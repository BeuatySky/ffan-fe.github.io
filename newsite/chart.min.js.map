{"version":3,"sources":["webpack:///chart.min.js","webpack:///./client/app/components/chart/chart.js","webpack:///./client/app/components/chart/chart.component.js","webpack:///./client/app/components/chart/chart.html","webpack:///./client/app/components/chart/chart.controller.js","webpack:///./~/echarts/lib/chart/pie.js","webpack:///./~/echarts/lib/chart/pie/PieSeries.js","webpack:///./~/echarts/lib/data/helper/completeDimensions.js","webpack:///./~/echarts/lib/component/helper/selectableMixin.js","webpack:///./~/echarts/lib/chart/pie/PieView.js","webpack:///./~/echarts/lib/action/createDataSelectAction.js","webpack:///./~/echarts/lib/visual/dataColor.js","webpack:///./~/echarts/lib/chart/pie/pieLayout.js","webpack:///./~/echarts/lib/chart/pie/labelLayout.js","webpack:///./~/echarts/lib/processor/dataFilter.js","webpack:///./~/echarts/lib/chart/gauge.js","webpack:///./~/echarts/lib/chart/gauge/GaugeSeries.js","webpack:///./~/echarts/lib/chart/gauge/GaugeView.js","webpack:///./~/echarts/lib/chart/gauge/PointerPath.js","webpack:///./~/echarts/lib/chart/line.js","webpack:///./~/echarts/lib/chart/line/LineSeries.js","webpack:///./~/echarts/lib/chart/helper/createListFromArray.js","webpack:///./~/echarts/lib/chart/line/LineView.js","webpack:///./~/echarts/lib/chart/helper/SymbolDraw.js","webpack:///./~/echarts/lib/chart/helper/Symbol.js","webpack:///./~/echarts/lib/util/symbol.js","webpack:///./~/echarts/lib/chart/line/lineAnimationDiff.js","webpack:///./~/echarts/lib/chart/line/poly.js","webpack:///./~/echarts/lib/visual/symbol.js","webpack:///./~/echarts/lib/layout/points.js","webpack:///./~/echarts/lib/processor/dataSample.js","webpack:///./~/echarts/lib/component/grid.js","webpack:///./~/echarts/lib/coord/cartesian/Grid.js","webpack:///./~/echarts/lib/coord/axisHelper.js","webpack:///./~/echarts/lib/scale/Ordinal.js","webpack:///./~/echarts/lib/scale/Scale.js","webpack:///./~/echarts/lib/scale/Interval.js","webpack:///./~/echarts/lib/scale/Time.js","webpack:///./~/echarts/lib/scale/Log.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian2D.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian.js","webpack:///./~/echarts/lib/coord/cartesian/Axis2D.js","webpack:///./~/echarts/lib/coord/Axis.js","webpack:///./~/echarts/lib/coord/cartesian/axisLabelInterval.js","webpack:///./~/echarts/lib/coord/cartesian/GridModel.js","webpack:///./~/echarts/lib/coord/cartesian/AxisModel.js","webpack:///./~/echarts/lib/coord/axisModelCreator.js","webpack:///./~/echarts/lib/coord/axisDefault.js","webpack:///./~/echarts/lib/coord/axisModelCommonMixin.js","webpack:///./~/echarts/lib/coord/axisModelZoomMixin.js","webpack:///./~/echarts/lib/component/axis.js","webpack:///./~/echarts/lib/component/axis/AxisView.js","webpack:///./~/echarts/lib/component/axis/AxisBuilder.js","webpack:///./~/echarts/lib/component/tooltip.js","webpack:///./~/echarts/lib/component/tooltip/TooltipModel.js","webpack:///./~/echarts/lib/component/tooltip/TooltipView.js","webpack:///./~/echarts/lib/component/tooltip/TooltipContent.js","webpack:///./~/echarts/lib/component/title.js","webpack:///./~/echarts/lib/component/legend.js","webpack:///./~/echarts/lib/component/legend/LegendModel.js","webpack:///./~/echarts/lib/component/legend/legendAction.js","webpack:///./~/echarts/lib/component/legend/LegendView.js","webpack:///./~/echarts/lib/component/helper/listComponent.js","webpack:///./~/echarts/lib/component/legend/legendFilter.js","webpack:///./client/app/components/chart/chart.less?56c1","webpack:///./client/app/components/chart/chart.less"],"names":["webpackJsonp","509","module","exports","__webpack_require__","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_chart","_chart2","angular","component","510","_chart3","_chart4","restrict","bindings","template","controller","controllerAs","511","512","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","ChartController","this","initPieChart","initGaugeChart","initLineChart","gaugeConfig","theme","dataLoaded","gaugeOption","series","name","z","type","startAngle","endAngle","center","radius","axisLine","lineStyle","width","color","axisTick","show","axisLabel","splitLine","pointer","title","detail","data","offsetCenter","textStyle","fontSize","fontFamily","fontWeight","self","pieConfig","pieOption","tooltip","trigger","formatter","legend","orient","x","top","oa","itemStyle","normal","label","labelLine","lineConfig","lineOption","text","subtext","textAlign","subtextStyle","display","grid","borderWidth","borderColor","right","align","xAxis","boundaryGap","interval","yAxis","smooth","513","zrUtil","echarts","event","method","registerVisual","curry","registerLayout","registerProcessor","514","List","modelUtil","completeDimensions","dataSelectableMixin","PieSeries","extendSeriesModel","init","option","superApply","arguments","legendDataProvider","_dataBeforeProcessed","updateSelectedMap","_defaultLabelLine","mergeOption","newOption","superCall","getInitialData","ecModel","dimensions","list","initData","getDataParams","dataIndex","_data","params","sum","getSum","percent","get","toFixed","$vars","push","defaultEmphasis","labelLineNormalOpt","labelLineEmphasisOpt","emphasis","defaultOption","zlevel","legendHoverLink","hoverAnimation","clockwise","minAngle","selectedOffset","avoidLabelOverlap","rotate","position","length2","animationEasing","mixin","515","defaultNames","extraPrefix","value0","retrieveValue","dimSize","isArray","guessOrdinal","o","isObject","dimIndex","len","isFinite","isString","516","targetList","_selectTargetMap","reduce","targetMap","select","selectedMode","each","selected","unSelect","toggleSelected","isSelected","517","updateDataSelected","uid","seriesModel","hasAnimation","api","getData","getName","dispatchAction","from","seriesId","id","idx","toggleItemSelected","getItemGraphicEl","getItemLayout","el","layout","midAngle","dx","Math","cos","dy","sin","offset","animate","when","start","attr","PiePiece","onEmphasis","polyline","ignore","hoverIgnore","onNormal","normalIgnore","graphic","Group","call","sector","Sector","z2","Polyline","Text","add","updateData","on","getLabelStyle","state","labelModel","labelPosition","textStyleModel","getModel","isLabelInside","fill","getTextColor","getItemVisual","opacity","textFont","getFont","retrieve","hostModel","getFormattedLabel","piePieceProto","firstCreate","stopAnimation","animateTo","shape","r","childAt","itemModel","getItemModel","sectorShape","extend","setShape","updateProps","itemStyleModel","visualColor","useStyle","defaults","lineJoin","getItemStyle","hoverStyle","off","ifEnableAnimation","_updateLabel","setHoverStyle","labelText","labelLayout","points","linePoints","y","style","textVerticalAlign","verticalAlign","font","rotation","origin","labelHoverModel","labelLineModel","labelLineHoverModel","setStyle","stroke","getLineStyle","inherits","Pie","sectorGroup","_sectorGroup","render","payload","oldData","group","isFirstRender","onSectorClick","diff","piePiece","eachChild","child","setItemGraphicEl","update","newIdx","oldIdx","remove","execute","count","max","getWidth","getHeight","removeClipPath","bind","setClipPath","_createClipPath","cx","cy","dispose","cb","clipPath","r0","initProps","PI","containPoint","point","itemLayout","sqrt","518","seriesType","actionInfos","actionInfo","registerAction","eachComponent","mainType","subType","query","519","paletteScope","eachRawSeriesByType","dataAll","getRawData","idxMap","isSeriesFiltered","rawIdx","getRawIndex","filteredIdx","singleDataColor","setItemVisual","getColorFromPalette","520","numberUtil","parsePercent","PI2","RADIAN","eachSeriesByType","height","size","min","unitRadian","roseType","extent","getDataExtent","restAngle","valueSumLargerThanMinAngle","currentAngle","dir","angle","setItemLayout","linearMap","521","adjustSingleSide","viewWidth","viewHeight","shiftDown","end","delta","j","shiftUp","changeX","isDownList","lastDeltaX","Number","MAX_VALUE","l","deltaY","abs","len2","deltaX","sort","a","b","lastY","upList","downList","avoidOverlap","labelLayoutList","leftList","rightList","dist","textContain","hasLabelRotate","textX","textY","labelLineLen","labelLineLen2","x1","y1","x2","y2","x3","y3","labelRotate","textRect","getBoundingRect","522","legendModels","findComponents","filterSelf","523","524","SeriesModel","GaugeSeries","dataOpt","splitNumber","distance","backgroundColor","525","parsePosition","formatLabel","labelFormatter","replace","PointerPath","GaugeView","removeAll","colorList","posInfo","_renderMain","axisLineModel","lineStyleModel","angleRangeSpan","prevEndAngle","axisLineWidth","silent","getColor","tmp","_renderTicks","_renderPointer","_renderTitle","_renderDetail","minVal","maxVal","splitLineModel","tickModel","subSplitNumber","splitLineLen","tickLen","step","subStep","splitLineStyle","tickLineStyle","unitX","unitY","Line","round","tickLine","valueExtent","angleExtent","eachItemGraphicEl","pointerModel","titleModel","detailModel","rect","Rect","textFill","526","buildPath","ctx","mathCos","mathSin","moveTo","lineTo","527","PRIORITY","PROCESSOR","STATISTIC","528","createListFromArray","dependencies","__DEV__","coordSys","coordinateSystem","Error","clipOverflow","smoothMonotone","symbol","symbolSize","symbolRotate","showSymbol","showAllSymbol","connectNulls","sampling","progressive","hoverLayerThreshold","Infinity","529","firstDataNotNull","ifNeedCompleteOrdinalData","sampleItem","getDataItemValue","coordSysName","creator","creators","registeredCoordSys","CoordinateSystem","axesInfo","concat","categoryIndex","nameList","createNameList","categories","dimValueGetter","itemOpt","dimName","isDataItemOption","hasItemOption","converDataValue","val","categoryAxesModels","getCategories","indexOf","isNaN","isStackable","axisType","getDimTypeByAxis","result","categoryAxisModel","categoryDim","dataLen","slice","cartesian2d","axesModels","map","queryComponents","index","xAxisModel","yAxisModel","xAxisType","yAxisType","stackable","isXAxisCateogry","isYAxisCategory","polar","polarModel","angleAxisModel","findAxisModel","radiusAxisModel","radiusAxisType","angleAxisType","isAngleAxisCateogry","isRadiusAxisCateogry","geo","530","isPointsSame","points1","points2","p1","p2","getSmooth","getAxisExtentWithGap","axis","getGlobalExtent","onBand","halfBandWidth","getBandWidth","sign","getStackedOnPoints","baseAxis","getBaseAxis","valueAxis","getOtherAxis","valueStart","onZero","scale","getExtent","valueDim","dim","baseDataOffset","mapArray","stackedOnSameSign","stackedOn","stackedData","dataToPoint","createGridClipShape","cartesian","xExtent","getAxis","yExtent","isHorizontal","lineWidth","expandSize","createPolarClipShape","angleAxis","getAngleAxis","radiusAxis","getRadiusAxis","radiusExtent","inverse","createClipShape","turnPointsIntoStep","stepTurnAt","baseIndex","stepPoints","nextPt","pt","stepPt","middle","stepPt2","clamp","number","getVisualGradient","visualMetaList","getVisual","visualMeta","dimension","console","warn","dataExtent","stops","colorStops","firstStop","lastStop","stopsSpan","gradient","LinearGradient","toGlobalCoord","dataToCoord","SymbolDraw","Symbol","lineAnimationDiff","polyHelper","ChartView","lineGroup","symbolDraw","_symbolDraw","_lineGroup","areaStyleModel","isCoordSysPolar","prevCoordSys","_coordSys","_polyline","polygon","_polygon","isAreaChart","isEmpty","stackedOnPoints","isSymbolIgnore","_getSymbolIgnoreFunc","__temp","_step","_newPolygon","_stackedOnPoints","_points","_updateAnimation","_newPolyline","stackedOnSmooth","getAreaStyle","stackedOnSeries","highlight","queryDataIndex","Array","setZ","stopSymbolAnimation","downplay","Polygon","categoryAxis","getAxesByScale","isLabelIgnored","current","stackedOnCurrent","next","stackedOnNext","__points","updatedDataInfo","diffStatus","status","cmd","idx1","ptIdx","animators","during","531","symbolCtor","_symbolCtor","symbolNeedsDraw","isIgnore","symbolDrawProto","SymbolCtor","seriesScope","hoverItemStyle","symbolOffset","hoverLabelModel","symbolEl","fadeOut","updateLayout","enableAnimation","532","normalizeSymbolSize","driftSymbol","parent","drift","symbolUtil","symbolProto","_createSymbol","symbolType","symbolPath","createSymbol","culling","_symbolType","toLastFrame","getSymbolPath","getScale","setDraggable","draggable","cursor","_updateCommon","_seriesModel","normalStyleAccessPath","emphasisStyleAccessPath","normalLabelAccessPath","emphasisLabelAccessPath","strokeNoScale","getShallow","elStyle","setColor","dataType","pop","getDimensionInfo","setText","ratio","533","BoundingRect","Triangle","extendShape","path","closePath","Diamond","Pin","w","h","asin","tanX","tanY","arc","cpLen","cpLen2","bezierCurveTo","Arrow","symbolCtors","line","roundRect","square","circle","Circle","diamond","pin","arrow","triangle","symbolShapeMakers","symbolBuildProxies","hasOwnProperty","beforeBrush","textPosition","inBundle","proxySymbol","symbolPathSetColor","symbolStyle","symbolShape","__isEmptyBrush","dirty","substr","toLowerCase","Image","image","makePath","534","getStackedOnPoint","diffData","newData","diffResult","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","currPoints","nextPoints","currStackedPoints","nextStackedPoints","sortedIndices","rawIndices","dims","diffItem","pointAdded","currentPt","rawIndex","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","535","isPointNull","p","drawSegment","segLen","allLen","smoothMin","smoothMax","prevIdx","k","v2Copy","cp0","nextIdx","nextP","ratioNextSeg","prevP","cp1","vec2","sub","v","lenPrevSeg","lenNextSeg","scaleAndAdd","vec2Min","vec2Max","getBoundingBox","smoothConstraint","ptMin","ptMax","Path","copy","bbox","stackedOnBBox","536","defaultSymbolType","legendSymbol","setVisual","rawValue","getRawValue","itemSymbolType","itemSymbolSize","537","NaN","538","samplers","average","frame","nearest","indexSampler","rate","sampler","downSample","setData","539","extendComponentView","gridModel","getRect","registerPreprocessor","540","isAxisUsedInTheGrid","axisModel","findGridModel","getLabelUnionRect","model","labels","getFormattedLabels","labelCount","ceil","singleRect","getTextRect","union","Grid","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","_model","updateAxisTransfrom","coordBase","axisExtent","axisExtentSum","coord","toLocalCoord","findAxesModels","axesTypes","getReferringComponents","isCartesian2D","axisHelper","Cartesian2D","Axis2D","ifAxisCrossZero","niceScaleExtent","gridProto","_rect","ifAxisCanNotOnZero","otherAxisDim","axes","axesMap","_updateScale","resize","adjustAxes","axesList","gridRect","setExtent","getLayoutRect","getBoxLayoutParams","labelUnionRect","margin","axisIndex","axesMapOnDim","getCartesian","xAxisIndex","yAxisIndex","coordList","convertToPixel","finder","_findConvertTarget","convertFromPixel","pointToData","coordToData","coordsList","componentIndex","createAxisCreator","axisPosition","axisPositionUsed","createScaleByModel","isCategory","axesCount","left","bottom","addAxis","unionExtent","coordDimToDataDim","eachSeries","create","grids","register","541","OrdinalScale","IntervalScale","Scale","getScaleExtent","originalExtent","span","getMin","getMax","crossZero","getNeedCrossZero","fixMin","fixMax","base","niceExtent","minInterval","getInterval","intervalScale","setInterval","getClass","getAxisLabelInterval","tickCoords","isAxisHorizontal","textSpaceTakenRect","autoLabelInterval","accumulatedLabelInterval","floor","tickCoord","intersect","clone","getTicksLabels","ticks","getTicks","tpl","tick","getLabel","542","scaleProto","_extent","parse","contain","rank","normalize","n","niceTicks","noop","543","_interval","apply","clazzUtil","other","thisExtent","enableClassExtend","enableClassManagement","registerWhenExtend","544","formatUtil","mathFloor","mathCeil","getPrecisionSafe","roundingErrorFix","parseFloat","_niceExtent","safeLimit","precision","addCommas","reverse","nice","545","intervalScaleProto","ONE_SECOND","ONE_MINUTE","ONE_HOUR","ONE_DAY","bisect","lo","hi","mid","TimeScale","stepLvl","_stepLvl","date","Date","formatTime","approxTickNum","d","getFullYear","getMonth","getDate","approxInterval","scaleLevelsLen","scaleLevels","level","yearSpan","yearStep","parseDate","methodName","546","fixRoundingError","originalVal","mathPow","pow","mathLog","log","LogScale","$constructor","_originalScale","originalScale","powVal","__fixMin","__fixMax","quantity","err","547","Cartesian","constructor","axisX","axisY","containData","dataToPoints","stack","548","dimAxisMapper","_axes","_dimList","getAxes","scaleType","filter","_dataCoordConvert","input","dimList","output","549","Axis","axisLabelInterval","coordExtent","ret","getLabelInterval","labelInterval","_labelInterval","550","fixExtentWithBands","nTick","normalizedExtent","getPixelPrecision","t","getTicksCoords","alignWithLabel","bands","getBands","coords","getLabelsCoords","551","552","ComponentModel","layoutMode","containLabel","553","getAxisType","axisDim","axisModelCreator","AxisModel","resetRange","restoreData","merge","extraOption","554","axisDefault","AXIS_TYPES","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","mergeDefaultAndTheme","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","mergeAll","registerSubTypeDefaulter","555","nameLocation","nameRotate","nameTruncate","maxWidth","ellipsis","placeholder","nameTextStyle","nameGap","triggerEvent","inside","splitArea","areaStyle","timeAxis","logAxis","logBase","556","557","rangeStart","rangeEnd","setRange","558","559","layoutAxis","getZero","theAxis","rawAxisPosition","rectBound","axisOffset","posMap","dirMap","labelDirection","tickDirection","nameDirection","labelOffset","labelRotation","AxisBuilder","ifIgnoreOnTick","axisBuilderAttrs","selfBuilderAttrs","AxisView","oldAxisGroup","_axisGroup","axisBuilder","getGroup","groupTransition","_splitLine","lineColors","lineInterval","lineCount","ticksCoords","colorIndex","subPixelOptimizeLine","anid","_splitArea","splitAreaModel","areaColors","prevX","prevY","areaInterval","560","makeAxisEventDataBase","eventData","componentType","innerTextLayout","opt","textRotation","direction","rotationDiff","remRadian","isRadianAroundZero","endTextLayout","textRotate","onLeft","isSilent","tooltipOpt","Model","v2ApplyTransform","applyTransform","dumbGroup","updateTransform","_transform","transform","_dumbGroup","hasBuilder","builders","matrix","pt1","pt2","lineCap","strokeContainThreshold","tickInterval","isTwoLabelOverlapped","firstRect","nextRect","getLocalTransform","axisLabelShow","labelMargin","categoryData","textEls","itemTextStyleModel","textColor","pos","labelBeforeFormat","textEl","targetType","decomposeTransform","firstLabel","nextLabel","lastLabel","prevLabel","gap","gapSignal","nameRotation","axisNameAvailableWidth","truncateOpt","truncatedText","truncateText","minChar","formatterParams","__fullText","__truncatedText","content","rawTick","561","562","extendComponentModel","showContent","triggerOn","alwaysShowContent","showDelay","hideDelay","transitionDuration","enterable","borderRadius","padding","extraCssText","axisPointer","animation","animationDurationUpdate","animationEasingUpdate","crossStyle","shadowStyle","563","dataEqual","makeLineShape","makeRectShape","makeSectorShape","refixTooltipPosition","clientWidth","clientHeight","calcTooltipPosition","dom","domWidth","domHeight","rectWidth","rectHeight","updatePosition","positionExpr","ifSeriesSupportAxisTrigger","TooltipContent","env","_axisPointers","node","tooltipContent","getDom","_tooltipContent","_manuallyShowTip","_manuallyHideTip","tooltipModel","_tooltipModel","_ecModel","_api","_lastHover","_alwaysShowContent","_seriesGroupByAxis","_prepareAxisTriggerData","crossText","_crossText","_lastX","_lastY","clearTimeout","_refreshUpdateTimeout","setTimeout","zr","getZr","_tryShow","_mousemove","_hide","e","_showTimeout","seriesIndex","getSeriesByIndex","_series","getTooltipPosition","getValues","offsetX","offsetY","handler","findHover","seriesGroupByAxis","globalTrigger","dataModel","_showAxisTooltip","_ticket","_hideAxisPointer","_resetLastHover","_showItemTooltipContent","dataIndexInside","subTooltipModel","defaultHtml","asyncTicket","random","_showTooltipContent","axisPointerModel","axisPointerType","_showAxisPointer","allNotShow","seriesCoordSysSameAxis","allCoordSys","contentNotChange","lastHover","valIndex","_showSinglePointer","_showPolarPointer","_showCartesianPointer","_dispatchAndShowSeriesTooltipContent","moveGridLine","otherExtent","targetShape","pointerEl","_getPointerElement","moveAnimation","moveGridShadow","bandWidth","_updateCrossText","otherAxis","single","moveSingleLine","movePolarLine","mouseCoord","pointToCoord","coordToPoint","movePolarShadow","radian","crossStyleModel","join","initShape","axisPointers","pointerType","styleModel","isShadow","elementType","seriesList","rootTooltipModel","baseDimIndex","payloadBatch","getAxisTooltipDataIndex","indexOfNearest","batch","paramsList","firstDataIndex","firstLine","formatTooltip","seriesTooltipModel","html","formatTpl","ticket","callback","cbTicket","setContent","hide","children","hideLater","564","assembleTransition","duration","transitionCurve","transitionText","vendors","vendorPrefix","assembleFont","cssText","assembleCssText","canvasSupported","zrColor","toHex","borderName","camelCase","toCamelCase","normalizeCssArray","container","document","createElement","_x","_y","appendChild","_container","_show","_hideTimeout","onmouseenter","_inContent","onmousemove","window","eventUtil","normalizeEvent","dispatch","onmouseleave","_hideDelay","compromiseMobile","tooltipContentEl","preventDefault","contains","targetEl","parentNode","addEventListener","gCssText","stl","currentStyle","defaultView","getComputedStyle","domStyle","innerHTML","time","isShow","565","ignoreSize","subtarget","itemGap","subtextStyleModel","textBaseline","subText","subTextEl","link","sublink","open","groupRect","layoutOption","layoutRect","alignStyle","subPixelOptimizeRect","566","567","LegendModel","parentModel","optionUpdated","_updateData","legendData","hasSelected","dataItem","availableNames","getSeries","_availableNames","itemWidth","itemHeight","inactiveColor","568","legendSelectActionHandler","selectedMap","isToggleSelect","legendModel","isItemSelected","569","dispatchSelectAction","dispatchHighlightAction","dataName","storage","getDisplayList","useHoverLayer","seriesName","dispatchDownplayAction","symbolCreator","listComponentHelper","_symbolTypeStore","selectMode","itemAlign","legendDrawedMap","newline","getSeriesByName","legendSymbolType","itemGroup","_createItem","eachRawSeries","indexOfName","addBackground","itemIcon","legendGlobalTooltipModel","hitRect","invisible","legendIndex","570","positionGroup","componentModel","box","boundingRect","571","filterSeries","572","locals","573"],"mappings":"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","file":"chart.min.js","sourcesContent":["webpackJsonp([16],{\n\n/***/ 509:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _chart = __webpack_require__(510);\n\t\n\tvar _chart2 = _interopRequireDefault(_chart);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = angular.module('chart', [])\n\t/**\n\t * 轻在routerConfig.js里定义路由\n\t */\n\t.component('chart', _chart2.default);\n\n/***/ },\n\n/***/ 510:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _chart = __webpack_require__(511);\n\t\n\tvar _chart2 = _interopRequireDefault(_chart);\n\t\n\tvar _chart3 = __webpack_require__(512);\n\t\n\tvar _chart4 = _interopRequireDefault(_chart3);\n\t\n\t__webpack_require__(572);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t  restrict: 'E',\n\t  bindings: {},\n\t  template: _chart2.default,\n\t  controller: _chart4.default,\n\t  controllerAs: 'vm'\n\t};\n\n/***/ },\n\n/***/ 511:\n/***/ function(module, exports) {\n\n\tmodule.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1>图表</h1>\\n\\t<h2>饼图</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"bs-example\\\">\\n\\t<div class=\\\"col-md-4 echarts-container\\\">\\n\\t\\t<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.pieConfig\\\" ec-option=\\\"vm.pieOption\\\" ></ng-echarts>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.pieConfig\\\" ec-option=\\\"vm.pieOption\\\" ></ng-echarts>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nlet self = this;\\nself.pieConfig = {\\n\\ttheme: 'default',\\n\\tdataLoaded: true\\n};\\n\\nself.pieOption = {\\n\\ttooltip: {\\n\\t\\ttrigger: 'item',\\n\\t\\tformatter: \\\"{a} <br/>{b} : {c} ({d}%)\\\"\\n\\t},\\n\\tlegend: {\\n\\t\\torient: 'vertical',\\n\\t\\tx: '65%',\\n\\t\\ttop: '25%',\\n\\t\\tdata: ['正常', '断开', '等待'],\\n\\t\\tformatter: function (name) {\\n\\t\\t\\tvar oa = self.pieOption.series[0].data;\\n\\t\\t\\tfor (var i = 0; i < self.pieOption.series[0].data.length; i++) {\\n\\t\\t\\t\\tif (name == oa[i].name) {\\n\\t\\t\\t\\t\\treturn name + ':' + oa[i].value + '个';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\tcolor: ['#bdea75', '#fe5454', '#faba3c'],\\n\\tseries: [{\\n\\t\\tname: '比例分析',\\n\\t\\ttype: 'pie',\\n\\t\\tradius: '55%',\\n\\t\\tcenter: ['35%', '50%'],\\n\\t\\tdata: [\\n\\t\\t{\\n\\t\\t\\tvalue: '2',\\n\\t\\t\\tname: '正常'\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tvalue: '2',\\n\\t\\t\\tname: '断开'\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tvalue: '2',\\n\\t\\t\\tname: '等待'\\n\\t\\t}],\\n\\t\\titemStyle: {\\n\\t\\t\\tnormal: {\\n\\t\\t\\t\\tlabel: {\\n\\t\\t\\t\\t\\tshow: false,\\n\\t\\t\\t\\t\\tformatter: '{b} : {c} ({d}%)'\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tlabelLine: {\\n\\t\\t\\t\\tshow: true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}]\\n};\\n</div>\\n</div>\\n\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>仪表盘</h2>\\n</section>\\n<div class=\\\"example-block\\\">\\n<div class=\\\"bs-example\\\">\\n\\t<div class=\\\"col-md-4 echarts-container\\\">\\n\\t\\t<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.gaugeConfig\\\" ec-option=\\\"vm.gaugeOption\\\" ></ng-echarts>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.gaugeConfig\\\" ec-option=\\\"vm.gaugeOption\\\" ></ng-echarts>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nthis.gaugeConfig = {\\n\\ttheme: 'default',\\n\\tdataLoaded: true\\n};\\nthis.gaugeOption = {\\n\\tseries: [{\\n\\t\\tname: \\\"外层\\\",\\n\\t\\tz: 3,\\n\\t\\ttype: \\\"gauge\\\",\\n\\t\\tstartAngle: 180, //总的360，设置180就是半圆\\n\\t\\tendAngle: 0,\\n\\t\\tcenter: [\\\"50%\\\", \\\"77%\\\"], //整体的位置设置\\n\\t\\tradius: 80,\\n\\t\\taxisLine: {\\n\\t\\t\\tlineStyle: {\\n\\t\\t\\t\\twidth: 3, //柱子的宽度\\n\\t\\t\\t\\tcolor: [[1, \\\"#1fbba6\\\"], [1, \\\"#dbdbdb\\\"]]\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\taxisTick: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\taxisLabel: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tsplitLine: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tpointer: {\\n\\t\\t\\twidth: 0, //指针的宽度\\n\\t\\t\\tlength: \\\"80%\\\", //指针长度，按照半圆半径的百分比\\n\\t\\t\\tcolor: \\\"#2d99e2\\\"\\n\\t\\t},\\n\\t\\ttitle: {\\n\\t\\tshow: false\\n\\t\\t},\\n\\t\\tdetail: {\\n\\t\\tshow: false\\n\\t\\t},\\n\\t\\tdata: [{ //显示数据\\n\\t\\t\\tvalue: 100,\\n\\t\\t\\tname: \\\"100%\\\"\\n\\t\\t}]\\n\\t},\\n\\t{\\n\\t\\tname: \\\"内层\\\",\\n\\t\\ttype: \\\"gauge\\\",\\n\\t\\tstartAngle: 180, //总的360，设置180就是半圆\\n\\t\\tendAngle: 0,\\n\\t\\tcenter: [\\\"50%\\\", \\\"77%\\\"], //整体的位置设置\\n\\t\\tradius: 75,\\n\\t\\taxisLine: {\\n\\t\\t\\tlineStyle: {\\n\\t\\t\\twidth: 30, //柱子的宽度\\n\\t\\t\\tcolor: [[0.305, \\\"#1fbba6\\\"], [1, \\\"#dbdbdb\\\"]] //0.298是百分比的比例值（小数），还有对应两个颜色值\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\taxisTick: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\taxisLabel: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tsplitLine: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tpointer: {\\n\\t\\t\\twidth: 0, //指针的宽度\\n\\t\\t\\tlength: \\\"80%\\\", //指针长度，按照半圆半径的百分比\\n\\t\\t\\tcolor: \\\"#2d99e2\\\"\\n\\t\\t},\\n\\t\\ttitle: {\\n\\t\\t\\tshow: true,\\n\\t\\t\\toffsetCenter: [0, '-10px'], //标题位置设置\\n\\t\\t\\ttextStyle: { //标题样式设置\\n\\t\\t\\tcolor: \\\"#1fbba6\\\",\\n\\t\\t\\tfontSize: 18,\\n\\t\\t\\tfontFamily: \\\"Arial\\\",\\n\\t\\t\\tfontWeight: \\\"normal\\\"\\n\\t\\t}\\n\\t},\\n\\tdetail: {\\n\\t\\tshow: false\\n\\t},\\n\\tdata: [{ //显示数据\\n\\t\\tvalue: 30.50,\\n\\t\\tname: \\\"30.50%\\\"\\n\\t}]\\n}]\\n};\\n</div>\\n</div>\\n\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>曲线图</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"bs-example\\\">\\n\\t<div class=\\\"col-md-12 echarts-container\\\" style=\\\"height: 400px\\\">\\n\\t\\t<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.lineConfig\\\" ec-option=\\\"vm.lineOption\\\" ></ng-echarts>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.lineConfig\\\" ec-option=\\\"vm.lineOption\\\" ></ng-echarts>\\n</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nlet self =  this;\\nthis.lineConfig = {\\n\\ttheme: 'default',\\n\\tdataLoaded: true\\n};\\n\\nthis.lineOption = {\\n\\ttitle: {\\n\\t\\ttext: '内存使用情况',\\n\\t\\tsubtext: 'pod memory usage',\\n\\t\\ttextAlign: 'left',\\n\\t\\tx: \\\"0\\\",\\n\\t\\ttextStyle: {\\n\\t\\t\\tcolor: '#666',\\n\\t\\t\\tfontSize: '14'\\n\\t\\t},\\n\\t\\tsubtextStyle: {\\n\\t\\t\\tcolor: '#d6d6d6',\\n\\t\\t\\tfontSize: '12',\\n\\t\\t\\tdisplay: 'inline'\\n\\t\\t}\\n\\t},\\n\\tgrid: {\\n\\t\\tborderWidth: 0,\\n\\t\\tborderColor: '#f2f2f2'\\n\\t},\\n\\tlegend: {\\n\\t\\torient: 'horizontal',\\n\\t\\ttop: '0',\\n\\t\\tright: '0',\\n\\t\\talign: 'left',\\n\\t\\tdata: ['op-lodgings-sync', 'elasticsearch-logging']\\n\\t},\\n\\ttooltip: {\\n\\t\\ttrigger: 'axis'\\n\\t},\\n\\txAxis: {\\n\\t\\ttype: 'category',\\n\\t\\tboundaryGap: false,\\n\\t\\tdata: ['13:25', '13:30', '13:35', '13:40', '13:45', '13:50', '13:55', '14:00', '14:05', '14:10', '14:15', '14:20'],\\n\\t\\tsplitLine: {\\n\\t\\t\\tshow: true,\\n\\t\\t\\tinterval: 'auto'\\n\\t\\t}\\n\\t},\\n\\tyAxis: {\\n\\t\\ttype: 'value',\\n\\t\\taxisLabel: {\\n\\t\\t\\tformatter: '{value} GiB'\\n\\t\\t}\\n\\t},\\n\\tcolor: ['#64b1e4', '#fa9073'],\\n\\tseries: [\\n\\t\\t{\\n\\t\\t\\tname: 'op-lodgings-sync',\\n\\t\\t\\ttype: 'line',\\n\\t\\t\\tsmooth: false,\\n\\t\\t\\tdata: [1.1, 4.5, 3.4, 1.7, 3.8, 2.1, 4.5, 4.7, 5.1, 3.8, 5.5, 6.2]\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: 'elasticsearch-logging',\\n\\t\\t\\ttype: 'line',\\n\\t\\t\\tsmooth: false,\\n\\t\\t\\tdata: [2.6, 3.7, 5.1, 8.2, 3.2, 6.1, 3.9, 4.5, 3.4, 1.7, 3.8, 2.1]\\n\\t\\t}\\n\\t]\\n};\\n</div>\\n</div>\\n\"\n\n/***/ },\n\n/***/ 512:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * (description)\n\t *\n\t * @author yourname\n\t */\n\t\n\t// include pie chart\n\t__webpack_require__(513);\n\t// include gauge chart\n\t__webpack_require__(523);\n\t// include line chart\n\t__webpack_require__(527);\n\t\n\t// include tooltip component\n\t__webpack_require__(561);\n\t// include title component\n\t__webpack_require__(565);\n\t// include legend component\n\t__webpack_require__(566);\n\t\n\tvar ChartController = function () {\n\t\tfunction ChartController() {\n\t\t\t\"ngInject\";\n\t\n\t\t\t_classCallCheck(this, ChartController);\n\t\n\t\t\tthis.initPieChart();\n\t\t\tthis.initGaugeChart();\n\t\t\tthis.initLineChart();\n\t\t}\n\t\n\t\t_createClass(ChartController, [{\n\t\t\tkey: 'initGaugeChart',\n\t\t\tvalue: function initGaugeChart() {\n\t\t\t\tthis.gaugeConfig = {\n\t\t\t\t\ttheme: 'default',\n\t\t\t\t\tdataLoaded: true\n\t\t\t\t};\n\t\n\t\t\t\tthis.gaugeOption = {\n\t\t\t\t\tseries: [{\n\t\t\t\t\t\tname: \"外层\",\n\t\t\t\t\t\tz: 3,\n\t\t\t\t\t\ttype: \"gauge\",\n\t\t\t\t\t\tstartAngle: 180, //总的360，设置180就是半圆\n\t\t\t\t\t\tendAngle: 0,\n\t\t\t\t\t\tcenter: [\"50%\", \"77%\"], //整体的位置设置\n\t\t\t\t\t\tradius: 80,\n\t\t\t\t\t\taxisLine: {\n\t\t\t\t\t\t\tlineStyle: {\n\t\t\t\t\t\t\t\twidth: 3, //柱子的宽度\n\t\t\t\t\t\t\t\tcolor: [[1, \"#1fbba6\"], [1, \"#dbdbdb\"]] //0.298是百分比的比例值（小数），还有对应两个颜色值\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\taxisTick: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\taxisLabel: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsplitLine: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpointer: {\n\t\t\t\t\t\t\twidth: 0, //指针的宽度\n\t\t\t\t\t\t\tlength: \"80%\", //指针长度，按照半圆半径的百分比\n\t\t\t\t\t\t\tcolor: \"#2d99e2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttitle: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdata: [{ //显示数据\n\t\t\t\t\t\t\tvalue: 100,\n\t\t\t\t\t\t\tname: \"100%\"\n\t\t\t\t\t\t}]\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: \"内层\",\n\t\t\t\t\t\ttype: \"gauge\",\n\t\t\t\t\t\tstartAngle: 180, //总的360，设置180就是半圆\n\t\t\t\t\t\tendAngle: 0,\n\t\t\t\t\t\tcenter: [\"50%\", \"77%\"], //整体的位置设置\n\t\t\t\t\t\tradius: 75,\n\t\t\t\t\t\taxisLine: {\n\t\t\t\t\t\t\tlineStyle: {\n\t\t\t\t\t\t\t\twidth: 30, //柱子的宽度\n\t\t\t\t\t\t\t\tcolor: [[0.305, \"#1fbba6\"], [1, \"#dbdbdb\"]] //0.298是百分比的比例值（小数），还有对应两个颜色值\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\taxisTick: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\taxisLabel: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsplitLine: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpointer: {\n\t\t\t\t\t\t\twidth: 0, //指针的宽度\n\t\t\t\t\t\t\tlength: \"80%\", //指针长度，按照半圆半径的百分比\n\t\t\t\t\t\t\tcolor: \"#2d99e2\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttitle: {\n\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\toffsetCenter: [0, '-10px'], //标题位置设置\n\t\t\t\t\t\t\ttextStyle: { //标题样式设置\n\t\t\t\t\t\t\t\tcolor: \"#1fbba6\",\n\t\t\t\t\t\t\t\tfontSize: 18,\n\t\t\t\t\t\t\t\tfontFamily: \"Arial\",\n\t\t\t\t\t\t\t\tfontWeight: \"normal\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdetail: {\n\t\t\t\t\t\t\tshow: false\n\t\t\t\t\t\t},\n\t\t\t\t\t\tdata: [{ //显示数据\n\t\t\t\t\t\t\tvalue: 30.50,\n\t\t\t\t\t\t\tname: \"30.50%\"\n\t\t\t\t\t\t}]\n\t\t\t\t\t}]\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'initPieChart',\n\t\t\tvalue: function initPieChart() {\n\t\t\t\tvar self = this;\n\t\t\t\tself.pieConfig = {\n\t\t\t\t\ttheme: 'default',\n\t\t\t\t\tdataLoaded: true\n\t\t\t\t};\n\t\n\t\t\t\tself.pieOption = {\n\t\t\t\t\ttooltip: {\n\t\t\t\t\t\ttrigger: 'item',\n\t\t\t\t\t\tformatter: \"{a} <br/>{b} : {c} ({d}%)\"\n\t\t\t\t\t},\n\t\t\t\t\tlegend: {\n\t\t\t\t\t\torient: 'vertical',\n\t\t\t\t\t\tx: '65%',\n\t\t\t\t\t\ttop: '25%',\n\t\t\t\t\t\tdata: ['正常', '断开', '等待'],\n\t\t\t\t\t\tformatter: function formatter(name) {\n\t\t\t\t\t\t\tvar oa = self.pieOption.series[0].data;\n\t\t\t\t\t\t\tfor (var i = 0; i < self.pieOption.series[0].data.length; i++) {\n\t\t\t\t\t\t\t\tif (name == oa[i].name) {\n\t\t\t\t\t\t\t\t\treturn name + ':' + oa[i].value + '个';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcolor: ['#bdea75', '#fe5454', '#faba3c'],\n\t\t\t\t\tseries: [{\n\t\t\t\t\t\tname: '比例分析',\n\t\t\t\t\t\ttype: 'pie',\n\t\t\t\t\t\tradius: '55%',\n\t\t\t\t\t\tcenter: ['35%', '50%'],\n\t\t\t\t\t\tdata: [{\n\t\t\t\t\t\t\tvalue: '2',\n\t\t\t\t\t\t\tname: '正常'\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tvalue: '2',\n\t\t\t\t\t\t\tname: '断开'\n\t\t\t\t\t\t}, {\n\t\t\t\t\t\t\tvalue: '2',\n\t\t\t\t\t\t\tname: '等待'\n\t\t\t\t\t\t}],\n\t\t\t\t\t\titemStyle: {\n\t\t\t\t\t\t\tnormal: {\n\t\t\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\t\t\tshow: false,\n\t\t\t\t\t\t\t\t\tformatter: '{b} : {c} ({d}%)'\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tlabelLine: {\n\t\t\t\t\t\t\t\tshow: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t\t};\n\t\t\t}\n\t\t}, {\n\t\t\tkey: 'initLineChart',\n\t\t\tvalue: function initLineChart() {\n\t\t\t\tvar self = this;\n\t\t\t\tthis.lineConfig = {\n\t\t\t\t\ttheme: 'default',\n\t\t\t\t\tdataLoaded: true\n\t\t\t\t};\n\t\n\t\t\t\tthis.lineOption = {\n\t\t\t\t\ttitle: {\n\t\t\t\t\t\ttext: '内存使用情况',\n\t\t\t\t\t\tsubtext: 'pod memory usage',\n\t\t\t\t\t\ttextAlign: 'left',\n\t\t\t\t\t\tx: \"0\",\n\t\t\t\t\t\ttextStyle: {\n\t\t\t\t\t\t\tcolor: '#666',\n\t\t\t\t\t\t\tfontSize: '14'\n\t\t\t\t\t\t},\n\t\t\t\t\t\tsubtextStyle: {\n\t\t\t\t\t\t\tcolor: '#d6d6d6',\n\t\t\t\t\t\t\tfontSize: '12',\n\t\t\t\t\t\t\tdisplay: 'inline'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tgrid: {\n\t\t\t\t\t\tborderWidth: 0,\n\t\t\t\t\t\tborderColor: '#f2f2f2'\n\t\t\t\t\t},\n\t\t\t\t\tlegend: {\n\t\t\t\t\t\torient: 'horizontal',\n\t\t\t\t\t\ttop: '0',\n\t\t\t\t\t\tright: '0',\n\t\t\t\t\t\talign: 'left',\n\t\t\t\t\t\tdata: ['op-lodgings-sync', 'elasticsearch-logging']\n\t\t\t\t\t},\n\t\t\t\t\ttooltip: {\n\t\t\t\t\t\ttrigger: 'axis'\n\t\t\t\t\t},\n\t\t\t\t\txAxis: {\n\t\t\t\t\t\ttype: 'category',\n\t\t\t\t\t\tboundaryGap: false,\n\t\t\t\t\t\tdata: ['13:25', '13:30', '13:35', '13:40', '13:45', '13:50', '13:55', '14:00', '14:05', '14:10', '14:15', '14:20'],\n\t\t\t\t\t\tsplitLine: {\n\t\t\t\t\t\t\tshow: true,\n\t\t\t\t\t\t\tinterval: 'auto'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tyAxis: {\n\t\t\t\t\t\ttype: 'value',\n\t\t\t\t\t\taxisLabel: {\n\t\t\t\t\t\t\tformatter: '{value} GiB'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tcolor: ['#64b1e4', '#fa9073'],\n\t\t\t\t\tseries: [{\n\t\t\t\t\t\tname: 'op-lodgings-sync',\n\t\t\t\t\t\ttype: 'line',\n\t\t\t\t\t\tsmooth: false,\n\t\t\t\t\t\tdata: [1.1, 4.5, 3.4, 1.7, 3.8, 2.1, 4.5, 4.7, 5.1, 3.8, 5.5, 6.2]\n\t\t\t\t\t}, {\n\t\t\t\t\t\tname: 'elasticsearch-logging',\n\t\t\t\t\t\ttype: 'line',\n\t\t\t\t\t\tsmooth: false,\n\t\t\t\t\t\tdata: [2.6, 3.7, 5.1, 8.2, 3.2, 6.1, 3.9, 4.5, 3.4, 1.7, 3.8, 2.1]\n\t\t\t\t\t}]\n\t\t\t\t};\n\t\t\t}\n\t\t}]);\n\t\n\t\treturn ChartController;\n\t}();\n\t\n\texports.default = ChartController;\n\n/***/ },\n\n/***/ 513:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var echarts = __webpack_require__(122);\n\t\n\t    __webpack_require__(514);\n\t    __webpack_require__(517);\n\t\n\t    __webpack_require__(518)('pie', [{\n\t        type: 'pieToggleSelect',\n\t        event: 'pieselectchanged',\n\t        method: 'toggleSelected'\n\t    }, {\n\t        type: 'pieSelect',\n\t        event: 'pieselected',\n\t        method: 'select'\n\t    }, {\n\t        type: 'pieUnSelect',\n\t        event: 'pieunselected',\n\t        method: 'unSelect'\n\t    }]);\n\t\n\t    echarts.registerVisual(zrUtil.curry(__webpack_require__(519), 'pie'));\n\t\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(520), 'pie'\n\t    ));\n\t\n\t    echarts.registerProcessor(zrUtil.curry(__webpack_require__(522), 'pie'));\n\n\n/***/ },\n\n/***/ 514:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(218);\n\t    var zrUtil = __webpack_require__(125);\n\t    var modelUtil = __webpack_require__(126);\n\t    var completeDimensions = __webpack_require__(515);\n\t\n\t    var dataSelectableMixin = __webpack_require__(516);\n\t\n\t    var PieSeries = __webpack_require__(122).extendSeriesModel({\n\t\n\t        type: 'series.pie',\n\t\n\t        // Overwrite\n\t        init: function (option) {\n\t            PieSeries.superApply(this, 'init', arguments);\n\t\n\t            // Enable legend selection for each data item\n\t            // Use a function instead of direct access because data reference may changed\n\t            this.legendDataProvider = function () {\n\t                return this._dataBeforeProcessed;\n\t            };\n\t\n\t            this.updateSelectedMap(option.data);\n\t\n\t            this._defaultLabelLine(option);\n\t        },\n\t\n\t        // Overwrite\n\t        mergeOption: function (newOption) {\n\t            PieSeries.superCall(this, 'mergeOption', newOption);\n\t            this.updateSelectedMap(this.option.data);\n\t        },\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            var dimensions = completeDimensions(['value'], option.data);\n\t            var list = new List(dimensions, this);\n\t            list.initData(option.data);\n\t            return list;\n\t        },\n\t\n\t        // Overwrite\n\t        getDataParams: function (dataIndex) {\n\t            var data = this._data;\n\t            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n\t            var sum = data.getSum('value');\n\t            // FIXME toFixed?\n\t            //\n\t            // Percent is 0 if sum is 0\n\t            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\t\n\t            params.$vars.push('percent');\n\t            return params;\n\t        },\n\t\n\t        _defaultLabelLine: function (option) {\n\t            // Extend labelLine emphasis\n\t            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\t\n\t            var labelLineNormalOpt = option.labelLine.normal;\n\t            var labelLineEmphasisOpt = option.labelLine.emphasis;\n\t            // Not show label line if `label.normal.show = false`\n\t            labelLineNormalOpt.show = labelLineNormalOpt.show\n\t                && option.label.normal.show;\n\t            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n\t                && option.label.emphasis.show;\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // 默认全局居中\n\t            center: ['50%', '50%'],\n\t            radius: [0, '75%'],\n\t            // 默认顺时针\n\t            clockwise: true,\n\t            startAngle: 90,\n\t            // 最小角度改为0\n\t            minAngle: 0,\n\t            // 选中是扇区偏移量\n\t            selectedOffset: 10,\n\t\n\t            // If use strategy to avoid label overlapping\n\t            avoidLabelOverlap: true,\n\t            // 选择模式，默认关闭，可选single，multiple\n\t            // selectedMode: false,\n\t            // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n\t            // roseType: null,\n\t\n\t            label: {\n\t                normal: {\n\t                    // If rotate around circle\n\t                    rotate: false,\n\t                    show: true,\n\t                    // 'outer', 'inside', 'center'\n\t                    position: 'outer'\n\t                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n\t                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n\t                    // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n\t                },\n\t                emphasis: {}\n\t            },\n\t            // Enabled when label.normal.position is 'outer'\n\t            labelLine: {\n\t                normal: {\n\t                    show: true,\n\t                    // 引导线两段中的第一段长度\n\t                    length: 15,\n\t                    // 引导线两段中的第二段长度\n\t                    length2: 15,\n\t                    smooth: false,\n\t                    lineStyle: {\n\t                        // color: 各异,\n\t                        width: 1,\n\t                        type: 'solid'\n\t                    }\n\t                }\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    borderWidth: 1\n\t                },\n\t                emphasis: {}\n\t            },\n\t\n\t            animationEasing: 'cubicOut',\n\t\n\t            data: []\n\t        }\n\t    });\n\t\n\t    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\t\n\t    module.exports = PieSeries;\n\n\n/***/ },\n\n/***/ 515:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Complete dimensions by data (guess dimension).\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    /**\n\t     * Complete the dimensions array guessed from the data structure.\n\t     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n\t     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n\t     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n\t     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n\t     * @return {Array.<string>}\n\t     */\n\t    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n\t        if (!data) {\n\t            return dimensions;\n\t        }\n\t\n\t        var value0 = retrieveValue(data[0]);\n\t        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\t\n\t        defaultNames = defaultNames || [];\n\t        extraPrefix = extraPrefix || 'extra';\n\t        for (var i = 0; i < dimSize; i++) {\n\t            if (!dimensions[i]) {\n\t                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n\t                dimensions[i] = guessOrdinal(data, i)\n\t                    ? {type: 'ordinal', name: name}\n\t                    : name;\n\t            }\n\t        }\n\t\n\t        return dimensions;\n\t    }\n\t\n\t    // The rule should not be complex, otherwise user might not\n\t    // be able to known where the data is wrong.\n\t    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n\t        for (var i = 0, len = data.length; i < len; i++) {\n\t            var value = retrieveValue(data[i]);\n\t\n\t            if (!zrUtil.isArray(value)) {\n\t                return false;\n\t            }\n\t\n\t            var value = value[dimIndex];\n\t            if (value != null && isFinite(value)) {\n\t                return false;\n\t            }\n\t            else if (zrUtil.isString(value) && value !== '-') {\n\t                return true;\n\t            }\n\t        }\n\t        return false;\n\t    };\n\t\n\t    function retrieveValue(o) {\n\t        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n\t    }\n\t\n\t    module.exports = completeDimensions;\n\t\n\n\n/***/ },\n\n/***/ 516:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Data selectable mixin for chart series.\n\t * To eanble data select, option of series must have `selectedMode`.\n\t * And each data item will use `selected` to toggle itself selected status\n\t *\n\t * @module echarts/chart/helper/DataSelectable\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    module.exports = {\n\t\n\t        updateSelectedMap: function (targetList) {\n\t            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n\t                targetMap[target.name] = target;\n\t                return targetMap;\n\t            }, {});\n\t        },\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        // PENGING If selectedMode is null ?\n\t        select: function (name) {\n\t            var targetMap = this._selectTargetMap;\n\t            var target = targetMap[name];\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                zrUtil.each(targetMap, function (target) {\n\t                    target.selected = false;\n\t                });\n\t            }\n\t            target && (target.selected = true);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            // var selectedMode = this.get('selectedMode');\n\t            // selectedMode !== 'single' && target && (target.selected = false);\n\t            target && (target.selected = false);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            if (target != null) {\n\t                this[target.selected ? 'unSelect' : 'select'](name);\n\t                return target.selected;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var target = this._selectTargetMap[name];\n\t            return target && target.selected;\n\t        }\n\t    };\n\n\n/***/ },\n\n/***/ 517:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var graphic = __webpack_require__(164);\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    /**\n\t     * @param {module:echarts/model/Series} seriesModel\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n\t        var data = seriesModel.getData();\n\t        var dataIndex = this.dataIndex;\n\t        var name = data.getName(dataIndex);\n\t        var selectedOffset = seriesModel.get('selectedOffset');\n\t\n\t        api.dispatchAction({\n\t            type: 'pieToggleSelect',\n\t            from: uid,\n\t            name: name,\n\t            seriesId: seriesModel.id\n\t        });\n\t\n\t        data.each(function (idx) {\n\t            toggleItemSelected(\n\t                data.getItemGraphicEl(idx),\n\t                data.getItemLayout(idx),\n\t                seriesModel.isSelected(data.getName(idx)),\n\t                selectedOffset,\n\t                hasAnimation\n\t            );\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @param {module:zrender/graphic/Sector} el\n\t     * @param {Object} layout\n\t     * @param {boolean} isSelected\n\t     * @param {number} selectedOffset\n\t     * @param {boolean} hasAnimation\n\t     * @inner\n\t     */\n\t    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n\t        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t\n\t        var dx = Math.cos(midAngle);\n\t        var dy = Math.sin(midAngle);\n\t\n\t        var offset = isSelected ? selectedOffset : 0;\n\t        var position = [dx * offset, dy * offset];\n\t\n\t        hasAnimation\n\t            // animateTo will stop revious animation like update transition\n\t            ? el.animate()\n\t                .when(200, {\n\t                    position: position\n\t                })\n\t                .start('bounceOut')\n\t            : el.attr('position', position);\n\t    }\n\t\n\t    /**\n\t     * Piece of pie including Sector, Label, LabelLine\n\t     * @constructor\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function PiePiece(data, idx) {\n\t\n\t        graphic.Group.call(this);\n\t\n\t        var sector = new graphic.Sector({\n\t            z2: 2\n\t        });\n\t        var polyline = new graphic.Polyline();\n\t        var text = new graphic.Text();\n\t        this.add(sector);\n\t        this.add(polyline);\n\t        this.add(text);\n\t\n\t        this.updateData(data, idx, true);\n\t\n\t        // Hover to change label and labelLine\n\t        function onEmphasis() {\n\t            polyline.ignore = polyline.hoverIgnore;\n\t            text.ignore = text.hoverIgnore;\n\t        }\n\t        function onNormal() {\n\t            polyline.ignore = polyline.normalIgnore;\n\t            text.ignore = text.normalIgnore;\n\t        }\n\t        this.on('emphasis', onEmphasis)\n\t            .on('normal', onNormal)\n\t            .on('mouseover', onEmphasis)\n\t            .on('mouseout', onNormal);\n\t    }\n\t\n\t    var piePieceProto = PiePiece.prototype;\n\t\n\t    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n\t        var textStyleModel = labelModel.getModel('textStyle');\n\t        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t        return {\n\t            fill: textStyleModel.getTextColor()\n\t                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n\t            opacity: data.getItemVisual(idx, 'opacity'),\n\t            textFont: textStyleModel.getFont(),\n\t            text: zrUtil.retrieve(\n\t                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n\t            )\n\t        };\n\t    }\n\t\n\t    piePieceProto.updateData = function (data, idx, firstCreate) {\n\t\n\t        var sector = this.childAt(0);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var sectorShape = zrUtil.extend({}, layout);\n\t        sectorShape.label = null;\n\t        if (firstCreate) {\n\t            sector.setShape(sectorShape);\n\t            sector.shape.endAngle = layout.startAngle;\n\t            graphic.updateProps(sector, {\n\t                shape: {\n\t                    endAngle: layout.endAngle\n\t                }\n\t            }, seriesModel, idx);\n\t        }\n\t        else {\n\t            graphic.updateProps(sector, {\n\t                shape: sectorShape\n\t            }, seriesModel, idx);\n\t        }\n\t\n\t        // Update common style\n\t        var itemStyleModel = itemModel.getModel('itemStyle');\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        sector.useStyle(\n\t            zrUtil.defaults(\n\t                {\n\t                    lineJoin: 'bevel',\n\t                    fill: visualColor\n\t                },\n\t                itemStyleModel.getModel('normal').getItemStyle()\n\t            )\n\t        );\n\t        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\t\n\t        // Toggle selected\n\t        toggleItemSelected(\n\t            this,\n\t            data.getItemLayout(idx),\n\t            itemModel.get('selected'),\n\t            seriesModel.get('selectedOffset'),\n\t            seriesModel.get('animation')\n\t        );\n\t\n\t        function onEmphasis() {\n\t            // Sector may has animation of updating data. Force to move to the last frame\n\t            // Or it may stopped on the wrong shape\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r + 10\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        function onNormal() {\n\t            sector.stopAnimation(true);\n\t            sector.animateTo({\n\t                shape: {\n\t                    r: layout.r\n\t                }\n\t            }, 300, 'elasticOut');\n\t        }\n\t        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n\t        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n\t            sector\n\t                .on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t\n\t        this._updateLabel(data, idx);\n\t\n\t        graphic.setHoverStyle(this);\n\t    };\n\t\n\t    piePieceProto._updateLabel = function (data, idx) {\n\t\n\t        var labelLine = this.childAt(1);\n\t        var labelText = this.childAt(2);\n\t\n\t        var seriesModel = data.hostModel;\n\t        var itemModel = data.getItemModel(idx);\n\t        var layout = data.getItemLayout(idx);\n\t        var labelLayout = layout.label;\n\t        var visualColor = data.getItemVisual(idx, 'color');\n\t\n\t        graphic.updateProps(labelLine, {\n\t            shape: {\n\t                points: labelLayout.linePoints || [\n\t                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n\t                ]\n\t            }\n\t        }, seriesModel, idx);\n\t\n\t        graphic.updateProps(labelText, {\n\t            style: {\n\t                x: labelLayout.x,\n\t                y: labelLayout.y\n\t            }\n\t        }, seriesModel, idx);\n\t        labelText.attr({\n\t            style: {\n\t                textVerticalAlign: labelLayout.verticalAlign,\n\t                textAlign: labelLayout.textAlign,\n\t                textFont: labelLayout.font\n\t            },\n\t            rotation: labelLayout.rotation,\n\t            origin: [labelLayout.x, labelLayout.y],\n\t            z2: 10\n\t        });\n\t\n\t        var labelModel = itemModel.getModel('label.normal');\n\t        var labelHoverModel = itemModel.getModel('label.emphasis');\n\t        var labelLineModel = itemModel.getModel('labelLine.normal');\n\t        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n\t        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\t\n\t        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\t\n\t        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n\t        labelText.hoverIgnore = !labelHoverModel.get('show');\n\t\n\t        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n\t        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\t\n\t        // Default use item visual color\n\t        labelLine.setStyle({\n\t            stroke: visualColor,\n\t            opacity: data.getItemVisual(idx, 'opacity')\n\t        });\n\t        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\t\n\t        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n\t        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\t\n\t        var smooth = labelLineModel.get('smooth');\n\t        if (smooth && smooth === true) {\n\t            smooth = 0.4;\n\t        }\n\t        labelLine.setShape({\n\t            smooth: smooth\n\t        });\n\t    };\n\t\n\t    zrUtil.inherits(PiePiece, graphic.Group);\n\t\n\t\n\t    // Pie view\n\t    var Pie = __webpack_require__(163).extend({\n\t\n\t        type: 'pie',\n\t\n\t        init: function () {\n\t            var sectorGroup = new graphic.Group();\n\t            this._sectorGroup = sectorGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api, payload) {\n\t            if (payload && (payload.from === this.uid)) {\n\t                return;\n\t            }\n\t\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t            var group = this.group;\n\t\n\t            var hasAnimation = ecModel.get('animation');\n\t            var isFirstRender = !oldData;\n\t\n\t            var onSectorClick = zrUtil.curry(\n\t                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n\t            );\n\t\n\t            var selectedMode = seriesModel.get('selectedMode');\n\t\n\t            data.diff(oldData)\n\t                .add(function (idx) {\n\t                    var piePiece = new PiePiece(data, idx);\n\t                    if (isFirstRender) {\n\t                        piePiece.eachChild(function (child) {\n\t                            child.stopAnimation(true);\n\t                        });\n\t                    }\n\t\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t\n\t                    data.setItemGraphicEl(idx, piePiece);\n\t\n\t                    group.add(piePiece);\n\t                })\n\t                .update(function (newIdx, oldIdx) {\n\t                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\t\n\t                    piePiece.updateData(data, newIdx);\n\t\n\t                    piePiece.off('click');\n\t                    selectedMode && piePiece.on('click', onSectorClick);\n\t                    group.add(piePiece);\n\t                    data.setItemGraphicEl(newIdx, piePiece);\n\t                })\n\t                .remove(function (idx) {\n\t                    var piePiece = oldData.getItemGraphicEl(idx);\n\t                    group.remove(piePiece);\n\t                })\n\t                .execute();\n\t\n\t            if (hasAnimation && isFirstRender && data.count() > 0) {\n\t                var shape = data.getItemLayout(0);\n\t                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\t\n\t                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n\t                group.setClipPath(this._createClipPath(\n\t                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n\t                ));\n\t            }\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        _createClipPath: function (\n\t            cx, cy, r, startAngle, clockwise, cb, seriesModel\n\t        ) {\n\t            var clipPath = new graphic.Sector({\n\t                shape: {\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: 0,\n\t                    r: r,\n\t                    startAngle: startAngle,\n\t                    endAngle: startAngle,\n\t                    clockwise: clockwise\n\t                }\n\t            });\n\t\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n\t                }\n\t            }, seriesModel, cb);\n\t\n\t            return clipPath;\n\t        },\n\t\n\t        /**\n\t         * @implement\n\t         */\n\t        containPoint: function (point, seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var itemLayout = data.getItemLayout(0);\n\t            if (itemLayout) {\n\t                var dx = point[0] - itemLayout.cx;\n\t                var dy = point[1] - itemLayout.cy;\n\t                var radius = Math.sqrt(dx * dx + dy * dy);\n\t                return radius <= itemLayout.r && radius >= itemLayout.r0;\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    module.exports = Pie;\n\n\n/***/ },\n\n/***/ 518:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    var echarts = __webpack_require__(122);\n\t    var zrUtil = __webpack_require__(125);\n\t    module.exports = function (seriesType, actionInfos) {\n\t        zrUtil.each(actionInfos, function (actionInfo) {\n\t            actionInfo.update = 'updateView';\n\t            /**\n\t             * @payload\n\t             * @property {string} seriesName\n\t             * @property {string} name\n\t             */\n\t            echarts.registerAction(actionInfo, function (payload, ecModel) {\n\t                var selected = {};\n\t                ecModel.eachComponent(\n\t                    {mainType: 'series', subType: seriesType, query: payload},\n\t                    function (seriesModel) {\n\t                        if (seriesModel[actionInfo.method]) {\n\t                            seriesModel[actionInfo.method](payload.name);\n\t                        }\n\t                        var data = seriesModel.getData();\n\t                        // Create selected map\n\t                        data.each(function (idx) {\n\t                            var name = data.getName(idx);\n\t                            selected[name] = seriesModel.isSelected(name) || false;\n\t                        });\n\t                    }\n\t                );\n\t                return {\n\t                    name: payload.name,\n\t                    selected: selected\n\t                };\n\t            });\n\t        });\n\t    };\n\n\n/***/ },\n\n/***/ 519:\n/***/ function(module, exports) {\n\n\t// Pick color from palette for each data item\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        // Pie and funnel may use diferrent scope\n\t        var paletteScope = {};\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var dataAll = seriesModel.getRawData();\n\t            var idxMap = {};\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                var data = seriesModel.getData();\n\t                data.each(function (idx) {\n\t                    var rawIdx = data.getRawIndex(idx);\n\t                    idxMap[rawIdx] = idx;\n\t                });\n\t                dataAll.each(function (rawIdx) {\n\t                    // FIXME Performance\n\t                    var itemModel = dataAll.getItemModel(rawIdx);\n\t                    var filteredIdx = idxMap[rawIdx];\n\t\n\t                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n\t                    var singleDataColor = filteredIdx != null\n\t                        && data.getItemVisual(filteredIdx, 'color', true);\n\t\n\t                    if (!singleDataColor) {\n\t                        var color = itemModel.get('itemStyle.normal.color')\n\t                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n\t                        // Legend may use the visual info in data before processed\n\t                        dataAll.setItemVisual(rawIdx, 'color', color);\n\t\n\t                        // Data is not filtered\n\t                        if (filteredIdx != null) {\n\t                            data.setItemVisual(filteredIdx, 'color', color);\n\t                        }\n\t                    }\n\t                    else {\n\t                        // Set data all color for legend\n\t                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n\n/***/ 520:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// TODO minAngle\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(128);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var labelLayout = __webpack_require__(521);\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    var PI2 = Math.PI * 2;\n\t    var RADIAN = Math.PI / 180;\n\t\n\t    module.exports = function (seriesType, ecModel, api, payload) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var center = seriesModel.get('center');\n\t            var radius = seriesModel.get('radius');\n\t\n\t            if (!zrUtil.isArray(radius)) {\n\t                radius = [0, radius];\n\t            }\n\t            if (!zrUtil.isArray(center)) {\n\t                center = [center, center];\n\t            }\n\t\n\t            var width = api.getWidth();\n\t            var height = api.getHeight();\n\t            var size = Math.min(width, height);\n\t            var cx = parsePercent(center[0], width);\n\t            var cy = parsePercent(center[1], height);\n\t            var r0 = parsePercent(radius[0], size / 2);\n\t            var r = parsePercent(radius[1], size / 2);\n\t\n\t            var data = seriesModel.getData();\n\t\n\t            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\t\n\t            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\t\n\t            var sum = data.getSum('value');\n\t            // Sum may be 0\n\t            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\t\n\t            var clockwise = seriesModel.get('clockwise');\n\t\n\t            var roseType = seriesModel.get('roseType');\n\t\n\t            // [0...max]\n\t            var extent = data.getDataExtent('value');\n\t            extent[0] = 0;\n\t\n\t            // In the case some sector angle is smaller than minAngle\n\t            var restAngle = PI2;\n\t            var valueSumLargerThanMinAngle = 0;\n\t\n\t            var currentAngle = startAngle;\n\t\n\t            var dir = clockwise ? 1 : -1;\n\t            data.each('value', function (value, idx) {\n\t                var angle;\n\t                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n\t                if (roseType !== 'area') {\n\t                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n\t                }\n\t                else {\n\t                    angle = PI2 / (data.count() || 1);\n\t                }\n\t\n\t                if (angle < minAngle) {\n\t                    angle = minAngle;\n\t                    restAngle -= minAngle;\n\t                }\n\t                else {\n\t                    valueSumLargerThanMinAngle += value;\n\t                }\n\t\n\t                var endAngle = currentAngle + dir * angle;\n\t                data.setItemLayout(idx, {\n\t                    angle: angle,\n\t                    startAngle: currentAngle,\n\t                    endAngle: endAngle,\n\t                    clockwise: clockwise,\n\t                    cx: cx,\n\t                    cy: cy,\n\t                    r0: r0,\n\t                    r: roseType\n\t                        ? numberUtil.linearMap(value, extent, [r0, r])\n\t                        : r\n\t                });\n\t\n\t                currentAngle = endAngle;\n\t            }, true);\n\t\n\t            // Some sector is constrained by minAngle\n\t            // Rest sectors needs recalculate angle\n\t            if (restAngle < PI2) {\n\t                // Average the angle if rest angle is not enough after all angles is\n\t                // Constrained by minAngle\n\t                if (restAngle <= 1e-3) {\n\t                    var angle = PI2 / data.count();\n\t                    data.each(function (idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        layout.startAngle = startAngle + dir * idx * angle;\n\t                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n\t                    });\n\t                }\n\t                else {\n\t                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n\t                    currentAngle = startAngle;\n\t                    data.each('value', function (value, idx) {\n\t                        var layout = data.getItemLayout(idx);\n\t                        var angle = layout.angle === minAngle\n\t                            ? minAngle : value * unitRadian;\n\t                        layout.startAngle = currentAngle;\n\t                        layout.endAngle = currentAngle + dir * angle;\n\t                        currentAngle += angle;\n\t                    });\n\t                }\n\t            }\n\t\n\t            labelLayout(seriesModel, r, width, height);\n\t        });\n\t    };\n\n\n/***/ },\n\n/***/ 521:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME emphasis label position is not same with normal label position\n\t\n\t\n\t    var textContain = __webpack_require__(129);\n\t\n\t    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n\t        list.sort(function (a, b) {\n\t            return a.y - b.y;\n\t        });\n\t\n\t        // 压\n\t        function shiftDown(start, end, delta, dir) {\n\t            for (var j = start; j < end; j++) {\n\t                list[j].y += delta;\n\t                if (j > start\n\t                    && j + 1 < end\n\t                    && list[j + 1].y > list[j].y + list[j].height\n\t                ) {\n\t                    shiftUp(j, delta / 2);\n\t                    return;\n\t                }\n\t            }\n\t\n\t            shiftUp(end - 1, delta / 2);\n\t        }\n\t\n\t        // 弹\n\t        function shiftUp(end, delta) {\n\t            for (var j = end; j >= 0; j--) {\n\t                list[j].y -= delta;\n\t                if (j > 0\n\t                    && list[j].y > list[j - 1].y + list[j - 1].height\n\t                ) {\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t\n\t        function changeX(list, isDownList, cx, cy, r, dir) {\n\t            var lastDeltaX = dir > 0\n\t                ? isDownList                // 右侧\n\t                    ? Number.MAX_VALUE      // 下\n\t                    : 0                     // 上\n\t                : isDownList                // 左侧\n\t                    ? Number.MAX_VALUE      // 下\n\t                    : 0;                    // 上\n\t\n\t            for (var i = 0, l = list.length; i < l; i++) {\n\t                // Not change x for center label\n\t                if (list[i].position === 'center') {\n\t                    continue;\n\t                }\n\t                var deltaY = Math.abs(list[i].y - cy);\n\t                var length = list[i].len;\n\t                var length2 = list[i].len2;\n\t                var deltaX = (deltaY < r + length)\n\t                    ? Math.sqrt(\n\t                          (r + length + length2) * (r + length + length2)\n\t                          - deltaY * deltaY\n\t                      )\n\t                    : Math.abs(list[i].x - cx);\n\t                if (isDownList && deltaX >= lastDeltaX) {\n\t                    // 右下，左下\n\t                    deltaX = lastDeltaX - 10;\n\t                }\n\t                if (!isDownList && deltaX <= lastDeltaX) {\n\t                    // 右上，左上\n\t                    deltaX = lastDeltaX + 10;\n\t                }\n\t\n\t                list[i].x = cx + deltaX * dir;\n\t                lastDeltaX = deltaX;\n\t            }\n\t        }\n\t\n\t        var lastY = 0;\n\t        var delta;\n\t        var len = list.length;\n\t        var upList = [];\n\t        var downList = [];\n\t        for (var i = 0; i < len; i++) {\n\t            delta = list[i].y - lastY;\n\t            if (delta < 0) {\n\t                shiftDown(i, len, -delta, dir);\n\t            }\n\t            lastY = list[i].y + list[i].height;\n\t        }\n\t        if (viewHeight - lastY < 0) {\n\t            shiftUp(len - 1, lastY - viewHeight);\n\t        }\n\t        for (var i = 0; i < len; i++) {\n\t            if (list[i].y >= cy) {\n\t                downList.push(list[i]);\n\t            }\n\t            else {\n\t                upList.push(list[i]);\n\t            }\n\t        }\n\t        changeX(upList, false, cx, cy, r, dir);\n\t        changeX(downList, true, cx, cy, r, dir);\n\t    }\n\t\n\t    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n\t        var leftList = [];\n\t        var rightList = [];\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            if (labelLayoutList[i].x < cx) {\n\t                leftList.push(labelLayoutList[i]);\n\t            }\n\t            else {\n\t                rightList.push(labelLayoutList[i]);\n\t            }\n\t        }\n\t\n\t        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n\t        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\t\n\t        for (var i = 0; i < labelLayoutList.length; i++) {\n\t            var linePoints = labelLayoutList[i].linePoints;\n\t            if (linePoints) {\n\t                var dist = linePoints[1][0] - linePoints[2][0];\n\t                if (labelLayoutList[i].x < cx) {\n\t                    linePoints[2][0] = labelLayoutList[i].x + 3;\n\t                }\n\t                else {\n\t                    linePoints[2][0] = labelLayoutList[i].x - 3;\n\t                }\n\t                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n\t                linePoints[1][0] = linePoints[2][0] + dist;\n\t            }\n\t        }\n\t    }\n\t\n\t    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n\t        var data = seriesModel.getData();\n\t        var labelLayoutList = [];\n\t        var cx;\n\t        var cy;\n\t        var hasLabelRotate = false;\n\t\n\t        data.each(function (idx) {\n\t            var layout = data.getItemLayout(idx);\n\t\n\t            var itemModel = data.getItemModel(idx);\n\t            var labelModel = itemModel.getModel('label.normal');\n\t            // Use position in normal or emphasis\n\t            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\t\n\t            var labelLineModel = itemModel.getModel('labelLine.normal');\n\t            var labelLineLen = labelLineModel.get('length');\n\t            var labelLineLen2 = labelLineModel.get('length2');\n\t\n\t            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\t            var dx = Math.cos(midAngle);\n\t            var dy = Math.sin(midAngle);\n\t\n\t            var textX;\n\t            var textY;\n\t            var linePoints;\n\t            var textAlign;\n\t\n\t            cx = layout.cx;\n\t            cy = layout.cy;\n\t\n\t            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\t            if (labelPosition === 'center') {\n\t                textX = layout.cx;\n\t                textY = layout.cy;\n\t                textAlign = 'center';\n\t            }\n\t            else {\n\t                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n\t                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\t\n\t                textX = x1 + dx * 3;\n\t                textY = y1 + dy * 3;\n\t\n\t                if (!isLabelInside) {\n\t                    // For roseType\n\t                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n\t                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n\t                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n\t                    var y3 = y2;\n\t\n\t                    textX = x3 + (dx < 0 ? -5 : 5);\n\t                    textY = y3;\n\t                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n\t                }\n\t\n\t                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n\t            }\n\t            var font = labelModel.getModel('textStyle').getFont();\n\t\n\t            var labelRotate = labelModel.get('rotate')\n\t                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n\t            var text = seriesModel.getFormattedLabel(idx, 'normal')\n\t                        || data.getName(idx);\n\t            var textRect = textContain.getBoundingRect(\n\t                text, font, textAlign, 'top'\n\t            );\n\t            hasLabelRotate = !!labelRotate;\n\t            layout.label = {\n\t                x: textX,\n\t                y: textY,\n\t                position: labelPosition,\n\t                height: textRect.height,\n\t                len: labelLineLen,\n\t                len2: labelLineLen2,\n\t                linePoints: linePoints,\n\t                textAlign: textAlign,\n\t                verticalAlign: 'middle',\n\t                font: font,\n\t                rotation: labelRotate\n\t            };\n\t\n\t            // Not layout the inside label\n\t            if (!isLabelInside) {\n\t                labelLayoutList.push(layout.label);\n\t            }\n\t        });\n\t        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n\t            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n\t        }\n\t    };\n\n\n/***/ },\n\n/***/ 522:\n/***/ function(module, exports) {\n\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (!legendModels || !legendModels.length) {\n\t            return;\n\t        }\n\t        ecModel.eachSeriesByType(seriesType, function (series) {\n\t            var data = series.getData();\n\t            data.filterSelf(function (idx) {\n\t                var name = data.getName(idx);\n\t                // If in any legend component the status is not selected.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            }, this);\n\t        }, this);\n\t    };\n\n\n/***/ },\n\n/***/ 523:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    __webpack_require__(524);\n\t    __webpack_require__(525);\n\n\n/***/ },\n\n/***/ 524:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var List = __webpack_require__(218);\n\t    var SeriesModel = __webpack_require__(149);\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    var GaugeSeries = SeriesModel.extend({\n\t\n\t        type: 'series.gauge',\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            var list = new List(['value'], this);\n\t            var dataOpt = option.data || [];\n\t            if (!zrUtil.isArray(dataOpt)) {\n\t                dataOpt = [dataOpt];\n\t            }\n\t            // Only use the first data item\n\t            list.initData(dataOpt);\n\t            return list;\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t            z: 2,\n\t            // 默认全局居中\n\t            center: ['50%', '50%'],\n\t            legendHoverLink: true,\n\t            radius: '75%',\n\t            startAngle: 225,\n\t            endAngle: -45,\n\t            clockwise: true,\n\t            // 最小值\n\t            min: 0,\n\t            // 最大值\n\t            max: 100,\n\t            // 分割段数，默认为10\n\t            splitNumber: 10,\n\t            // 坐标轴线\n\t            axisLine: {\n\t                // 默认显示，属性show控制显示与否\n\t                show: true,\n\t                lineStyle: {       // 属性lineStyle控制线条样式\n\t                    color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],\n\t                    width: 30\n\t                }\n\t            },\n\t            // 分隔线\n\t            splitLine: {\n\t                // 默认显示，属性show控制显示与否\n\t                show: true,\n\t                // 属性length控制线长\n\t                length: 30,\n\t                // 属性lineStyle（详见lineStyle）控制线条样式\n\t                lineStyle: {\n\t                    color: '#eee',\n\t                    width: 2,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            // 坐标轴小标记\n\t            axisTick: {\n\t                // 属性show控制显示与否，默认不显示\n\t                show: true,\n\t                // 每份split细分多少段\n\t                splitNumber: 5,\n\t                // 属性length控制线长\n\t                length: 8,\n\t                // 属性lineStyle控制线条样式\n\t                lineStyle: {\n\t                    color: '#eee',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            axisLabel: {\n\t                show: true,\n\t                distance: 5,\n\t                // formatter: null,\n\t                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n\t                    color: 'auto'\n\t                }\n\t            },\n\t            pointer: {\n\t                show: true,\n\t                length: '80%',\n\t                width: 8\n\t            },\n\t            itemStyle: {\n\t                normal: {\n\t                    color: 'auto'\n\t                }\n\t            },\n\t            title: {\n\t                show: true,\n\t                // x, y，单位px\n\t                offsetCenter: [0, '-40%'],\n\t                // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n\t                textStyle: {\n\t                    color: '#333',\n\t                    fontSize: 15\n\t                }\n\t            },\n\t            detail: {\n\t                show: true,\n\t                backgroundColor: 'rgba(0,0,0,0)',\n\t                borderWidth: 0,\n\t                borderColor: '#ccc',\n\t                width: 100,\n\t                height: 40,\n\t                // x, y，单位px\n\t                offsetCenter: [0, '40%'],\n\t                // formatter: null,\n\t                // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n\t                textStyle: {\n\t                    color: 'auto',\n\t                    fontSize: 30\n\t                }\n\t            }\n\t        }\n\t    });\n\t\n\t    module.exports = GaugeSeries;\n\n\n/***/ },\n\n/***/ 525:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var PointerPath = __webpack_require__(526);\n\t\n\t    var graphic = __webpack_require__(164);\n\t    var numberUtil = __webpack_require__(128);\n\t    var parsePercent = numberUtil.parsePercent;\n\t\n\t    function parsePosition(seriesModel, api) {\n\t        var center = seriesModel.get('center');\n\t        var width = api.getWidth();\n\t        var height = api.getHeight();\n\t        var size = Math.min(width, height);\n\t        var cx = parsePercent(center[0], api.getWidth());\n\t        var cy = parsePercent(center[1], api.getHeight());\n\t        var r = parsePercent(seriesModel.get('radius'), size / 2);\n\t\n\t        return {\n\t            cx: cx,\n\t            cy: cy,\n\t            r: r\n\t        };\n\t    }\n\t\n\t    function formatLabel(label, labelFormatter) {\n\t        if (labelFormatter) {\n\t            if (typeof labelFormatter === 'string') {\n\t                label = labelFormatter.replace('{value}', label);\n\t            }\n\t            else if (typeof labelFormatter === 'function') {\n\t                label = labelFormatter(label);\n\t            }\n\t        }\n\t\n\t        return label;\n\t    }\n\t\n\t    var PI2 = Math.PI * 2;\n\t\n\t    var GaugeView = __webpack_require__(163).extend({\n\t\n\t        type: 'gauge',\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t\n\t            this.group.removeAll();\n\t\n\t            var colorList = seriesModel.get('axisLine.lineStyle.color');\n\t            var posInfo = parsePosition(seriesModel, api);\n\t\n\t            this._renderMain(\n\t                seriesModel, ecModel, api, colorList, posInfo\n\t            );\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n\t            var group = this.group;\n\t\n\t            var axisLineModel = seriesModel.getModel('axisLine');\n\t            var lineStyleModel = axisLineModel.getModel('lineStyle');\n\t\n\t            var clockwise = seriesModel.get('clockwise');\n\t            var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n\t            var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n\t\n\t            var angleRangeSpan = (endAngle - startAngle) % PI2;\n\t\n\t            var prevEndAngle = startAngle;\n\t            var axisLineWidth = lineStyleModel.get('width');\n\t\n\t            for (var i = 0; i < colorList.length; i++) {\n\t                // Clamp\n\t                var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n\t                var endAngle = startAngle + angleRangeSpan * percent;\n\t                var sector = new graphic.Sector({\n\t                    shape: {\n\t                        startAngle: prevEndAngle,\n\t                        endAngle: endAngle,\n\t                        cx: posInfo.cx,\n\t                        cy: posInfo.cy,\n\t                        clockwise: clockwise,\n\t                        r0: posInfo.r - axisLineWidth,\n\t                        r: posInfo.r\n\t                    },\n\t                    silent: true\n\t                });\n\t\n\t                sector.setStyle({\n\t                    fill: colorList[i][1]\n\t                });\n\t\n\t                sector.setStyle(lineStyleModel.getLineStyle(\n\t                    // Because we use sector to simulate arc\n\t                    // so the properties for stroking are useless\n\t                    ['color', 'borderWidth', 'borderColor']\n\t                ));\n\t\n\t                group.add(sector);\n\t\n\t                prevEndAngle = endAngle;\n\t            }\n\t\n\t            var getColor = function (percent) {\n\t                // Less than 0\n\t                if (percent <= 0) {\n\t                    return colorList[0][1];\n\t                }\n\t                for (var i = 0; i < colorList.length; i++) {\n\t                    if (colorList[i][0] >= percent\n\t                        && (i === 0 ? 0 : colorList[i - 1][0]) < percent\n\t                    ) {\n\t                        return colorList[i][1];\n\t                    }\n\t                }\n\t                // More than 1\n\t                return colorList[i - 1][1];\n\t            };\n\t\n\t            if (!clockwise) {\n\t                var tmp = startAngle;\n\t                startAngle = endAngle;\n\t                endAngle = tmp;\n\t            }\n\t\n\t            this._renderTicks(\n\t                seriesModel, ecModel, api, getColor, posInfo,\n\t                startAngle, endAngle, clockwise\n\t            );\n\t\n\t            this._renderPointer(\n\t                seriesModel, ecModel, api, getColor, posInfo,\n\t                startAngle, endAngle, clockwise\n\t            );\n\t\n\t            this._renderTitle(\n\t                seriesModel, ecModel, api, getColor, posInfo\n\t            );\n\t            this._renderDetail(\n\t                seriesModel, ecModel, api, getColor, posInfo\n\t            );\n\t        },\n\t\n\t        _renderTicks: function (\n\t            seriesModel, ecModel, api, getColor, posInfo,\n\t            startAngle, endAngle, clockwise\n\t        ) {\n\t            var group = this.group;\n\t            var cx = posInfo.cx;\n\t            var cy = posInfo.cy;\n\t            var r = posInfo.r;\n\t\n\t            var minVal = seriesModel.get('min');\n\t            var maxVal = seriesModel.get('max');\n\t\n\t            var splitLineModel = seriesModel.getModel('splitLine');\n\t            var tickModel = seriesModel.getModel('axisTick');\n\t            var labelModel = seriesModel.getModel('axisLabel');\n\t\n\t            var splitNumber = seriesModel.get('splitNumber');\n\t            var subSplitNumber = tickModel.get('splitNumber');\n\t\n\t            var splitLineLen = parsePercent(\n\t                splitLineModel.get('length'), r\n\t            );\n\t            var tickLen = parsePercent(\n\t                tickModel.get('length'), r\n\t            );\n\t\n\t            var angle = startAngle;\n\t            var step = (endAngle - startAngle) / splitNumber;\n\t            var subStep = step / subSplitNumber;\n\t\n\t            var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n\t            var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n\t            var textStyleModel = labelModel.getModel('textStyle');\n\t\n\t            for (var i = 0; i <= splitNumber; i++) {\n\t                var unitX = Math.cos(angle);\n\t                var unitY = Math.sin(angle);\n\t                // Split line\n\t                if (splitLineModel.get('show')) {\n\t                    var splitLine = new graphic.Line({\n\t                        shape: {\n\t                            x1: unitX * r + cx,\n\t                            y1: unitY * r + cy,\n\t                            x2: unitX * (r - splitLineLen) + cx,\n\t                            y2: unitY * (r - splitLineLen) + cy\n\t                        },\n\t                        style: splitLineStyle,\n\t                        silent: true\n\t                    });\n\t                    if (splitLineStyle.stroke === 'auto') {\n\t                        splitLine.setStyle({\n\t                            stroke: getColor(i / splitNumber)\n\t                        });\n\t                    }\n\t\n\t                    group.add(splitLine);\n\t                }\n\t\n\t                // Label\n\t                if (labelModel.get('show')) {\n\t                    var label = formatLabel(\n\t                        numberUtil.round(i / splitNumber * (maxVal - minVal) + minVal),\n\t                        labelModel.get('formatter')\n\t                    );\n\t                    var distance = labelModel.get('distance');\n\t\n\t                    var text = new graphic.Text({\n\t                        style: {\n\t                            text: label,\n\t                            x: unitX * (r - splitLineLen - distance) + cx,\n\t                            y: unitY * (r - splitLineLen - distance) + cy,\n\t                            fill: textStyleModel.getTextColor(),\n\t                            textFont: textStyleModel.getFont(),\n\t                            textVerticalAlign: unitY < -0.4 ? 'top' : (unitY > 0.4 ? 'bottom' : 'middle'),\n\t                            textAlign: unitX < -0.4 ? 'left' : (unitX > 0.4 ? 'right' : 'center')\n\t                        },\n\t                        silent: true\n\t                    });\n\t                    if (text.style.fill === 'auto') {\n\t                        text.setStyle({\n\t                            fill: getColor(i / splitNumber)\n\t                        });\n\t                    }\n\t\n\t                    group.add(text);\n\t                }\n\t\n\t                // Axis tick\n\t                if (tickModel.get('show') && i !== splitNumber) {\n\t                    for (var j = 0; j <= subSplitNumber; j++) {\n\t                        var unitX = Math.cos(angle);\n\t                        var unitY = Math.sin(angle);\n\t                        var tickLine = new graphic.Line({\n\t                            shape: {\n\t                                x1: unitX * r + cx,\n\t                                y1: unitY * r + cy,\n\t                                x2: unitX * (r - tickLen) + cx,\n\t                                y2: unitY * (r - tickLen) + cy\n\t                            },\n\t                            silent: true,\n\t                            style: tickLineStyle\n\t                        });\n\t\n\t                        if (tickLineStyle.stroke === 'auto') {\n\t                            tickLine.setStyle({\n\t                                stroke: getColor((i + j / subSplitNumber) / splitNumber)\n\t                            });\n\t                        }\n\t\n\t                        group.add(tickLine);\n\t                        angle += subStep;\n\t                    }\n\t                    angle -= subStep;\n\t                }\n\t                else {\n\t                    angle += step;\n\t                }\n\t            }\n\t        },\n\t\n\t        _renderPointer: function (\n\t            seriesModel, ecModel, api, getColor, posInfo,\n\t            startAngle, endAngle, clockwise\n\t        ) {\n\t            var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n\t            var angleExtent = [startAngle, endAngle];\n\t\n\t            var data = seriesModel.getData();\n\t            var oldData = this._data;\n\t\n\t            var group = this.group;\n\t\n\t            data.diff(oldData)\n\t                .add(function (idx) {\n\t                    var pointer = new PointerPath({\n\t                        shape: {\n\t                            angle: startAngle\n\t                        }\n\t                    });\n\t\n\t                    graphic.updateProps(pointer, {\n\t                        shape: {\n\t                            angle: numberUtil.linearMap(data.get('value', idx), valueExtent, angleExtent, true)\n\t                        }\n\t                    }, seriesModel);\n\t\n\t                    group.add(pointer);\n\t                    data.setItemGraphicEl(idx, pointer);\n\t                })\n\t                .update(function (newIdx, oldIdx) {\n\t                    var pointer = oldData.getItemGraphicEl(oldIdx);\n\t\n\t                    graphic.updateProps(pointer, {\n\t                        shape: {\n\t                            angle: numberUtil.linearMap(data.get('value', newIdx), valueExtent, angleExtent, true)\n\t                        }\n\t                    }, seriesModel);\n\t\n\t                    group.add(pointer);\n\t                    data.setItemGraphicEl(newIdx, pointer);\n\t                })\n\t                .remove(function (idx) {\n\t                    var pointer = oldData.getItemGraphicEl(idx);\n\t                    group.remove(pointer);\n\t                })\n\t                .execute();\n\t\n\t            data.eachItemGraphicEl(function (pointer, idx) {\n\t                var itemModel = data.getItemModel(idx);\n\t                var pointerModel = itemModel.getModel('pointer');\n\t\n\t                pointer.setShape({\n\t                    x: posInfo.cx,\n\t                    y: posInfo.cy,\n\t                    width: parsePercent(\n\t                        pointerModel.get('width'), posInfo.r\n\t                    ),\n\t                    r: parsePercent(pointerModel.get('length'), posInfo.r)\n\t                });\n\t\n\t                pointer.useStyle(itemModel.getModel('itemStyle.normal').getItemStyle());\n\t\n\t                if (pointer.style.fill === 'auto') {\n\t                    pointer.setStyle('fill', getColor(\n\t                        (data.get('value', idx) - valueExtent[0]) / (valueExtent[1] - valueExtent[0])\n\t                    ));\n\t                }\n\t\n\t                graphic.setHoverStyle(\n\t                    pointer, itemModel.getModel('itemStyle.emphasis').getItemStyle()\n\t                );\n\t            });\n\t\n\t            this._data = data;\n\t        },\n\t\n\t        _renderTitle: function (\n\t            seriesModel, ecModel, api, getColor, posInfo\n\t        ) {\n\t            var titleModel = seriesModel.getModel('title');\n\t            if (titleModel.get('show')) {\n\t                var textStyleModel = titleModel.getModel('textStyle');\n\t                var offsetCenter = titleModel.get('offsetCenter');\n\t                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n\t                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n\t                var text = new graphic.Text({\n\t                    style: {\n\t                        x: x,\n\t                        y: y,\n\t                        // FIXME First data name ?\n\t                        text: seriesModel.getData().getName(0),\n\t                        fill: textStyleModel.getTextColor(),\n\t                        textFont: textStyleModel.getFont(),\n\t                        textAlign: 'center',\n\t                        textVerticalAlign: 'middle'\n\t                    }\n\t                });\n\t                this.group.add(text);\n\t            }\n\t        },\n\t\n\t        _renderDetail: function (\n\t            seriesModel, ecModel, api, getColor, posInfo\n\t        ) {\n\t            var detailModel = seriesModel.getModel('detail');\n\t            var minVal = seriesModel.get('min');\n\t            var maxVal = seriesModel.get('max');\n\t            if (detailModel.get('show')) {\n\t                var textStyleModel = detailModel.getModel('textStyle');\n\t                var offsetCenter = detailModel.get('offsetCenter');\n\t                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n\t                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n\t                var width = parsePercent(detailModel.get('width'), posInfo.r);\n\t                var height = parsePercent(detailModel.get('height'), posInfo.r);\n\t                var value = seriesModel.getData().get('value', 0);\n\t                var rect = new graphic.Rect({\n\t                    shape: {\n\t                        x: x - width / 2,\n\t                        y: y - height / 2,\n\t                        width: width,\n\t                        height: height\n\t                    },\n\t                    style: {\n\t                        text: formatLabel(\n\t                            // FIXME First data name ?\n\t                            value, detailModel.get('formatter')\n\t                        ),\n\t                        fill: detailModel.get('backgroundColor'),\n\t                        textFill: textStyleModel.getTextColor(),\n\t                        textFont: textStyleModel.getFont()\n\t                    }\n\t                });\n\t                if (rect.style.textFill === 'auto') {\n\t                    rect.setStyle('textFill', getColor(\n\t                        numberUtil.linearMap(value, [minVal, maxVal], [0, 1], true)\n\t                    ));\n\t                }\n\t                rect.setStyle(detailModel.getItemStyle(['color']));\n\t                this.group.add(rect);\n\t            }\n\t        }\n\t    });\n\t\n\t    module.exports = GaugeView;\n\n\n/***/ },\n\n/***/ 526:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    module.exports = __webpack_require__(166).extend({\n\t\n\t        type: 'echartsGaugePointer',\n\t\n\t        shape: {\n\t            angle: 0,\n\t\n\t            width: 10,\n\t\n\t            r: 10,\n\t\n\t            x: 0,\n\t\n\t            y: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var mathCos = Math.cos;\n\t            var mathSin = Math.sin;\n\t\n\t            var r = shape.r;\n\t            var width = shape.width;\n\t            var angle = shape.angle;\n\t            var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);\n\t            var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);\n\t\n\t            angle = shape.angle - Math.PI / 2;\n\t            ctx.moveTo(x, y);\n\t            ctx.lineTo(\n\t                shape.x + mathCos(angle) * width,\n\t                shape.y + mathSin(angle) * width\n\t            );\n\t            ctx.lineTo(\n\t                shape.x + mathCos(shape.angle) * r,\n\t                shape.y + mathSin(shape.angle) * r\n\t            );\n\t            ctx.lineTo(\n\t                shape.x - mathCos(angle) * width,\n\t                shape.y - mathSin(angle) * width\n\t            );\n\t            ctx.lineTo(x, y);\n\t            return;\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 527:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var echarts = __webpack_require__(122);\n\t    var PRIORITY = echarts.PRIORITY;\n\t\n\t    __webpack_require__(528);\n\t    __webpack_require__(530);\n\t\n\t    echarts.registerVisual(zrUtil.curry(\n\t        __webpack_require__(536), 'line', 'circle', 'line'\n\t    ));\n\t    echarts.registerLayout(zrUtil.curry(\n\t        __webpack_require__(537), 'line'\n\t    ));\n\t\n\t    // Down sample after filter\n\t    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n\t        __webpack_require__(538), 'line'\n\t    ));\n\t\n\t    // In case developer forget to include grid component\n\t    __webpack_require__(539);\n\n\n/***/ },\n\n/***/ 528:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var createListFromArray = __webpack_require__(529);\n\t    var SeriesModel = __webpack_require__(149);\n\t\n\t    module.exports = SeriesModel.extend({\n\t\n\t        type: 'series.line',\n\t\n\t        dependencies: ['grid', 'polar'],\n\t\n\t        getInitialData: function (option, ecModel) {\n\t            if (__DEV__) {\n\t                var coordSys = option.coordinateSystem;\n\t                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n\t                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n\t                }\n\t            }\n\t            return createListFromArray(option.data, this, ecModel);\n\t        },\n\t\n\t        defaultOption: {\n\t            zlevel: 0,                  // 一级层叠\n\t            z: 2,                       // 二级层叠\n\t            coordinateSystem: 'cartesian2d',\n\t            legendHoverLink: true,\n\t\n\t            hoverAnimation: true,\n\t            // stack: null\n\t            // xAxisIndex: 0,\n\t            // yAxisIndex: 0,\n\t\n\t            // polarIndex: 0,\n\t\n\t            // If clip the overflow value\n\t            clipOverflow: true,\n\t\n\t            label: {\n\t                normal: {\n\t                    position: 'top'\n\t                }\n\t            },\n\t            // itemStyle: {\n\t            //     normal: {},\n\t            //     emphasis: {}\n\t            // },\n\t            lineStyle: {\n\t                normal: {\n\t                    width: 2,\n\t                    type: 'solid'\n\t                }\n\t            },\n\t            // areaStyle: {},\n\t            // false, 'start', 'end', 'middle'\n\t            step: false,\n\t\n\t            // Disabled if step is true\n\t            smooth: false,\n\t            smoothMonotone: null,\n\t            // 拐点图形类型\n\t            symbol: 'emptyCircle',\n\t            // 拐点图形大小\n\t            symbolSize: 4,\n\t            // 拐点图形旋转控制\n\t            symbolRotate: null,\n\t\n\t            // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n\t            showSymbol: true,\n\t            // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n\t            showAllSymbol: false,\n\t\n\t            // 是否连接断点\n\t            connectNulls: false,\n\t\n\t            // 数据过滤，'average', 'max', 'min', 'sum'\n\t            sampling: 'none',\n\t\n\t            animationEasing: 'linear',\n\t\n\t            // Disable progressive\n\t            progressive: 0,\n\t            hoverLayerThreshold: Infinity\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 529:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var List = __webpack_require__(218);\n\t    var completeDimensions = __webpack_require__(515);\n\t    var zrUtil = __webpack_require__(125);\n\t    var modelUtil = __webpack_require__(126);\n\t    var CoordinateSystem = __webpack_require__(147);\n\t    var getDataItemValue = modelUtil.getDataItemValue;\n\t    var converDataValue = modelUtil.converDataValue;\n\t\n\t    function firstDataNotNull(data) {\n\t        var i = 0;\n\t        while (i < data.length && data[i] == null) {\n\t            i++;\n\t        }\n\t        return data[i];\n\t    }\n\t    function ifNeedCompleteOrdinalData(data) {\n\t        var sampleItem = firstDataNotNull(data);\n\t        return sampleItem != null\n\t            && !zrUtil.isArray(getDataItemValue(sampleItem));\n\t    }\n\t\n\t    /**\n\t     * Helper function to create a list from option data\n\t     */\n\t    function createListFromArray(data, seriesModel, ecModel) {\n\t        // If data is undefined\n\t        data = data || [];\n\t\n\t        if (__DEV__) {\n\t            if (!zrUtil.isArray(data)) {\n\t                throw new Error('Invalid data.');\n\t            }\n\t        }\n\t\n\t        var coordSysName = seriesModel.get('coordinateSystem');\n\t        var creator = creators[coordSysName];\n\t        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n\t        // FIXME\n\t        var axesInfo = creator && creator(data, seriesModel, ecModel);\n\t        var dimensions = axesInfo && axesInfo.dimensions;\n\t        if (!dimensions) {\n\t            // Get dimensions from registered coordinate system\n\t            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n\t            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n\t        }\n\t        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\t\n\t        var list = new List(dimensions, seriesModel);\n\t\n\t        var nameList = createNameList(axesInfo, data);\n\t\n\t        var categories = {};\n\t        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n\t            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                // Use dataIndex as ordinal value in categoryAxis\n\t                return dimIndex === categoryIndex\n\t                    ? dataIndex\n\t                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n\t            }\n\t            : function (itemOpt, dimName, dataIndex, dimIndex) {\n\t                var value = getDataItemValue(itemOpt);\n\t                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n\t                // If any dataItem is like { value: 10 }\n\t                if (modelUtil.isDataItemOption(itemOpt)) {\n\t                    list.hasItemOption = true;\n\t                }\n\t\n\t                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n\t                if (categoryAxesModels && categoryAxesModels[dimName]) {\n\t                    // If given value is a category string\n\t                    if (typeof val === 'string') {\n\t                        // Lazy get categories\n\t                        categories[dimName] = categories[dimName]\n\t                            || categoryAxesModels[dimName].getCategories();\n\t                        val = zrUtil.indexOf(categories[dimName], val);\n\t                        if (val < 0 && !isNaN(val)) {\n\t                            // In case some one write '1', '2' istead of 1, 2\n\t                            val = +val;\n\t                        }\n\t                    }\n\t                }\n\t                return val;\n\t            };\n\t\n\t        list.hasItemOption = false;\n\t        list.initData(data, nameList, dimValueGetter);\n\t\n\t        return list;\n\t    }\n\t\n\t    function isStackable(axisType) {\n\t        return axisType !== 'category' && axisType !== 'time';\n\t    }\n\t\n\t    function getDimTypeByAxis(axisType) {\n\t        return axisType === 'category'\n\t            ? 'ordinal'\n\t            : axisType === 'time'\n\t            ? 'time'\n\t            : 'float';\n\t    }\n\t\n\t    /**\n\t     * Creaters for each coord system.\n\t     */\n\t    var creators = {\n\t\n\t        cartesian2d: function (data, seriesModel, ecModel) {\n\t\n\t            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n\t                return ecModel.queryComponents({\n\t                    mainType: name,\n\t                    index: seriesModel.get(name + 'Index'),\n\t                    id: seriesModel.get(name + 'Id')\n\t                })[0];\n\t            });\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            if (__DEV__) {\n\t                if (!xAxisModel) {\n\t                    throw new Error('xAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('xAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t                if (!yAxisModel) {\n\t                    throw new Error('yAxis \"' + zrUtil.retrieve(\n\t                        seriesModel.get('xAxisIndex'),\n\t                        seriesModel.get('yAxisId'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t\n\t            var xAxisType = xAxisModel.get('type');\n\t            var yAxisType = yAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'x',\n\t                    type: getDimTypeByAxis(xAxisType),\n\t                    stackable: isStackable(xAxisType)\n\t                },\n\t                {\n\t                    name: 'y',\n\t                    // If two category axes\n\t                    type: getDimTypeByAxis(yAxisType),\n\t                    stackable: isStackable(yAxisType)\n\t                }\n\t            ];\n\t\n\t            var isXAxisCateogry = xAxisType === 'category';\n\t            var isYAxisCategory = yAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isXAxisCateogry) {\n\t                categoryAxesModels.x = xAxisModel;\n\t            }\n\t            if (isYAxisCategory) {\n\t                categoryAxesModels.y = yAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        polar: function (data, seriesModel, ecModel) {\n\t            var polarModel = ecModel.queryComponents({\n\t                mainType: 'polar',\n\t                index: seriesModel.get('polarIndex'),\n\t                id: seriesModel.get('polarId')\n\t            })[0];\n\t\n\t            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n\t            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\t\n\t            if (__DEV__) {\n\t                if (!angleAxisModel) {\n\t                    throw new Error('angleAxis option not found');\n\t                }\n\t                if (!radiusAxisModel) {\n\t                    throw new Error('radiusAxis option not found');\n\t                }\n\t            }\n\t\n\t            var radiusAxisType = radiusAxisModel.get('type');\n\t            var angleAxisType = angleAxisModel.get('type');\n\t\n\t            var dimensions = [\n\t                {\n\t                    name: 'radius',\n\t                    type: getDimTypeByAxis(radiusAxisType),\n\t                    stackable: isStackable(radiusAxisType)\n\t                },\n\t                {\n\t                    name: 'angle',\n\t                    type: getDimTypeByAxis(angleAxisType),\n\t                    stackable: isStackable(angleAxisType)\n\t                }\n\t            ];\n\t            var isAngleAxisCateogry = angleAxisType === 'category';\n\t            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\t\n\t            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\t\n\t            var categoryAxesModels = {};\n\t            if (isRadiusAxisCateogry) {\n\t                categoryAxesModels.radius = radiusAxisModel;\n\t            }\n\t            if (isAngleAxisCateogry) {\n\t                categoryAxesModels.angle = angleAxisModel;\n\t            }\n\t            return {\n\t                dimensions: dimensions,\n\t                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n\t                categoryAxesModels: categoryAxesModels\n\t            };\n\t        },\n\t\n\t        geo: function (data, seriesModel, ecModel) {\n\t            // TODO Region\n\t            // 多个散点图系列在同一个地区的时候\n\t            return {\n\t                dimensions: completeDimensions([\n\t                    {name: 'lng'},\n\t                    {name: 'lat'}\n\t                ], data, ['lng', 'lat', 'value'])\n\t            };\n\t        }\n\t    };\n\t\n\t    function createNameList(result, data) {\n\t        var nameList = [];\n\t\n\t        var categoryDim = result && result.dimensions[result.categoryIndex];\n\t        var categoryAxisModel;\n\t        if (categoryDim) {\n\t            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n\t        }\n\t\n\t        if (categoryAxisModel) {\n\t            // FIXME Two category axis\n\t            var categories = categoryAxisModel.getCategories();\n\t            if (categories) {\n\t                var dataLen = data.length;\n\t                // Ordered data is given explicitly like\n\t                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n\t                // or given scatter data,\n\t                // pick the category\n\t                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n\t                    nameList = [];\n\t                    for (var i = 0; i < dataLen; i++) {\n\t                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n\t                    }\n\t                }\n\t                else {\n\t                    nameList = categories.slice(0);\n\t                }\n\t            }\n\t        }\n\t\n\t        return nameList;\n\t    }\n\t\n\t    module.exports = createListFromArray;\n\t\n\n\n/***/ },\n\n/***/ 530:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// FIXME step not support polar\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var SymbolDraw = __webpack_require__(531);\n\t    var Symbol = __webpack_require__(532);\n\t    var lineAnimationDiff = __webpack_require__(534);\n\t    var graphic = __webpack_require__(164);\n\t    var modelUtil = __webpack_require__(126);\n\t\n\t    var polyHelper = __webpack_require__(535);\n\t\n\t    var ChartView = __webpack_require__(163);\n\t\n\t    function isPointsSame(points1, points2) {\n\t        if (points1.length !== points2.length) {\n\t            return;\n\t        }\n\t        for (var i = 0; i < points1.length; i++) {\n\t            var p1 = points1[i];\n\t            var p2 = points2[i];\n\t            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n\t                return;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t\n\t    function getSmooth(smooth) {\n\t        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n\t    }\n\t\n\t    function getAxisExtentWithGap(axis) {\n\t        var extent = axis.getGlobalExtent();\n\t        if (axis.onBand) {\n\t            // Remove extra 1px to avoid line miter in clipped edge\n\t            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n\t            var dir = extent[1] > extent[0] ? 1 : -1;\n\t            extent[0] += dir * halfBandWidth;\n\t            extent[1] -= dir * halfBandWidth;\n\t        }\n\t        return extent;\n\t    }\n\t\n\t    function sign(val) {\n\t        return val >= 0 ? 1 : -1;\n\t    }\n\t    /**\n\t     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Array.<Array.<number>>} points\n\t     * @private\n\t     */\n\t    function getStackedOnPoints(coordSys, data) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t        var valueStart = baseAxis.onZero\n\t            ? 0 : valueAxis.scale.getExtent()[0];\n\t\n\t        var valueDim = valueAxis.dim;\n\t\n\t        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\t\n\t        return data.mapArray([valueDim], function (val, idx) {\n\t            var stackedOnSameSign;\n\t            var stackedOn = data.stackedOn;\n\t            // Find first stacked value with same sign\n\t            while (stackedOn &&\n\t                sign(stackedOn.get(valueDim, idx)) === sign(val)\n\t            ) {\n\t                stackedOnSameSign = stackedOn;\n\t                break;\n\t            }\n\t            var stackedData = [];\n\t            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n\t            stackedData[1 - baseDataOffset] = stackedOnSameSign\n\t                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\t\n\t            return coordSys.dataToPoint(stackedData);\n\t        }, true);\n\t    }\n\t\n\t    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n\t        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n\t        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n\t        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\t\n\t        var x = Math.min(xExtent[0], xExtent[1]);\n\t        var y = Math.min(yExtent[0], yExtent[1]);\n\t        var width = Math.max(xExtent[0], xExtent[1]) - x;\n\t        var height = Math.max(yExtent[0], yExtent[1]) - y;\n\t        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n\t        // Expand clip shape to avoid clipping when line value exceeds axis\n\t        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n\t        if (isHorizontal) {\n\t            y -= expandSize;\n\t            height += expandSize * 2;\n\t        }\n\t        else {\n\t            x -= expandSize;\n\t            width += expandSize * 2;\n\t        }\n\t\n\t        var clipPath = new graphic.Rect({\n\t            shape: {\n\t                x: x,\n\t                y: y,\n\t                width: width,\n\t                height: height\n\t            }\n\t        });\n\t\n\t        if (hasAnimation) {\n\t            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    width: width,\n\t                    height: height\n\t                }\n\t            }, seriesModel);\n\t        }\n\t\n\t        return clipPath;\n\t    }\n\t\n\t    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n\t        var angleAxis = polar.getAngleAxis();\n\t        var radiusAxis = polar.getRadiusAxis();\n\t\n\t        var radiusExtent = radiusAxis.getExtent();\n\t        var angleExtent = angleAxis.getExtent();\n\t\n\t        var RADIAN = Math.PI / 180;\n\t\n\t        var clipPath = new graphic.Sector({\n\t            shape: {\n\t                cx: polar.cx,\n\t                cy: polar.cy,\n\t                r0: radiusExtent[0],\n\t                r: radiusExtent[1],\n\t                startAngle: -angleExtent[0] * RADIAN,\n\t                endAngle: -angleExtent[1] * RADIAN,\n\t                clockwise: angleAxis.inverse\n\t            }\n\t        });\n\t\n\t        if (hasAnimation) {\n\t            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n\t            graphic.initProps(clipPath, {\n\t                shape: {\n\t                    endAngle: -angleExtent[1] * RADIAN\n\t                }\n\t            }, seriesModel);\n\t        }\n\t\n\t        return clipPath;\n\t    }\n\t\n\t    function createClipShape(coordSys, hasAnimation, seriesModel) {\n\t        return coordSys.type === 'polar'\n\t            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n\t            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n\t    }\n\t\n\t    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\t\n\t        var stepPoints = [];\n\t        for (var i = 0; i < points.length - 1; i++) {\n\t            var nextPt = points[i + 1];\n\t            var pt = points[i];\n\t            stepPoints.push(pt);\n\t\n\t            var stepPt = [];\n\t            switch (stepTurnAt) {\n\t                case 'end':\n\t                    stepPt[baseIndex] = nextPt[baseIndex];\n\t                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n\t                    // default is start\n\t                    stepPoints.push(stepPt);\n\t                    break;\n\t                case 'middle':\n\t                    // default is start\n\t                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n\t                    var stepPt2 = [];\n\t                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n\t                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n\t                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n\t                    stepPoints.push(stepPt);\n\t                    stepPoints.push(stepPt2);\n\t                    break;\n\t                default:\n\t                    stepPt[baseIndex] = pt[baseIndex];\n\t                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n\t                    // default is start\n\t                    stepPoints.push(stepPt);\n\t            }\n\t        }\n\t        // Last points\n\t        points[i] && stepPoints.push(points[i]);\n\t        return stepPoints;\n\t    }\n\t\n\t    function clamp(number, extent) {\n\t        return Math.max(Math.min(number, extent[1]), extent[0]);\n\t    }\n\t\n\t    function getVisualGradient(data, coordSys) {\n\t        var visualMetaList = data.getVisual('visualMeta');\n\t        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n\t            // When data.count() is 0, gradient range can not be calculated.\n\t            return;\n\t        }\n\t\n\t        var visualMeta;\n\t        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n\t            // Can only be x or y\n\t            if (visualMetaList[i].dimension < 2) {\n\t                visualMeta = visualMetaList[i];\n\t                break;\n\t            }\n\t        }\n\t        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n\t            if (__DEV__) {\n\t                console.warn('Visual map on line style only support x or y dimension.');\n\t            }\n\t            return;\n\t        }\n\t\n\t        var dimension = visualMeta.dimension;\n\t        var dimName = data.dimensions[dimension];\n\t        var dataExtent = data.getDataExtent(dimName);\n\t\n\t        var stops = visualMeta.stops;\n\t\n\t        var colorStops = [];\n\t        if (stops[0].interval) {\n\t            stops.sort(function (a, b) {\n\t                return a.interval[0] - b.interval[0];\n\t            });\n\t        }\n\t\n\t        var firstStop = stops[0];\n\t        var lastStop = stops[stops.length - 1];\n\t        // Interval can be infinity in piecewise case\n\t        var min = firstStop.interval ? clamp(firstStop.interval[0], dataExtent) : firstStop.value;\n\t        var max = lastStop.interval ? clamp(lastStop.interval[1], dataExtent) : lastStop.value;\n\t        var stopsSpan = max - min;\n\t\n\t        // In the piecewise case data out of visual range\n\t        // ----dataMin----dataMax-----visualMin----visualMax\n\t        if (stopsSpan === 0) {\n\t            return data.getItemVisual(0, 'color');\n\t        }\n\t        for (var i = 0; i < stops.length; i++) {\n\t            // Piecewise\n\t            if (stops[i].interval) {\n\t                if (stops[i].interval[1] === stops[i].interval[0]) {\n\t                    continue;\n\t                }\n\t                colorStops.push({\n\t                    // Make sure offset is between 0 and 1\n\t                    offset: (clamp(stops[i].interval[0], dataExtent) - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                }, {\n\t                    offset: (clamp(stops[i].interval[1], dataExtent) - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                });\n\t            }\n\t            // Continous\n\t            else {\n\t                // if (i > 0 && stops[i].value === stops[i - 1].value) {\n\t                //     continue;\n\t                // }\n\t                colorStops.push({\n\t                    offset: (stops[i].value - min) / stopsSpan,\n\t                    color: stops[i].color\n\t                });\n\t            }\n\t        }\n\t\n\t        var gradient = new graphic.LinearGradient(\n\t            0, 0, 0, 0, colorStops, true\n\t        );\n\t        var axis = coordSys.getAxis(dimName);\n\t\n\t        var start = axis.toGlobalCoord(axis.dataToCoord(min));\n\t        var end = axis.toGlobalCoord(axis.dataToCoord(max));\n\t        // zrUtil.each(colorStops, function (colorStop) {\n\t        //     // Make sure each offset has rounded px to avoid not sharp edge\n\t        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n\t        // });\n\t\n\t        gradient[dimName] = start;\n\t        gradient[dimName + '2'] = end;\n\t\n\t        return gradient;\n\t    }\n\t\n\t    module.exports = ChartView.extend({\n\t\n\t        type: 'line',\n\t\n\t        init: function () {\n\t            var lineGroup = new graphic.Group();\n\t\n\t            var symbolDraw = new SymbolDraw();\n\t            this.group.add(symbolDraw.group);\n\t\n\t            this._symbolDraw = symbolDraw;\n\t            this._lineGroup = lineGroup;\n\t        },\n\t\n\t        render: function (seriesModel, ecModel, api) {\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            var group = this.group;\n\t            var data = seriesModel.getData();\n\t            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n\t            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\t\n\t            var points = data.mapArray(data.getItemLayout, true);\n\t\n\t            var isCoordSysPolar = coordSys.type === 'polar';\n\t            var prevCoordSys = this._coordSys;\n\t\n\t            var symbolDraw = this._symbolDraw;\n\t            var polyline = this._polyline;\n\t            var polygon = this._polygon;\n\t\n\t            var lineGroup = this._lineGroup;\n\t\n\t            var hasAnimation = seriesModel.get('animation');\n\t\n\t            var isAreaChart = !areaStyleModel.isEmpty();\n\t            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\t\n\t            var showSymbol = seriesModel.get('showSymbol');\n\t\n\t            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n\t                && this._getSymbolIgnoreFunc(data, coordSys);\n\t\n\t            // Remove temporary symbols\n\t            var oldData = this._data;\n\t            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n\t                if (el.__temp) {\n\t                    group.remove(el);\n\t                    oldData.setItemGraphicEl(idx, null);\n\t                }\n\t            });\n\t\n\t            // Remove previous created symbols if showSymbol changed to false\n\t            if (!showSymbol) {\n\t                symbolDraw.remove();\n\t            }\n\t\n\t            group.add(lineGroup);\n\t\n\t            // FIXME step not support polar\n\t            var step = !isCoordSysPolar && seriesModel.get('step');\n\t            // Initialization animation or coordinate system changed\n\t            if (\n\t                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n\t            ) {\n\t                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\t\n\t                if (step) {\n\t                    // TODO If stacked series is not step\n\t                    points = turnPointsIntoStep(points, coordSys, step);\n\t                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n\t                }\n\t\n\t                polyline = this._newPolyline(points, coordSys, hasAnimation);\n\t                if (isAreaChart) {\n\t                    polygon = this._newPolygon(\n\t                        points, stackedOnPoints,\n\t                        coordSys, hasAnimation\n\t                    );\n\t                }\n\t                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n\t            }\n\t            else {\n\t                if (isAreaChart && !polygon) {\n\t                    // If areaStyle is added\n\t                    polygon = this._newPolygon(\n\t                        points, stackedOnPoints,\n\t                        coordSys, hasAnimation\n\t                    );\n\t                }\n\t                else if (polygon && !isAreaChart) {\n\t                    // If areaStyle is removed\n\t                    lineGroup.remove(polygon);\n\t                    polygon = this._polygon = null;\n\t                }\n\t\n\t                // Update clipPath\n\t                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\t\n\t                // Always update, or it is wrong in the case turning on legend\n\t                // because points are not changed\n\t                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\t\n\t                // Stop symbol animation and sync with line points\n\t                // FIXME performance?\n\t                data.eachItemGraphicEl(function (el) {\n\t                    el.stopAnimation(true);\n\t                });\n\t\n\t                // In the case data zoom triggerred refreshing frequently\n\t                // Data may not change if line has a category axis. So it should animate nothing\n\t                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n\t                    || !isPointsSame(this._points, points)\n\t                ) {\n\t                    if (hasAnimation) {\n\t                        this._updateAnimation(\n\t                            data, stackedOnPoints, coordSys, api, step\n\t                        );\n\t                    }\n\t                    else {\n\t                        // Not do it in update with animation\n\t                        if (step) {\n\t                            // TODO If stacked series is not step\n\t                            points = turnPointsIntoStep(points, coordSys, step);\n\t                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n\t                        }\n\t\n\t                        polyline.setShape({\n\t                            points: points\n\t                        });\n\t                        polygon && polygon.setShape({\n\t                            points: points,\n\t                            stackedOnPoints: stackedOnPoints\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t\n\t            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\t\n\t            polyline.useStyle(zrUtil.defaults(\n\t                // Use color in lineStyle first\n\t                lineStyleModel.getLineStyle(),\n\t                {\n\t                    fill: 'none',\n\t                    stroke: visualColor,\n\t                    lineJoin: 'bevel'\n\t                }\n\t            ));\n\t\n\t            var smooth = seriesModel.get('smooth');\n\t            smooth = getSmooth(seriesModel.get('smooth'));\n\t            polyline.setShape({\n\t                smooth: smooth,\n\t                smoothMonotone: seriesModel.get('smoothMonotone'),\n\t                connectNulls: seriesModel.get('connectNulls')\n\t            });\n\t\n\t            if (polygon) {\n\t                var stackedOn = data.stackedOn;\n\t                var stackedOnSmooth = 0;\n\t\n\t                polygon.useStyle(zrUtil.defaults(\n\t                    areaStyleModel.getAreaStyle(),\n\t                    {\n\t                        fill: visualColor,\n\t                        opacity: 0.7,\n\t                        lineJoin: 'bevel'\n\t                    }\n\t                ));\n\t\n\t                if (stackedOn) {\n\t                    var stackedOnSeries = stackedOn.hostModel;\n\t                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n\t                }\n\t\n\t                polygon.setShape({\n\t                    smooth: smooth,\n\t                    stackedOnSmooth: stackedOnSmooth,\n\t                    smoothMonotone: seriesModel.get('smoothMonotone'),\n\t                    connectNulls: seriesModel.get('connectNulls')\n\t                });\n\t            }\n\t\n\t            this._data = data;\n\t            // Save the coordinate system for transition animation when data changed\n\t            this._coordSys = coordSys;\n\t            this._stackedOnPoints = stackedOnPoints;\n\t            this._points = points;\n\t            this._step = step;\n\t        },\n\t\n\t        dispose: function () {},\n\t\n\t        highlight: function (seriesModel, ecModel, api, payload) {\n\t            var data = seriesModel.getData();\n\t            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t\n\t            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n\t                var symbol = data.getItemGraphicEl(dataIndex);\n\t                if (!symbol) {\n\t                    // Create a temporary symbol if it is not exists\n\t                    var pt = data.getItemLayout(dataIndex);\n\t                    symbol = new Symbol(data, dataIndex);\n\t                    symbol.position = pt;\n\t                    symbol.setZ(\n\t                        seriesModel.get('zlevel'),\n\t                        seriesModel.get('z')\n\t                    );\n\t                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n\t                    symbol.__temp = true;\n\t                    data.setItemGraphicEl(dataIndex, symbol);\n\t\n\t                    // Stop scale animation\n\t                    symbol.stopSymbolAnimation(true);\n\t\n\t                    this.group.add(symbol);\n\t                }\n\t                symbol.highlight();\n\t            }\n\t            else {\n\t                // Highlight whole series\n\t                ChartView.prototype.highlight.call(\n\t                    this, seriesModel, ecModel, api, payload\n\t                );\n\t            }\n\t        },\n\t\n\t        downplay: function (seriesModel, ecModel, api, payload) {\n\t            var data = seriesModel.getData();\n\t            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\t            if (dataIndex != null && dataIndex >= 0) {\n\t                var symbol = data.getItemGraphicEl(dataIndex);\n\t                if (symbol) {\n\t                    if (symbol.__temp) {\n\t                        data.setItemGraphicEl(dataIndex, null);\n\t                        this.group.remove(symbol);\n\t                    }\n\t                    else {\n\t                        symbol.downplay();\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                // Downplay whole series\n\t                ChartView.prototype.downplay.call(\n\t                    this, seriesModel, ecModel, api, payload\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/container/Group} group\n\t         * @param {Array.<Array.<number>>} points\n\t         * @private\n\t         */\n\t        _newPolyline: function (points) {\n\t            var polyline = this._polyline;\n\t            // Remove previous created polyline\n\t            if (polyline) {\n\t                this._lineGroup.remove(polyline);\n\t            }\n\t\n\t            polyline = new polyHelper.Polyline({\n\t                shape: {\n\t                    points: points\n\t                },\n\t                silent: true,\n\t                z2: 10\n\t            });\n\t\n\t            this._lineGroup.add(polyline);\n\t\n\t            this._polyline = polyline;\n\t\n\t            return polyline;\n\t        },\n\t\n\t        /**\n\t         * @param {module:zrender/container/Group} group\n\t         * @param {Array.<Array.<number>>} stackedOnPoints\n\t         * @param {Array.<Array.<number>>} points\n\t         * @private\n\t         */\n\t        _newPolygon: function (points, stackedOnPoints) {\n\t            var polygon = this._polygon;\n\t            // Remove previous created polygon\n\t            if (polygon) {\n\t                this._lineGroup.remove(polygon);\n\t            }\n\t\n\t            polygon = new polyHelper.Polygon({\n\t                shape: {\n\t                    points: points,\n\t                    stackedOnPoints: stackedOnPoints\n\t                },\n\t                silent: true\n\t            });\n\t\n\t            this._lineGroup.add(polygon);\n\t\n\t            this._polygon = polygon;\n\t            return polygon;\n\t        },\n\t        /**\n\t         * @private\n\t         */\n\t        _getSymbolIgnoreFunc: function (data, coordSys) {\n\t            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n\t            // `getLabelInterval` is provided by echarts/component/axis\n\t            if (categoryAxis && categoryAxis.isLabelIgnored) {\n\t                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        // FIXME Two value axis\n\t        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n\t            var polyline = this._polyline;\n\t            var polygon = this._polygon;\n\t            var seriesModel = data.hostModel;\n\t\n\t            var diff = lineAnimationDiff(\n\t                this._data, data,\n\t                this._stackedOnPoints, stackedOnPoints,\n\t                this._coordSys, coordSys\n\t            );\n\t\n\t            var current = diff.current;\n\t            var stackedOnCurrent = diff.stackedOnCurrent;\n\t            var next = diff.next;\n\t            var stackedOnNext = diff.stackedOnNext;\n\t            if (step) {\n\t                // TODO If stacked series is not step\n\t                current = turnPointsIntoStep(diff.current, coordSys, step);\n\t                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n\t                next = turnPointsIntoStep(diff.next, coordSys, step);\n\t                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n\t            }\n\t            // `diff.current` is subset of `current` (which should be ensured by\n\t            // turnPointsIntoStep), so points in `__points` can be updated when\n\t            // points in `current` are update during animation.\n\t            polyline.shape.__points = diff.current;\n\t            polyline.shape.points = current;\n\t\n\t            graphic.updateProps(polyline, {\n\t                shape: {\n\t                    points: next\n\t                }\n\t            }, seriesModel);\n\t\n\t            if (polygon) {\n\t                polygon.setShape({\n\t                    points: current,\n\t                    stackedOnPoints: stackedOnCurrent\n\t                });\n\t                graphic.updateProps(polygon, {\n\t                    shape: {\n\t                        points: next,\n\t                        stackedOnPoints: stackedOnNext\n\t                    }\n\t                }, seriesModel);\n\t            }\n\t\n\t            var updatedDataInfo = [];\n\t            var diffStatus = diff.status;\n\t\n\t            for (var i = 0; i < diffStatus.length; i++) {\n\t                var cmd = diffStatus[i].cmd;\n\t                if (cmd === '=') {\n\t                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n\t                    if (el) {\n\t                        updatedDataInfo.push({\n\t                            el: el,\n\t                            ptIdx: i    // Index of points\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t\n\t            if (polyline.animators && polyline.animators.length) {\n\t                polyline.animators[0].during(function () {\n\t                    for (var i = 0; i < updatedDataInfo.length; i++) {\n\t                        var el = updatedDataInfo[i].el;\n\t                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n\t                    }\n\t                });\n\t            }\n\t        },\n\t\n\t        remove: function (ecModel) {\n\t            var group = this.group;\n\t            var oldData = this._data;\n\t            this._lineGroup.removeAll();\n\t            this._symbolDraw.remove(true);\n\t            // Remove temporary created elements when highlighting\n\t            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n\t                if (el.__temp) {\n\t                    group.remove(el);\n\t                    oldData.setItemGraphicEl(idx, null);\n\t                }\n\t            });\n\t\n\t            this._polyline =\n\t            this._polygon =\n\t            this._coordSys =\n\t            this._points =\n\t            this._stackedOnPoints =\n\t            this._data = null;\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 531:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/SymbolDraw\n\t */\n\t\n\t\n\t    var graphic = __webpack_require__(164);\n\t    var Symbol = __webpack_require__(532);\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias module:echarts/chart/helper/SymbolDraw\n\t     * @param {module:zrender/graphic/Group} [symbolCtor]\n\t     */\n\t    function SymbolDraw(symbolCtor) {\n\t        this.group = new graphic.Group();\n\t\n\t        this._symbolCtor = symbolCtor || Symbol;\n\t    }\n\t\n\t    var symbolDrawProto = SymbolDraw.prototype;\n\t\n\t    function symbolNeedsDraw(data, idx, isIgnore) {\n\t        var point = data.getItemLayout(idx);\n\t        // Is an object\n\t        // if (point && point.hasOwnProperty('point')) {\n\t        //     point = point.point;\n\t        // }\n\t        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n\t                    && data.getItemVisual(idx, 'symbol') !== 'none';\n\t    }\n\t    /**\n\t     * Update symbols draw by new data\n\t     * @param {module:echarts/data/List} data\n\t     * @param {Array.<boolean>} [isIgnore]\n\t     */\n\t    symbolDrawProto.updateData = function (data, isIgnore) {\n\t        var group = this.group;\n\t        var seriesModel = data.hostModel;\n\t        var oldData = this._data;\n\t\n\t        var SymbolCtor = this._symbolCtor;\n\t\n\t        var seriesScope = {\n\t            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n\t            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n\t            symbolRotate: seriesModel.get('symbolRotate'),\n\t            symbolOffset: seriesModel.get('symbolOffset'),\n\t            hoverAnimation: seriesModel.get('hoverAnimation'),\n\t\n\t            labelModel: seriesModel.getModel('label.normal'),\n\t            hoverLabelModel: seriesModel.getModel('label.emphasis')\n\t        };\n\t\n\t        data.diff(oldData)\n\t            .add(function (newIdx) {\n\t                var point = data.getItemLayout(newIdx);\n\t                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n\t                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n\t                    symbolEl.attr('position', point);\n\t                    data.setItemGraphicEl(newIdx, symbolEl);\n\t                    group.add(symbolEl);\n\t                }\n\t            })\n\t            .update(function (newIdx, oldIdx) {\n\t                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n\t                var point = data.getItemLayout(newIdx);\n\t                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n\t                    group.remove(symbolEl);\n\t                    return;\n\t                }\n\t                if (!symbolEl) {\n\t                    symbolEl = new SymbolCtor(data, newIdx);\n\t                    symbolEl.attr('position', point);\n\t                }\n\t                else {\n\t                    symbolEl.updateData(data, newIdx, seriesScope);\n\t                    graphic.updateProps(symbolEl, {\n\t                        position: point\n\t                    }, seriesModel);\n\t                }\n\t\n\t                // Add back\n\t                group.add(symbolEl);\n\t\n\t                data.setItemGraphicEl(newIdx, symbolEl);\n\t            })\n\t            .remove(function (oldIdx) {\n\t                var el = oldData.getItemGraphicEl(oldIdx);\n\t                el && el.fadeOut(function () {\n\t                    group.remove(el);\n\t                });\n\t            })\n\t            .execute();\n\t\n\t        this._data = data;\n\t    };\n\t\n\t    symbolDrawProto.updateLayout = function () {\n\t        var data = this._data;\n\t        if (data) {\n\t            // Not use animation\n\t            data.eachItemGraphicEl(function (el, idx) {\n\t                var point = data.getItemLayout(idx);\n\t                el.attr('position', point);\n\t            });\n\t        }\n\t    };\n\t\n\t    symbolDrawProto.remove = function (enableAnimation) {\n\t        var group = this.group;\n\t        var data = this._data;\n\t        if (data) {\n\t            if (enableAnimation) {\n\t                data.eachItemGraphicEl(function (el) {\n\t                    el.fadeOut(function () {\n\t                        group.remove(el);\n\t                    });\n\t                });\n\t            }\n\t            else {\n\t                group.removeAll();\n\t            }\n\t        }\n\t    };\n\t\n\t    module.exports = SymbolDraw;\n\n\n/***/ },\n\n/***/ 532:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/chart/helper/Symbol\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var symbolUtil = __webpack_require__(533);\n\t    var graphic = __webpack_require__(164);\n\t    var numberUtil = __webpack_require__(128);\n\t\n\t    function normalizeSymbolSize(symbolSize) {\n\t        symbolSize = symbolSize instanceof Array\n\t            ? symbolSize.slice()\n\t            : [+symbolSize, +symbolSize];\n\t        symbolSize[0] /= 2;\n\t        symbolSize[1] /= 2;\n\t        return symbolSize;\n\t    }\n\t\n\t    /**\n\t     * @constructor\n\t     * @alias {module:echarts/chart/helper/Symbol}\n\t     * @param {module:echarts/data/List} data\n\t     * @param {number} idx\n\t     * @extends {module:zrender/graphic/Group}\n\t     */\n\t    function Symbol(data, idx, seriesScope) {\n\t        graphic.Group.call(this);\n\t\n\t        this.updateData(data, idx, seriesScope);\n\t    }\n\t\n\t    var symbolProto = Symbol.prototype;\n\t\n\t    function driftSymbol(dx, dy) {\n\t        this.parent.drift(dx, dy);\n\t    }\n\t\n\t    symbolProto._createSymbol = function (symbolType, data, idx) {\n\t        // Remove paths created before\n\t        this.removeAll();\n\t\n\t        var seriesModel = data.hostModel;\n\t        var color = data.getItemVisual(idx, 'color');\n\t\n\t        // var symbolPath = symbolUtil.createSymbol(\n\t        //     symbolType, -0.5, -0.5, 1, 1, color\n\t        // );\n\t        // If width/height are set too small (e.g., set to 1) on ios10\n\t        // and macOS Sierra, a circle stroke become a rect, no matter what\n\t        // the scale is set. So we set width/height as 2. See #4150.\n\t        var symbolPath = symbolUtil.createSymbol(\n\t            symbolType, -1, -1, 2, 2, color\n\t        );\n\t\n\t        symbolPath.attr({\n\t            z2: 100,\n\t            culling: true,\n\t            scale: [0, 0]\n\t        });\n\t        // Rewrite drift method\n\t        symbolPath.drift = driftSymbol;\n\t\n\t        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t\n\t        graphic.initProps(symbolPath, {\n\t            scale: size\n\t        }, seriesModel, idx);\n\t        this._symbolType = symbolType;\n\t\n\t        this.add(symbolPath);\n\t    };\n\t\n\t    /**\n\t     * Stop animation\n\t     * @param {boolean} toLastFrame\n\t     */\n\t    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n\t        this.childAt(0).stopAnimation(toLastFrame);\n\t    };\n\t\n\t    /**\n\t     * Get symbol path element\n\t     */\n\t    symbolProto.getSymbolPath = function () {\n\t        return this.childAt(0);\n\t    };\n\t\n\t    /**\n\t     * Get scale(aka, current symbol size).\n\t     * Including the change caused by animation\n\t     */\n\t    symbolProto.getScale = function () {\n\t        return this.childAt(0).scale;\n\t    };\n\t\n\t    /**\n\t     * Highlight symbol\n\t     */\n\t    symbolProto.highlight = function () {\n\t        this.childAt(0).trigger('emphasis');\n\t    };\n\t\n\t    /**\n\t     * Downplay symbol\n\t     */\n\t    symbolProto.downplay = function () {\n\t        this.childAt(0).trigger('normal');\n\t    };\n\t\n\t    /**\n\t     * @param {number} zlevel\n\t     * @param {number} z\n\t     */\n\t    symbolProto.setZ = function (zlevel, z) {\n\t        var symbolPath = this.childAt(0);\n\t        symbolPath.zlevel = zlevel;\n\t        symbolPath.z = z;\n\t    };\n\t\n\t    symbolProto.setDraggable = function (draggable) {\n\t        var symbolPath = this.childAt(0);\n\t        symbolPath.draggable = draggable;\n\t        symbolPath.cursor = draggable ? 'move' : 'pointer';\n\t    };\n\t\n\t    /**\n\t     * Update symbol properties\n\t     * @param  {module:echarts/data/List} data\n\t     * @param  {number} idx\n\t     */\n\t    symbolProto.updateData = function (data, idx, seriesScope) {\n\t        this.silent = false;\n\t\n\t        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n\t        var seriesModel = data.hostModel;\n\t        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t        if (symbolType !== this._symbolType) {\n\t            this._createSymbol(symbolType, data, idx);\n\t        }\n\t        else {\n\t            var symbolPath = this.childAt(0);\n\t            graphic.updateProps(symbolPath, {\n\t                scale: symbolSize\n\t            }, seriesModel, idx);\n\t        }\n\t        this._updateCommon(data, idx, symbolSize, seriesScope);\n\t        this._seriesModel = seriesModel;\n\t    };\n\t\n\t    // Update common properties\n\t    var normalStyleAccessPath = ['itemStyle', 'normal'];\n\t    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n\t    var normalLabelAccessPath = ['label', 'normal'];\n\t    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\t\n\t    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n\t        var symbolPath = this.childAt(0);\n\t        var seriesModel = data.hostModel;\n\t        var color = data.getItemVisual(idx, 'color');\n\t\n\t        // Reset style\n\t        if (symbolPath.type !== 'image') {\n\t            symbolPath.useStyle({\n\t                strokeNoScale: true\n\t            });\n\t        }\n\t\n\t        seriesScope = seriesScope || null;\n\t\n\t        var itemStyle = seriesScope && seriesScope.itemStyle;\n\t        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n\t        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n\t        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n\t        var labelModel = seriesScope && seriesScope.labelModel;\n\t        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n\t        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\t\n\t        if (!seriesScope || data.hasItemOption) {\n\t            var itemModel = data.getItemModel(idx);\n\t\n\t            // Color must be excluded.\n\t            // Because symbol provide setColor individually to set fill and stroke\n\t            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n\t            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\t\n\t            symbolRotate = itemModel.getShallow('symbolRotate');\n\t            symbolOffset = itemModel.getShallow('symbolOffset');\n\t\n\t            labelModel = itemModel.getModel(normalLabelAccessPath);\n\t            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n\t            hoverAnimation = itemModel.getShallow('hoverAnimation');\n\t        }\n\t        else {\n\t            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n\t        }\n\t\n\t        var elStyle = symbolPath.style;\n\t\n\t        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\t\n\t        if (symbolOffset) {\n\t            symbolPath.attr('position', [\n\t                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n\t                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n\t            ]);\n\t        }\n\t\n\t        // PENDING setColor before setStyle!!!\n\t        symbolPath.setColor(color);\n\t\n\t        symbolPath.setStyle(itemStyle);\n\t\n\t        var opacity = data.getItemVisual(idx, 'opacity');\n\t        if (opacity != null) {\n\t            elStyle.opacity = opacity;\n\t        }\n\t\n\t        // Get last value dim\n\t        var dimensions = data.dimensions.slice();\n\t        var valueDim;\n\t        var dataType;\n\t        while (dimensions.length && (\n\t            valueDim = dimensions.pop(),\n\t            dataType = data.getDimensionInfo(valueDim).type,\n\t            dataType === 'ordinal' || dataType === 'time'\n\t        )) {} // jshint ignore:line\n\t\n\t        if (valueDim != null && labelModel.getShallow('show')) {\n\t            graphic.setText(elStyle, labelModel, color);\n\t            elStyle.text = zrUtil.retrieve(\n\t                seriesModel.getFormattedLabel(idx, 'normal'),\n\t                data.get(valueDim, idx)\n\t            );\n\t        }\n\t        else {\n\t            elStyle.text = '';\n\t        }\n\t\n\t        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n\t            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n\t            hoverItemStyle.text = zrUtil.retrieve(\n\t                seriesModel.getFormattedLabel(idx, 'emphasis'),\n\t                data.get(valueDim, idx)\n\t            );\n\t        }\n\t        else {\n\t            hoverItemStyle.text = '';\n\t        }\n\t\n\t        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\t\n\t        symbolPath.off('mouseover')\n\t            .off('mouseout')\n\t            .off('emphasis')\n\t            .off('normal');\n\t\n\t        symbolPath.hoverStyle = hoverItemStyle;\n\t\n\t        graphic.setHoverStyle(symbolPath);\n\t\n\t        if (hoverAnimation && seriesModel.ifEnableAnimation()) {\n\t            var onEmphasis = function() {\n\t                var ratio = size[1] / size[0];\n\t                this.animateTo({\n\t                    scale: [\n\t                        Math.max(size[0] * 1.1, size[0] + 3),\n\t                        Math.max(size[1] * 1.1, size[1] + 3 * ratio)\n\t                    ]\n\t                }, 400, 'elasticOut');\n\t            };\n\t            var onNormal = function() {\n\t                this.animateTo({\n\t                    scale: size\n\t                }, 400, 'elasticOut');\n\t            };\n\t            symbolPath.on('mouseover', onEmphasis)\n\t                .on('mouseout', onNormal)\n\t                .on('emphasis', onEmphasis)\n\t                .on('normal', onNormal);\n\t        }\n\t    };\n\t\n\t    symbolProto.fadeOut = function (cb) {\n\t        var symbolPath = this.childAt(0);\n\t        // Avoid mistaken hover when fading out\n\t        this.silent = true;\n\t        // Not show text when animating\n\t        symbolPath.style.text = '';\n\t        graphic.updateProps(symbolPath, {\n\t            scale: [0, 0]\n\t        }, this._seriesModel, this.dataIndex, cb);\n\t    };\n\t\n\t    zrUtil.inherits(Symbol, graphic.Group);\n\t\n\t    module.exports = Symbol;\n\n\n/***/ },\n\n/***/ 533:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Symbol factory\n\t\n\t\n\t    var graphic = __webpack_require__(164);\n\t    var BoundingRect = __webpack_require__(130);\n\t\n\t    /**\n\t     * Triangle shape\n\t     * @inner\n\t     */\n\t    var Triangle = graphic.extendShape({\n\t        type: 'triangle',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy + height);\n\t            path.lineTo(cx - width, cy + height);\n\t            path.closePath();\n\t        }\n\t    });\n\t    /**\n\t     * Diamond shape\n\t     * @inner\n\t     */\n\t    var Diamond = graphic.extendShape({\n\t        type: 'diamond',\n\t        shape: {\n\t            cx: 0,\n\t            cy: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t        buildPath: function (path, shape) {\n\t            var cx = shape.cx;\n\t            var cy = shape.cy;\n\t            var width = shape.width / 2;\n\t            var height = shape.height / 2;\n\t            path.moveTo(cx, cy - height);\n\t            path.lineTo(cx + width, cy);\n\t            path.lineTo(cx, cy + height);\n\t            path.lineTo(cx - width, cy);\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Pin shape\n\t     * @inner\n\t     */\n\t    var Pin = graphic.extendShape({\n\t        type: 'pin',\n\t        shape: {\n\t            // x, y on the cusp\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (path, shape) {\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var w = shape.width / 5 * 3;\n\t            // Height must be larger than width\n\t            var h = Math.max(w, shape.height);\n\t            var r = w / 2;\n\t\n\t            // Dist on y with tangent point and circle center\n\t            var dy = r * r / (h - r);\n\t            var cy = y - h + r + dy;\n\t            var angle = Math.asin(dy / r);\n\t            // Dist on x with tangent point and circle center\n\t            var dx = Math.cos(angle) * r;\n\t\n\t            var tanX = Math.sin(angle);\n\t            var tanY = Math.cos(angle);\n\t\n\t            path.arc(\n\t                x, cy, r,\n\t                Math.PI - angle,\n\t                Math.PI * 2 + angle\n\t            );\n\t\n\t            var cpLen = r * 0.6;\n\t            var cpLen2 = r * 0.7;\n\t            path.bezierCurveTo(\n\t                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x, y - cpLen2,\n\t                x, y\n\t            );\n\t            path.bezierCurveTo(\n\t                x, y - cpLen2,\n\t                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n\t                x - dx, cy + dy\n\t            );\n\t            path.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Arrow shape\n\t     * @inner\n\t     */\n\t    var Arrow = graphic.extendShape({\n\t\n\t        type: 'arrow',\n\t\n\t        shape: {\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        buildPath: function (ctx, shape) {\n\t            var height = shape.height;\n\t            var width = shape.width;\n\t            var x = shape.x;\n\t            var y = shape.y;\n\t            var dx = width / 3 * 2;\n\t            ctx.moveTo(x, y);\n\t            ctx.lineTo(x + dx, y + height);\n\t            ctx.lineTo(x, y + height / 4 * 3);\n\t            ctx.lineTo(x - dx, y + height);\n\t            ctx.lineTo(x, y);\n\t            ctx.closePath();\n\t        }\n\t    });\n\t\n\t    /**\n\t     * Map of path contructors\n\t     * @type {Object.<string, module:zrender/graphic/Path>}\n\t     */\n\t    var symbolCtors = {\n\t        line: graphic.Line,\n\t\n\t        rect: graphic.Rect,\n\t\n\t        roundRect: graphic.Rect,\n\t\n\t        square: graphic.Rect,\n\t\n\t        circle: graphic.Circle,\n\t\n\t        diamond: Diamond,\n\t\n\t        pin: Pin,\n\t\n\t        arrow: Arrow,\n\t\n\t        triangle: Triangle\n\t    };\n\t\n\t    var symbolShapeMakers = {\n\t\n\t        line: function (x, y, w, h, shape) {\n\t            // FIXME\n\t            shape.x1 = x;\n\t            shape.y1 = y + h / 2;\n\t            shape.x2 = x + w;\n\t            shape.y2 = y + h / 2;\n\t        },\n\t\n\t        rect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        roundRect: function (x, y, w, h, shape) {\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = w;\n\t            shape.height = h;\n\t            shape.r = Math.min(w, h) / 4;\n\t        },\n\t\n\t        square: function (x, y, w, h, shape) {\n\t            var size = Math.min(w, h);\n\t            shape.x = x;\n\t            shape.y = y;\n\t            shape.width = size;\n\t            shape.height = size;\n\t        },\n\t\n\t        circle: function (x, y, w, h, shape) {\n\t            // Put circle in the center of square\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.r = Math.min(w, h) / 2;\n\t        },\n\t\n\t        diamond: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        pin: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        arrow: function (x, y, w, h, shape) {\n\t            shape.x = x + w / 2;\n\t            shape.y = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        },\n\t\n\t        triangle: function (x, y, w, h, shape) {\n\t            shape.cx = x + w / 2;\n\t            shape.cy = y + h / 2;\n\t            shape.width = w;\n\t            shape.height = h;\n\t        }\n\t    };\n\t\n\t    var symbolBuildProxies = {};\n\t    for (var name in symbolCtors) {\n\t        if (symbolCtors.hasOwnProperty(name)) {\n\t            symbolBuildProxies[name] = new symbolCtors[name]();\n\t        }\n\t    }\n\t\n\t    var Symbol = graphic.extendShape({\n\t\n\t        type: 'symbol',\n\t\n\t        shape: {\n\t            symbolType: '',\n\t            x: 0,\n\t            y: 0,\n\t            width: 0,\n\t            height: 0\n\t        },\n\t\n\t        beforeBrush: function () {\n\t            var style = this.style;\n\t            var shape = this.shape;\n\t            // FIXME\n\t            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n\t                style.textPosition = ['50%', '40%'];\n\t                style.textAlign = 'center';\n\t                style.textVerticalAlign = 'middle';\n\t            }\n\t        },\n\t\n\t        buildPath: function (ctx, shape, inBundle) {\n\t            var symbolType = shape.symbolType;\n\t            var proxySymbol = symbolBuildProxies[symbolType];\n\t            if (shape.symbolType !== 'none') {\n\t                if (!proxySymbol) {\n\t                    // Default rect\n\t                    symbolType = 'rect';\n\t                    proxySymbol = symbolBuildProxies[symbolType];\n\t                }\n\t                symbolShapeMakers[symbolType](\n\t                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n\t                );\n\t                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n\t            }\n\t        }\n\t    });\n\t\n\t    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n\t    var symbolPathSetColor = function (color) {\n\t        if (this.type !== 'image') {\n\t            var symbolStyle = this.style;\n\t            var symbolShape = this.shape;\n\t            if (symbolShape && symbolShape.symbolType === 'line') {\n\t                symbolStyle.stroke = color;\n\t            }\n\t            else if (this.__isEmptyBrush) {\n\t                symbolStyle.stroke = color;\n\t                symbolStyle.fill = '#fff';\n\t            }\n\t            else {\n\t                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n\t                symbolStyle.fill && (symbolStyle.fill = color);\n\t                symbolStyle.stroke && (symbolStyle.stroke = color);\n\t            }\n\t            this.dirty(false);\n\t        }\n\t    };\n\t\n\t    var symbolUtil = {\n\t        /**\n\t         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n\t         * @param {string} symbolType\n\t         * @param {number} x\n\t         * @param {number} y\n\t         * @param {number} w\n\t         * @param {number} h\n\t         * @param {string} color\n\t         */\n\t        createSymbol: function (symbolType, x, y, w, h, color) {\n\t            var isEmpty = symbolType.indexOf('empty') === 0;\n\t            if (isEmpty) {\n\t                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n\t            }\n\t            var symbolPath;\n\t\n\t            if (symbolType.indexOf('image://') === 0) {\n\t                symbolPath = new graphic.Image({\n\t                    style: {\n\t                        image: symbolType.slice(8),\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t            else if (symbolType.indexOf('path://') === 0) {\n\t                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n\t            }\n\t            else {\n\t                symbolPath = new Symbol({\n\t                    shape: {\n\t                        symbolType: symbolType,\n\t                        x: x,\n\t                        y: y,\n\t                        width: w,\n\t                        height: h\n\t                    }\n\t                });\n\t            }\n\t\n\t            symbolPath.__isEmptyBrush = isEmpty;\n\t\n\t            symbolPath.setColor = symbolPathSetColor;\n\t\n\t            symbolPath.setColor(color);\n\t\n\t            return symbolPath;\n\t        }\n\t    };\n\t\n\t    module.exports = symbolUtil;\n\n\n/***/ },\n\n/***/ 534:\n/***/ function(module, exports) {\n\n\t\n\t\n\t    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n\t    // 'zrender/core/arrayDiff' has been used before, but it did\n\t    // not do well in performance when roam with fixed dataZoom window.\n\t\n\t    function sign(val) {\n\t        return val >= 0 ? 1 : -1;\n\t    }\n\t\n\t    function getStackedOnPoint(coordSys, data, idx) {\n\t        var baseAxis = coordSys.getBaseAxis();\n\t        var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t        var valueStart = baseAxis.onZero\n\t            ? 0 : valueAxis.scale.getExtent()[0];\n\t\n\t        var valueDim = valueAxis.dim;\n\t        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\t\n\t        var stackedOnSameSign;\n\t        var stackedOn = data.stackedOn;\n\t        var val = data.get(valueDim, idx);\n\t        // Find first stacked value with same sign\n\t        while (stackedOn &&\n\t            sign(stackedOn.get(valueDim, idx)) === sign(val)\n\t        ) {\n\t            stackedOnSameSign = stackedOn;\n\t            break;\n\t        }\n\t        var stackedData = [];\n\t        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n\t        stackedData[1 - baseDataOffset] = stackedOnSameSign\n\t            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\t\n\t        return coordSys.dataToPoint(stackedData);\n\t    }\n\t\n\t    // function convertToIntId(newIdList, oldIdList) {\n\t    //     // Generate int id instead of string id.\n\t    //     // Compare string maybe slow in score function of arrDiff\n\t\n\t    //     // Assume id in idList are all unique\n\t    //     var idIndicesMap = {};\n\t    //     var idx = 0;\n\t    //     for (var i = 0; i < newIdList.length; i++) {\n\t    //         idIndicesMap[newIdList[i]] = idx;\n\t    //         newIdList[i] = idx++;\n\t    //     }\n\t    //     for (var i = 0; i < oldIdList.length; i++) {\n\t    //         var oldId = oldIdList[i];\n\t    //         // Same with newIdList\n\t    //         if (idIndicesMap[oldId]) {\n\t    //             oldIdList[i] = idIndicesMap[oldId];\n\t    //         }\n\t    //         else {\n\t    //             oldIdList[i] = idx++;\n\t    //         }\n\t    //     }\n\t    // }\n\t\n\t    function diffData(oldData, newData) {\n\t        var diffResult = [];\n\t\n\t        newData.diff(oldData)\n\t            .add(function (idx) {\n\t                diffResult.push({cmd: '+', idx: idx});\n\t            })\n\t            .update(function (newIdx, oldIdx) {\n\t                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n\t            })\n\t            .remove(function (idx) {\n\t                diffResult.push({cmd: '-', idx: idx});\n\t            })\n\t            .execute();\n\t\n\t        return diffResult;\n\t    }\n\t\n\t    module.exports = function (\n\t        oldData, newData,\n\t        oldStackedOnPoints, newStackedOnPoints,\n\t        oldCoordSys, newCoordSys\n\t    ) {\n\t        var diff = diffData(oldData, newData);\n\t\n\t        // var newIdList = newData.mapArray(newData.getId);\n\t        // var oldIdList = oldData.mapArray(oldData.getId);\n\t\n\t        // convertToIntId(newIdList, oldIdList);\n\t\n\t        // // FIXME One data ?\n\t        // diff = arrayDiff(oldIdList, newIdList);\n\t\n\t        var currPoints = [];\n\t        var nextPoints = [];\n\t        // Points for stacking base line\n\t        var currStackedPoints = [];\n\t        var nextStackedPoints = [];\n\t\n\t        var status = [];\n\t        var sortedIndices = [];\n\t        var rawIndices = [];\n\t        var dims = newCoordSys.dimensions;\n\t        for (var i = 0; i < diff.length; i++) {\n\t            var diffItem = diff[i];\n\t            var pointAdded = true;\n\t\n\t            // FIXME, animation is not so perfect when dataZoom window moves fast\n\t            // Which is in case remvoing or add more than one data in the tail or head\n\t            switch (diffItem.cmd) {\n\t                case '=':\n\t                    var currentPt = oldData.getItemLayout(diffItem.idx);\n\t                    var nextPt = newData.getItemLayout(diffItem.idx1);\n\t                    // If previous data is NaN, use next point directly\n\t                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n\t                        currentPt = nextPt.slice();\n\t                    }\n\t                    currPoints.push(currentPt);\n\t                    nextPoints.push(nextPt);\n\t\n\t                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n\t                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\t\n\t                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n\t                    break;\n\t                case '+':\n\t                    var idx = diffItem.idx;\n\t                    currPoints.push(\n\t                        oldCoordSys.dataToPoint([\n\t                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n\t                        ])\n\t                    );\n\t\n\t                    nextPoints.push(newData.getItemLayout(idx).slice());\n\t\n\t                    currStackedPoints.push(\n\t                        getStackedOnPoint(oldCoordSys, newData, idx)\n\t                    );\n\t                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\t\n\t                    rawIndices.push(newData.getRawIndex(idx));\n\t                    break;\n\t                case '-':\n\t                    var idx = diffItem.idx;\n\t                    var rawIndex = oldData.getRawIndex(idx);\n\t                    // Data is replaced. In the case of dynamic data queue\n\t                    // FIXME FIXME FIXME\n\t                    if (rawIndex !== idx) {\n\t                        currPoints.push(oldData.getItemLayout(idx));\n\t                        nextPoints.push(newCoordSys.dataToPoint([\n\t                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n\t                        ]));\n\t\n\t                        currStackedPoints.push(oldStackedOnPoints[idx]);\n\t                        nextStackedPoints.push(\n\t                            getStackedOnPoint(\n\t                                newCoordSys, oldData, idx\n\t                            )\n\t                        );\n\t\n\t                        rawIndices.push(rawIndex);\n\t                    }\n\t                    else {\n\t                        pointAdded = false;\n\t                    }\n\t            }\n\t\n\t            // Original indices\n\t            if (pointAdded) {\n\t                status.push(diffItem);\n\t                sortedIndices.push(sortedIndices.length);\n\t            }\n\t        }\n\t\n\t        // Diff result may be crossed if all items are changed\n\t        // Sort by data index\n\t        sortedIndices.sort(function (a, b) {\n\t            return rawIndices[a] - rawIndices[b];\n\t        });\n\t\n\t        var sortedCurrPoints = [];\n\t        var sortedNextPoints = [];\n\t\n\t        var sortedCurrStackedPoints = [];\n\t        var sortedNextStackedPoints = [];\n\t\n\t        var sortedStatus = [];\n\t        for (var i = 0; i < sortedIndices.length; i++) {\n\t            var idx = sortedIndices[i];\n\t            sortedCurrPoints[i] = currPoints[idx];\n\t            sortedNextPoints[i] = nextPoints[idx];\n\t\n\t            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n\t            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\t\n\t            sortedStatus[i] = status[idx];\n\t        }\n\t\n\t        return {\n\t            current: sortedCurrPoints,\n\t            next: sortedNextPoints,\n\t\n\t            stackedOnCurrent: sortedCurrStackedPoints,\n\t            stackedOnNext: sortedNextStackedPoints,\n\t\n\t            status: sortedStatus\n\t        };\n\t    };\n\n\n/***/ },\n\n/***/ 535:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Poly path support NaN point\n\t\n\t\n\t    var Path = __webpack_require__(166);\n\t    var vec2 = __webpack_require__(131);\n\t\n\t    var vec2Min = vec2.min;\n\t    var vec2Max = vec2.max;\n\t\n\t    var scaleAndAdd = vec2.scaleAndAdd;\n\t    var v2Copy = vec2.copy;\n\t\n\t    // Temporary variable\n\t    var v = [];\n\t    var cp0 = [];\n\t    var cp1 = [];\n\t\n\t    function isPointNull(p) {\n\t        return isNaN(p[0]) || isNaN(p[1]);\n\t    }\n\t\n\t    function drawSegment(\n\t        ctx, points, start, segLen, allLen,\n\t        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n\t    ) {\n\t        var prevIdx = 0;\n\t        var idx = start;\n\t        for (var k = 0; k < segLen; k++) {\n\t            var p = points[idx];\n\t            if (idx >= allLen || idx < 0) {\n\t                break;\n\t            }\n\t            if (isPointNull(p)) {\n\t                if (connectNulls) {\n\t                    idx += dir;\n\t                    continue;\n\t                }\n\t                break;\n\t            }\n\t\n\t            if (idx === start) {\n\t                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n\t                v2Copy(cp0, p);\n\t            }\n\t            else {\n\t                if (smooth > 0) {\n\t                    var nextIdx = idx + dir;\n\t                    var nextP = points[nextIdx];\n\t                    if (connectNulls) {\n\t                        // Find next point not null\n\t                        while (nextP && isPointNull(points[nextIdx])) {\n\t                            nextIdx += dir;\n\t                            nextP = points[nextIdx];\n\t                        }\n\t                    }\n\t\n\t                    var ratioNextSeg = 0.5;\n\t                    var prevP = points[prevIdx];\n\t                    var nextP = points[nextIdx];\n\t                    // Last point\n\t                    if (!nextP || isPointNull(nextP)) {\n\t                        v2Copy(cp1, p);\n\t                    }\n\t                    else {\n\t                        // If next data is null in not connect case\n\t                        if (isPointNull(nextP) && !connectNulls) {\n\t                            nextP = p;\n\t                        }\n\t\n\t                        vec2.sub(v, nextP, prevP);\n\t\n\t                        var lenPrevSeg;\n\t                        var lenNextSeg;\n\t                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n\t                            var dim = smoothMonotone === 'x' ? 0 : 1;\n\t                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n\t                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n\t                        }\n\t                        else {\n\t                            lenPrevSeg = vec2.dist(p, prevP);\n\t                            lenNextSeg = vec2.dist(p, nextP);\n\t                        }\n\t\n\t                        // Use ratio of seg length\n\t                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\t\n\t                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n\t                    }\n\t                    // Smooth constraint\n\t                    vec2Min(cp0, cp0, smoothMax);\n\t                    vec2Max(cp0, cp0, smoothMin);\n\t                    vec2Min(cp1, cp1, smoothMax);\n\t                    vec2Max(cp1, cp1, smoothMin);\n\t\n\t                    ctx.bezierCurveTo(\n\t                        cp0[0], cp0[1],\n\t                        cp1[0], cp1[1],\n\t                        p[0], p[1]\n\t                    );\n\t                    // cp0 of next segment\n\t                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n\t                }\n\t                else {\n\t                    ctx.lineTo(p[0], p[1]);\n\t                }\n\t            }\n\t\n\t            prevIdx = idx;\n\t            idx += dir;\n\t        }\n\t\n\t        return k;\n\t    }\n\t\n\t    function getBoundingBox(points, smoothConstraint) {\n\t        var ptMin = [Infinity, Infinity];\n\t        var ptMax = [-Infinity, -Infinity];\n\t        if (smoothConstraint) {\n\t            for (var i = 0; i < points.length; i++) {\n\t                var pt = points[i];\n\t                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n\t                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n\t                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n\t                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n\t            }\n\t        }\n\t        return {\n\t            min: smoothConstraint ? ptMin : ptMax,\n\t            max: smoothConstraint ? ptMax : ptMin\n\t        };\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        Polyline: Path.extend({\n\t\n\t            type: 'ec-polyline',\n\t\n\t            shape: {\n\t                points: [],\n\t\n\t                smooth: 0,\n\t\n\t                smoothConstraint: true,\n\t\n\t                smoothMonotone: null,\n\t\n\t                connectNulls: false\n\t            },\n\t\n\t            style: {\n\t                fill: null,\n\t\n\t                stroke: '#000'\n\t            },\n\t\n\t            buildPath: function (ctx, shape) {\n\t                var points = shape.points;\n\t\n\t                var i = 0;\n\t                var len = points.length;\n\t\n\t                var result = getBoundingBox(points, shape.smoothConstraint);\n\t\n\t                if (shape.connectNulls) {\n\t                    // Must remove first and last null values avoid draw error in polygon\n\t                    for (; len > 0; len--) {\n\t                        if (!isPointNull(points[len - 1])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                    for (; i < len; i++) {\n\t                        if (!isPointNull(points[i])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                while (i < len) {\n\t                    i += drawSegment(\n\t                        ctx, points, i, len, len,\n\t                        1, result.min, result.max, shape.smooth,\n\t                        shape.smoothMonotone, shape.connectNulls\n\t                    ) + 1;\n\t                }\n\t            }\n\t        }),\n\t\n\t        Polygon: Path.extend({\n\t\n\t            type: 'ec-polygon',\n\t\n\t            shape: {\n\t                points: [],\n\t\n\t                // Offset between stacked base points and points\n\t                stackedOnPoints: [],\n\t\n\t                smooth: 0,\n\t\n\t                stackedOnSmooth: 0,\n\t\n\t                smoothConstraint: true,\n\t\n\t                smoothMonotone: null,\n\t\n\t                connectNulls: false\n\t            },\n\t\n\t            buildPath: function (ctx, shape) {\n\t                var points = shape.points;\n\t                var stackedOnPoints = shape.stackedOnPoints;\n\t\n\t                var i = 0;\n\t                var len = points.length;\n\t                var smoothMonotone = shape.smoothMonotone;\n\t                var bbox = getBoundingBox(points, shape.smoothConstraint);\n\t                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\t\n\t                if (shape.connectNulls) {\n\t                    // Must remove first and last null values avoid draw error in polygon\n\t                    for (; len > 0; len--) {\n\t                        if (!isPointNull(points[len - 1])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                    for (; i < len; i++) {\n\t                        if (!isPointNull(points[i])) {\n\t                            break;\n\t                        }\n\t                    }\n\t                }\n\t                while (i < len) {\n\t                    var k = drawSegment(\n\t                        ctx, points, i, len, len,\n\t                        1, bbox.min, bbox.max, shape.smooth,\n\t                        smoothMonotone, shape.connectNulls\n\t                    );\n\t                    drawSegment(\n\t                        ctx, stackedOnPoints, i + k - 1, k, len,\n\t                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n\t                        smoothMonotone, shape.connectNulls\n\t                    );\n\t                    i += k + 1;\n\t\n\t                    ctx.closePath();\n\t                }\n\t            }\n\t        })\n\t    };\n\n\n/***/ },\n\n/***/ 536:\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\t\n\t        // Encoding visual for all series include which is filtered for legend drawing\n\t        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t\n\t            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n\t            var symbolSize = seriesModel.get('symbolSize');\n\t\n\t            data.setVisual({\n\t                legendSymbol: legendSymbol || symbolType,\n\t                symbol: symbolType,\n\t                symbolSize: symbolSize\n\t            });\n\t\n\t            // Only visible series has each data be visual encoded\n\t            if (!ecModel.isSeriesFiltered(seriesModel)) {\n\t                if (typeof symbolSize === 'function') {\n\t                    data.each(function (idx) {\n\t                        var rawValue = seriesModel.getRawValue(idx);\n\t                        // FIXME\n\t                        var params = seriesModel.getDataParams(idx);\n\t                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n\t                    });\n\t                }\n\t                data.each(function (idx) {\n\t                    var itemModel = data.getItemModel(idx);\n\t                    var itemSymbolType = itemModel.getShallow('symbol', true);\n\t                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n\t                    // If has item symbol\n\t                    if (itemSymbolType != null) {\n\t                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n\t                    }\n\t                    if (itemSymbolSize != null) {\n\t                        // PENDING Transform symbolSize ?\n\t                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n\t                    }\n\t                });\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n\n/***/ 537:\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = function (seriesType, ecModel) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var coordSys = seriesModel.coordinateSystem;\n\t\n\t            if (coordSys) {\n\t                var dims = coordSys.dimensions;\n\t\n\t                if (coordSys.type === 'singleAxis') {\n\t                    data.each(dims[0], function (x, idx) {\n\t                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n\t                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n\t                    });\n\t                }\n\t                else {\n\t                    data.each(dims, function (x, y, idx) {\n\t                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n\t                        data.setItemLayout(\n\t                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n\t                        );\n\t                    }, true);\n\t                }\n\t            }\n\t        });\n\t    };\n\n\n/***/ },\n\n/***/ 538:\n/***/ function(module, exports) {\n\n\t\n\t    var samplers = {\n\t        average: function (frame) {\n\t            var sum = 0;\n\t            var count = 0;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                if (!isNaN(frame[i])) {\n\t                    sum += frame[i];\n\t                    count++;\n\t                }\n\t            }\n\t            // Return NaN if count is 0\n\t            return count === 0 ? NaN : sum / count;\n\t        },\n\t        sum: function (frame) {\n\t            var sum = 0;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                // Ignore NaN\n\t                sum += frame[i] || 0;\n\t            }\n\t            return sum;\n\t        },\n\t        max: function (frame) {\n\t            var max = -Infinity;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                frame[i] > max && (max = frame[i]);\n\t            }\n\t            return max;\n\t        },\n\t        min: function (frame) {\n\t            var min = Infinity;\n\t            for (var i = 0; i < frame.length; i++) {\n\t                frame[i] < min && (min = frame[i]);\n\t            }\n\t            return min;\n\t        },\n\t        // TODO\n\t        // Median\n\t        nearest: function (frame) {\n\t            return frame[0];\n\t        }\n\t    };\n\t\n\t    var indexSampler = function (frame, value) {\n\t        return Math.round(frame.length / 2);\n\t    };\n\t    module.exports = function (seriesType, ecModel, api) {\n\t        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n\t            var data = seriesModel.getData();\n\t            var sampling = seriesModel.get('sampling');\n\t            var coordSys = seriesModel.coordinateSystem;\n\t            // Only cartesian2d support down sampling\n\t            if (coordSys.type === 'cartesian2d' && sampling) {\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                var valueAxis = coordSys.getOtherAxis(baseAxis);\n\t                var extent = baseAxis.getExtent();\n\t                // Coordinste system has been resized\n\t                var size = extent[1] - extent[0];\n\t                var rate = Math.round(data.count() / size);\n\t                if (rate > 1) {\n\t                    var sampler;\n\t                    if (typeof sampling === 'string') {\n\t                        sampler = samplers[sampling];\n\t                    }\n\t                    else if (typeof sampling === 'function') {\n\t                        sampler = sampling;\n\t                    }\n\t                    if (sampler) {\n\t                        data = data.downSample(\n\t                            valueAxis.dim, 1 / rate, sampler, indexSampler\n\t                        );\n\t                        seriesModel.setData(data);\n\t                    }\n\t                }\n\t            }\n\t        }, this);\n\t    };\n\n\n/***/ },\n\n/***/ 539:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var graphic = __webpack_require__(164);\n\t    var zrUtil = __webpack_require__(125);\n\t    var echarts = __webpack_require__(122);\n\t\n\t    __webpack_require__(540);\n\t\n\t    __webpack_require__(558);\n\t\n\t    // Grid view\n\t    echarts.extendComponentView({\n\t\n\t        type: 'grid',\n\t\n\t        render: function (gridModel, ecModel) {\n\t            this.group.removeAll();\n\t            if (gridModel.get('show')) {\n\t                this.group.add(new graphic.Rect({\n\t                    shape: gridModel.coordinateSystem.getRect(),\n\t                    style: zrUtil.defaults({\n\t                        fill: gridModel.get('backgroundColor')\n\t                    }, gridModel.getItemStyle()),\n\t                    silent: true,\n\t                    z2: -1\n\t                }));\n\t            }\n\t        }\n\t\n\t    });\n\t\n\t    echarts.registerPreprocessor(function (option) {\n\t        // Only create grid when need\n\t        if (option.xAxis && option.yAxis && !option.grid) {\n\t            option.grid = {};\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 540:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Grid is a region which contains at most 4 cartesian systems\n\t *\n\t * TODO Default cartesian\n\t */\n\tvar factory = exports;\n\t\n\t    var layout = __webpack_require__(142);\n\t    var axisHelper = __webpack_require__(541);\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var Cartesian2D = __webpack_require__(547);\n\t    var Axis2D = __webpack_require__(549);\n\t\n\t    var each = zrUtil.each;\n\t\n\t    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n\t    var niceScaleExtent = axisHelper.niceScaleExtent;\n\t\n\t    // 依赖 GridModel, AxisModel 做预处理\n\t    __webpack_require__(552);\n\t\n\t    /**\n\t     * Check if the axis is used in the specified grid\n\t     * @inner\n\t     */\n\t    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n\t        return axisModel.findGridModel() === gridModel;\n\t    }\n\t\n\t    function getLabelUnionRect(axis) {\n\t        var axisModel = axis.model;\n\t        var labels = axisModel.getFormattedLabels();\n\t        var rect;\n\t        var step = 1;\n\t        var labelCount = labels.length;\n\t        if (labelCount > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.ceil(labelCount / 40);\n\t        }\n\t        for (var i = 0; i < labelCount; i += step) {\n\t            if (!axis.isLabelIgnored(i)) {\n\t                var singleRect = axisModel.getTextRect(labels[i]);\n\t                // FIXME consider label rotate\n\t                rect ? rect.union(singleRect) : (rect = singleRect);\n\t            }\n\t        }\n\t        return rect;\n\t    }\n\t\n\t    function Grid(gridModel, ecModel, api) {\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n\t         * @private\n\t         */\n\t        this._coordsMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n\t         * @private\n\t         */\n\t        this._coordsList = [];\n\t\n\t        /**\n\t         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesMap = {};\n\t\n\t        /**\n\t         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n\t         * @private\n\t         */\n\t        this._axesList = [];\n\t\n\t        this._initCartesian(gridModel, ecModel, api);\n\t\n\t        this._model = gridModel;\n\t    }\n\t\n\t    var gridProto = Grid.prototype;\n\t\n\t    gridProto.type = 'grid';\n\t\n\t    gridProto.getRect = function () {\n\t        return this._rect;\n\t    };\n\t\n\t    gridProto.update = function (ecModel, api) {\n\t\n\t        var axesMap = this._axesMap;\n\t\n\t        this._updateScale(ecModel, this._model);\n\t\n\t        function ifAxisCanNotOnZero(otherAxisDim) {\n\t            var axes = axesMap[otherAxisDim];\n\t            for (var idx in axes) {\n\t                if (axes.hasOwnProperty(idx)) {\n\t                    var axis = axes[idx];\n\t                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n\t                        return true;\n\t                    }\n\t                }\n\t            }\n\t            return false;\n\t        }\n\t\n\t        each(axesMap.x, function (xAxis) {\n\t            niceScaleExtent(xAxis, xAxis.model);\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            niceScaleExtent(yAxis, yAxis.model);\n\t        });\n\t        // Fix configuration\n\t        each(axesMap.x, function (xAxis) {\n\t            // onZero can not be enabled in these two situations\n\t            // 1. When any other axis is a category axis\n\t            // 2. When any other axis not across 0 point\n\t            if (ifAxisCanNotOnZero('y')) {\n\t                xAxis.onZero = false;\n\t            }\n\t        });\n\t        each(axesMap.y, function (yAxis) {\n\t            if (ifAxisCanNotOnZero('x')) {\n\t                yAxis.onZero = false;\n\t            }\n\t        });\n\t\n\t        // Resize again if containLabel is enabled\n\t        // FIXME It may cause getting wrong grid size in data processing stage\n\t        this.resize(this._model, api);\n\t    };\n\t\n\t    /**\n\t     * Resize the grid\n\t     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t     * @param {module:echarts/ExtensionAPI} api\n\t     */\n\t    gridProto.resize = function (gridModel, api) {\n\t\n\t        var gridRect = layout.getLayoutRect(\n\t            gridModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            });\n\t\n\t        this._rect = gridRect;\n\t\n\t        var axesList = this._axesList;\n\t\n\t        adjustAxes();\n\t\n\t        // Minus label size\n\t        if (gridModel.get('containLabel')) {\n\t            each(axesList, function (axis) {\n\t                if (!axis.model.get('axisLabel.inside')) {\n\t                    var labelUnionRect = getLabelUnionRect(axis);\n\t                    if (labelUnionRect) {\n\t                        var dim = axis.isHorizontal() ? 'height' : 'width';\n\t                        var margin = axis.model.get('axisLabel.margin');\n\t                        gridRect[dim] -= labelUnionRect[dim] + margin;\n\t                        if (axis.position === 'top') {\n\t                            gridRect.y += labelUnionRect.height + margin;\n\t                        }\n\t                        else if (axis.position === 'left')  {\n\t                            gridRect.x += labelUnionRect.width + margin;\n\t                        }\n\t                    }\n\t                }\n\t            });\n\t\n\t            adjustAxes();\n\t        }\n\t\n\t        function adjustAxes() {\n\t            each(axesList, function (axis) {\n\t                var isHorizontal = axis.isHorizontal();\n\t                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n\t                var idx = axis.inverse ? 1 : 0;\n\t                axis.setExtent(extent[idx], extent[1 - idx]);\n\t                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {string} axisType\n\t     * @param {ndumber} [axisIndex]\n\t     */\n\t    gridProto.getAxis = function (axisType, axisIndex) {\n\t        var axesMapOnDim = this._axesMap[axisType];\n\t        if (axesMapOnDim != null) {\n\t            if (axisIndex == null) {\n\t                // Find first axis\n\t                for (var name in axesMapOnDim) {\n\t                    if (axesMapOnDim.hasOwnProperty(name)) {\n\t                        return axesMapOnDim[name];\n\t                    }\n\t                }\n\t            }\n\t            return axesMapOnDim[axisIndex];\n\t        }\n\t    };\n\t\n\t    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n\t        if (xAxisIndex != null && yAxisIndex != null) {\n\t            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t            return this._coordsMap[key];\n\t        }\n\t        else {\n\t            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\t            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n\t                if (coordList[i].getAxis('x').index === xAxisIndex\n\t                    || coordList[i].getAxis('y').index === yAxisIndex\n\t                ) {\n\t                    return coordList[i];\n\t                }\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertToPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.dataToPoint(value)\n\t            : target.axis\n\t            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.convertFromPixel = function (ecModel, finder, value) {\n\t        var target = this._findConvertTarget(ecModel, finder);\n\t\n\t        return target.cartesian\n\t            ? target.cartesian.pointToData(value)\n\t            : target.axis\n\t            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n\t            : null;\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    gridProto._findConvertTarget = function (ecModel, finder) {\n\t        var seriesModel = finder.seriesModel;\n\t        var xAxisModel = finder.xAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n\t        var yAxisModel = finder.yAxisModel\n\t            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n\t        var gridModel = finder.gridModel;\n\t        var coordsList = this._coordsList;\n\t        var cartesian;\n\t        var axis;\n\t\n\t        if (seriesModel) {\n\t            cartesian = seriesModel.coordinateSystem;\n\t            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n\t        }\n\t        else if (xAxisModel && yAxisModel) {\n\t            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n\t        }\n\t        else if (xAxisModel) {\n\t            axis = this.getAxis('x', xAxisModel.componentIndex);\n\t        }\n\t        else if (yAxisModel) {\n\t            axis = this.getAxis('y', yAxisModel.componentIndex);\n\t        }\n\t        // Lowest priority.\n\t        else if (gridModel) {\n\t            var grid = gridModel.coordinateSystem;\n\t            if (grid === this) {\n\t                cartesian = this._coordsList[0];\n\t            }\n\t        }\n\t\n\t        return {cartesian: cartesian, axis: axis};\n\t    };\n\t\n\t    /**\n\t     * @implements\n\t     * see {module:echarts/CoodinateSystem}\n\t     */\n\t    gridProto.containPoint = function (point) {\n\t        var coord = this._coordsList[0];\n\t        if (coord) {\n\t            return coord.containPoint(point);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Initialize cartesian coordinate systems\n\t     * @private\n\t     */\n\t    gridProto._initCartesian = function (gridModel, ecModel, api) {\n\t        var axisPositionUsed = {\n\t            left: false,\n\t            right: false,\n\t            top: false,\n\t            bottom: false\n\t        };\n\t\n\t        var axesMap = {\n\t            x: {},\n\t            y: {}\n\t        };\n\t        var axesCount = {\n\t            x: 0,\n\t            y: 0\n\t        };\n\t\n\t        /// Create axis\n\t        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n\t        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\t\n\t        if (!axesCount.x || !axesCount.y) {\n\t            // Roll back when there no either x or y axis\n\t            this._axesMap = {};\n\t            this._axesList = [];\n\t            return;\n\t        }\n\t\n\t        this._axesMap = axesMap;\n\t\n\t        /// Create cartesian2d\n\t        each(axesMap.x, function (xAxis, xAxisIndex) {\n\t            each(axesMap.y, function (yAxis, yAxisIndex) {\n\t                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n\t                var cartesian = new Cartesian2D(key);\n\t\n\t                cartesian.grid = this;\n\t\n\t                this._coordsMap[key] = cartesian;\n\t                this._coordsList.push(cartesian);\n\t\n\t                cartesian.addAxis(xAxis);\n\t                cartesian.addAxis(yAxis);\n\t            }, this);\n\t        }, this);\n\t\n\t        function createAxisCreator(axisType) {\n\t            return function (axisModel, idx) {\n\t                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n\t                    return;\n\t                }\n\t\n\t                var axisPosition = axisModel.get('position');\n\t                if (axisType === 'x') {\n\t                    // Fix position\n\t                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n\t                        // Default bottom of X\n\t                        axisPosition = 'bottom';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n\t                        }\n\t                    }\n\t                }\n\t                else {\n\t                    // Fix position\n\t                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n\t                        // Default left of Y\n\t                        axisPosition = 'left';\n\t                        if (axisPositionUsed[axisPosition]) {\n\t                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n\t                        }\n\t                    }\n\t                }\n\t                axisPositionUsed[axisPosition] = true;\n\t\n\t                var axis = new Axis2D(\n\t                    axisType, axisHelper.createScaleByModel(axisModel),\n\t                    [0, 0],\n\t                    axisModel.get('type'),\n\t                    axisPosition\n\t                );\n\t\n\t                var isCategory = axis.type === 'category';\n\t                axis.onBand = isCategory && axisModel.get('boundaryGap');\n\t                axis.inverse = axisModel.get('inverse');\n\t\n\t                axis.onZero = axisModel.get('axisLine.onZero');\n\t\n\t                // Inject axis into axisModel\n\t                axisModel.axis = axis;\n\t\n\t                // Inject axisModel into axis\n\t                axis.model = axisModel;\n\t\n\t                // Inject grid info axis\n\t                axis.grid = this;\n\t\n\t                // Index of axis, can be used as key\n\t                axis.index = idx;\n\t\n\t                this._axesList.push(axis);\n\t\n\t                axesMap[axisType][idx] = axis;\n\t                axesCount[axisType]++;\n\t            };\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Update cartesian properties from series\n\t     * @param  {module:echarts/model/Option} option\n\t     * @private\n\t     */\n\t    gridProto._updateScale = function (ecModel, gridModel) {\n\t        // Reset scale\n\t        zrUtil.each(this._axesList, function (axis) {\n\t            axis.scale.setExtent(Infinity, -Infinity);\n\t        });\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (isCartesian2D(seriesModel)) {\n\t                var axesModels = findAxesModels(seriesModel, ecModel);\n\t                var xAxisModel = axesModels[0];\n\t                var yAxisModel = axesModels[1];\n\t\n\t                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n\t                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n\t                 ) {\n\t                    return;\n\t                }\n\t\n\t                var cartesian = this.getCartesian(\n\t                    xAxisModel.componentIndex, yAxisModel.componentIndex\n\t                );\n\t                var data = seriesModel.getData();\n\t                var xAxis = cartesian.getAxis('x');\n\t                var yAxis = cartesian.getAxis('y');\n\t\n\t                if (data.type === 'list') {\n\t                    unionExtent(data, xAxis, seriesModel);\n\t                    unionExtent(data, yAxis, seriesModel);\n\t                }\n\t            }\n\t        }, this);\n\t\n\t        function unionExtent(data, axis, seriesModel) {\n\t            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n\t                axis.scale.unionExtent(data.getDataExtent(\n\t                    dim, axis.scale.type !== 'ordinal'\n\t                ));\n\t            });\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function updateAxisTransfrom(axis, coordBase) {\n\t        var axisExtent = axis.getExtent();\n\t        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\t\n\t        // Fast transform\n\t        axis.toGlobalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord + coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t        axis.toLocalCoord = axis.dim === 'x'\n\t            ? function (coord) {\n\t                return coord - coordBase;\n\t            }\n\t            : function (coord) {\n\t                return axisExtentSum - coord + coordBase;\n\t            };\n\t    }\n\t\n\t    var axesTypes = ['xAxis', 'yAxis'];\n\t    /**\n\t     * @inner\n\t     */\n\t    function findAxesModels(seriesModel, ecModel) {\n\t        return zrUtil.map(axesTypes, function (axisType) {\n\t            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\t\n\t            if (__DEV__) {\n\t                if (!axisModel) {\n\t                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n\t                        seriesModel.get(axisType + 'Index'),\n\t                        seriesModel.get(axisType + 'Id'),\n\t                        0\n\t                    ) + '\" not found');\n\t                }\n\t            }\n\t            return axisModel;\n\t        });\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isCartesian2D(seriesModel) {\n\t        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n\t    }\n\t\n\t    Grid.create = function (ecModel, api) {\n\t        var grids = [];\n\t        ecModel.eachComponent('grid', function (gridModel, idx) {\n\t            var grid = new Grid(gridModel, ecModel, api);\n\t            grid.name = 'grid_' + idx;\n\t            grid.resize(gridModel, api);\n\t\n\t            gridModel.coordinateSystem = grid;\n\t\n\t            grids.push(grid);\n\t        });\n\t\n\t        // Inject the coordinateSystems into seriesModel\n\t        ecModel.eachSeries(function (seriesModel) {\n\t            if (!isCartesian2D(seriesModel)) {\n\t                return;\n\t            }\n\t\n\t            var axesModels = findAxesModels(seriesModel, ecModel);\n\t            var xAxisModel = axesModels[0];\n\t            var yAxisModel = axesModels[1];\n\t\n\t            var gridModel = xAxisModel.findGridModel();\n\t\n\t            if (__DEV__) {\n\t                if (!gridModel) {\n\t                    throw new Error(\n\t                        'Grid \"' + zrUtil.retrieve(\n\t                            xAxisModel.get('gridIndex'),\n\t                            xAxisModel.get('gridId'),\n\t                            0\n\t                        ) + '\" not found'\n\t                    );\n\t                }\n\t                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n\t                    throw new Error('xAxis and yAxis must use the same grid');\n\t                }\n\t            }\n\t\n\t            var grid = gridModel.coordinateSystem;\n\t\n\t            seriesModel.coordinateSystem = grid.getCartesian(\n\t                xAxisModel.componentIndex, yAxisModel.componentIndex\n\t            );\n\t        });\n\t\n\t        return grids;\n\t    };\n\t\n\t    // For deciding which dimensions to use when creating list data\n\t    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\t\n\t    __webpack_require__(147).register('cartesian2d', Grid);\n\t\n\t    module.exports = Grid;\n\n\n/***/ },\n\n/***/ 541:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var OrdinalScale = __webpack_require__(542);\n\t    var IntervalScale = __webpack_require__(544);\n\t    __webpack_require__(545);\n\t    __webpack_require__(546);\n\t    var Scale = __webpack_require__(543);\n\t\n\t    var numberUtil = __webpack_require__(128);\n\t    var zrUtil = __webpack_require__(125);\n\t    var textContain = __webpack_require__(129);\n\t    var axisHelper = {};\n\t\n\t    /**\n\t     * Get axis scale extent before niced.\n\t     */\n\t    axisHelper.getScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var originalExtent = scale.getExtent();\n\t        var span = originalExtent[1] - originalExtent[0];\n\t        if (scale.type === 'ordinal') {\n\t            // If series has no data, scale extent may be wrong\n\t            if (!isFinite(span)) {\n\t                return [0, 0];\n\t            }\n\t            else {\n\t                return originalExtent;\n\t            }\n\t        }\n\t        var min = model.getMin ? model.getMin() : model.get('min');\n\t        var max = model.getMax ? model.getMax() : model.get('max');\n\t        var crossZero = model.getNeedCrossZero\n\t            ? model.getNeedCrossZero() : !model.get('scale');\n\t        var boundaryGap = model.get('boundaryGap');\n\t        if (!zrUtil.isArray(boundaryGap)) {\n\t            boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n\t        }\n\t        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n\t        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n\t        var fixMin = true;\n\t        var fixMax = true;\n\t        // Add boundary gap\n\t        if (min == null) {\n\t            min = originalExtent[0] - boundaryGap[0] * span;\n\t            fixMin = false;\n\t        }\n\t        if (max == null) {\n\t            max = originalExtent[1] + boundaryGap[1] * span;\n\t            fixMax = false;\n\t        }\n\t        if (min === 'dataMin') {\n\t            min = originalExtent[0];\n\t        }\n\t        if (max === 'dataMax') {\n\t            max = originalExtent[1];\n\t        }\n\t        // Evaluate if axis needs cross zero\n\t        if (crossZero) {\n\t            // Axis is over zero and min is not set\n\t            if (min > 0 && max > 0 && !fixMin) {\n\t                min = 0;\n\t            }\n\t            // Axis is under zero and max is not set\n\t            if (min < 0 && max < 0 && !fixMax) {\n\t                max = 0;\n\t            }\n\t        }\n\t        return [min, max];\n\t    };\n\t\n\t    axisHelper.niceScaleExtent = function (axis, model) {\n\t        var scale = axis.scale;\n\t        var extent = axisHelper.getScaleExtent(axis, model);\n\t        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n\t        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n\t        var splitNumber = model.get('splitNumber');\n\t\n\t        if (scale.type === 'log') {\n\t            scale.base = model.get('logBase');\n\t        }\n\t\n\t        scale.setExtent(extent[0], extent[1]);\n\t        scale.niceExtent(splitNumber, fixMin, fixMax);\n\t\n\t        // Use minInterval to constraint the calculated interval.\n\t        // If calculated interval is less than minInterval. increase the interval quantity until\n\t        // it is larger than minInterval.\n\t        // For example:\n\t        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n\t        //  an integer axis.\n\t        var minInterval = model.get('minInterval');\n\t        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n\t            var interval = scale.getInterval();\n\t            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n\t            // while (interval < minInterval) {\n\t            //     var quantity = numberUtil.quantity(interval);\n\t            //     interval = quantity * 10;\n\t            //     scaleQuantity *= 10;\n\t            // }\n\t            extent = scale.getExtent();\n\t            var origin = (extent[1] + extent[0]) / 2;\n\t            scale.setExtent(\n\t                intervalScale * (extent[0] - origin) + origin,\n\t                intervalScale * (extent[1] - origin) + origin\n\t            );\n\t            scale.niceExtent(splitNumber);\n\t        }\n\t\n\t        // If some one specified the min, max. And the default calculated interval\n\t        // is not good enough. He can specify the interval. It is often appeared\n\t        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n\t        // to be 60.\n\t        // FIXME\n\t        var interval = model.get('interval');\n\t        if (interval != null) {\n\t            scale.setInterval && scale.setInterval(interval);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @param {module:echarts/model/Model} model\n\t     * @param {string} [axisType] Default retrieve from model.type\n\t     * @return {module:echarts/scale/*}\n\t     */\n\t    axisHelper.createScaleByModel = function(model, axisType) {\n\t        axisType = axisType || model.get('type');\n\t        if (axisType) {\n\t            switch (axisType) {\n\t                // Buildin scale\n\t                case 'category':\n\t                    return new OrdinalScale(\n\t                        model.getCategories(), [Infinity, -Infinity]\n\t                    );\n\t                case 'value':\n\t                    return new IntervalScale();\n\t                // Extended scale, like time and log\n\t                default:\n\t                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n\t            }\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Check if the axis corss 0\n\t     */\n\t    axisHelper.ifAxisCrossZero = function (axis) {\n\t        var dataExtent = axis.scale.getExtent();\n\t        var min = dataExtent[0];\n\t        var max = dataExtent[1];\n\t        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n\t    };\n\t\n\t    /**\n\t     * @param {Array.<number>} tickCoords In axis self coordinate.\n\t     * @param {Array.<string>} labels\n\t     * @param {string} font\n\t     * @param {boolean} isAxisHorizontal\n\t     * @return {number}\n\t     */\n\t    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n\t        // FIXME\n\t        // 不同角的axis和label，不只是horizontal和vertical.\n\t\n\t        var textSpaceTakenRect;\n\t        var autoLabelInterval = 0;\n\t        var accumulatedLabelInterval = 0;\n\t\n\t        var step = 1;\n\t        if (labels.length > 40) {\n\t            // Simple optimization for large amount of labels\n\t            step = Math.floor(labels.length / 40);\n\t        }\n\t\n\t        for (var i = 0; i < tickCoords.length; i += step) {\n\t            var tickCoord = tickCoords[i];\n\t            var rect = textContain.getBoundingRect(\n\t                labels[i], font, 'center', 'top'\n\t            );\n\t            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n\t            // FIXME Magic number 1.5\n\t            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n\t            if (!textSpaceTakenRect) {\n\t                textSpaceTakenRect = rect.clone();\n\t            }\n\t            // There is no space for current label;\n\t            else if (textSpaceTakenRect.intersect(rect)) {\n\t                accumulatedLabelInterval++;\n\t                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n\t            }\n\t            else {\n\t                textSpaceTakenRect.union(rect);\n\t                // Reset\n\t                accumulatedLabelInterval = 0;\n\t            }\n\t        }\n\t        if (autoLabelInterval === 0 && step > 1) {\n\t            return step;\n\t        }\n\t        return (autoLabelInterval + 1) * step - 1;\n\t    };\n\t\n\t    /**\n\t     * @param {Object} axis\n\t     * @param {Function} labelFormatter\n\t     * @return {Array.<string>}\n\t     */\n\t    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n\t        var scale = axis.scale;\n\t        var labels = scale.getTicksLabels();\n\t        var ticks = scale.getTicks();\n\t        if (typeof labelFormatter === 'string') {\n\t            labelFormatter = (function (tpl) {\n\t                return function (val) {\n\t                    return tpl.replace('{value}', val);\n\t                };\n\t            })(labelFormatter);\n\t            return zrUtil.map(labels, labelFormatter);\n\t        }\n\t        else if (typeof labelFormatter === 'function') {\n\t            return zrUtil.map(ticks, function (tick, idx) {\n\t                return labelFormatter(\n\t                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n\t                    idx\n\t                );\n\t            }, this);\n\t        }\n\t        else {\n\t            return labels;\n\t        }\n\t    };\n\t\n\t    module.exports = axisHelper;\n\n\n/***/ },\n\n/***/ 542:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Linear continuous scale\n\t * @module echarts/coord/scale/Ordinal\n\t *\n\t * http://en.wikipedia.org/wiki/Level_of_measurement\n\t */\n\t\n\t// FIXME only one data\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var Scale = __webpack_require__(543);\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    var OrdinalScale = Scale.extend({\n\t\n\t        type: 'ordinal',\n\t\n\t        init: function (data, extent) {\n\t            this._data = data;\n\t            this._extent = extent || [0, data.length - 1];\n\t        },\n\t\n\t        parse: function (val) {\n\t            return typeof val === 'string'\n\t                ? zrUtil.indexOf(this._data, val)\n\t                // val might be float.\n\t                : Math.round(val);\n\t        },\n\t\n\t        contain: function (rank) {\n\t            rank = this.parse(rank);\n\t            return scaleProto.contain.call(this, rank)\n\t                && this._data[rank] != null;\n\t        },\n\t\n\t        /**\n\t         * Normalize given rank or name to linear [0, 1]\n\t         * @param {number|string} [val]\n\t         * @return {number}\n\t         */\n\t        normalize: function (val) {\n\t            return scaleProto.normalize.call(this, this.parse(val));\n\t        },\n\t\n\t        scale: function (val) {\n\t            return Math.round(scaleProto.scale.call(this, val));\n\t        },\n\t\n\t        /**\n\t         * @return {Array}\n\t         */\n\t        getTicks: function () {\n\t            var ticks = [];\n\t            var extent = this._extent;\n\t            var rank = extent[0];\n\t\n\t            while (rank <= extent[1]) {\n\t                ticks.push(rank);\n\t                rank++;\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * Get item on rank n\n\t         * @param {number} n\n\t         * @return {string}\n\t         */\n\t        getLabel: function (n) {\n\t            return this._data[n];\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        count: function () {\n\t            return this._extent[1] - this._extent[0] + 1;\n\t        },\n\t\n\t        niceTicks: zrUtil.noop,\n\t        niceExtent: zrUtil.noop\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    OrdinalScale.create = function () {\n\t        return new OrdinalScale();\n\t    };\n\t\n\t    module.exports = OrdinalScale;\n\n\n/***/ },\n\n/***/ 543:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * // Scale class management\n\t * @module echarts/scale/Scale\n\t */\n\t\n\t\n\t    var clazzUtil = __webpack_require__(134);\n\t\n\t    function Scale() {\n\t        /**\n\t         * Extent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._extent = [Infinity, -Infinity];\n\t\n\t        /**\n\t         * Step is calculated in adjustExtent\n\t         * @type {Array.<number>}\n\t         * @protected\n\t         */\n\t        this._interval = 0;\n\t\n\t        this.init && this.init.apply(this, arguments);\n\t    }\n\t\n\t    var scaleProto = Scale.prototype;\n\t\n\t    /**\n\t     * Parse input val to valid inner number.\n\t     * @param {*} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.parse = function (val) {\n\t        // Notice: This would be a trap here, If the implementation\n\t        // of this method depends on extent, and this method is used\n\t        // before extent set (like in dataZoom), it would be wrong.\n\t        // Nevertheless, parse does not depend on extent generally.\n\t        return val;\n\t    };\n\t\n\t    scaleProto.contain = function (val) {\n\t        var extent = this._extent;\n\t        return val >= extent[0] && val <= extent[1];\n\t    };\n\t\n\t    /**\n\t     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.normalize = function (val) {\n\t        var extent = this._extent;\n\t        if (extent[1] === extent[0]) {\n\t            return 0.5;\n\t        }\n\t        return (val - extent[0]) / (extent[1] - extent[0]);\n\t    };\n\t\n\t    /**\n\t     * Scale normalized value\n\t     * @param {number} val\n\t     * @return {number}\n\t     */\n\t    scaleProto.scale = function (val) {\n\t        var extent = this._extent;\n\t        return val * (extent[1] - extent[0]) + extent[0];\n\t    };\n\t\n\t    /**\n\t     * Set extent from data\n\t     * @param {Array.<number>} other\n\t     */\n\t    scaleProto.unionExtent = function (other) {\n\t        var extent = this._extent;\n\t        other[0] < extent[0] && (extent[0] = other[0]);\n\t        other[1] > extent[1] && (extent[1] = other[1]);\n\t        // not setExtent because in log axis it may transformed to power\n\t        // this.setExtent(extent[0], extent[1]);\n\t    };\n\t\n\t    /**\n\t     * Get extent\n\t     * @return {Array.<number>}\n\t     */\n\t    scaleProto.getExtent = function () {\n\t        return this._extent.slice();\n\t    };\n\t\n\t    /**\n\t     * Set extent\n\t     * @param {number} start\n\t     * @param {number} end\n\t     */\n\t    scaleProto.setExtent = function (start, end) {\n\t        var thisExtent = this._extent;\n\t        if (!isNaN(start)) {\n\t            thisExtent[0] = start;\n\t        }\n\t        if (!isNaN(end)) {\n\t            thisExtent[1] = end;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @return {Array.<string>}\n\t     */\n\t    scaleProto.getTicksLabels = function () {\n\t        var labels = [];\n\t        var ticks = this.getTicks();\n\t        for (var i = 0; i < ticks.length; i++) {\n\t            labels.push(this.getLabel(ticks[i]));\n\t        }\n\t        return labels;\n\t    };\n\t\n\t    clazzUtil.enableClassExtend(Scale);\n\t    clazzUtil.enableClassManagement(Scale, {\n\t        registerWhenExtend: true\n\t    });\n\t\n\t    module.exports = Scale;\n\n\n/***/ },\n\n/***/ 544:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/scale/Interval\n\t */\n\t\n\t\n\t\n\t    var numberUtil = __webpack_require__(128);\n\t    var formatUtil = __webpack_require__(127);\n\t    var Scale = __webpack_require__(543);\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t    /**\n\t     * @alias module:echarts/coord/scale/Interval\n\t     * @constructor\n\t     */\n\t    var IntervalScale = Scale.extend({\n\t\n\t        type: 'interval',\n\t\n\t        _interval: 0,\n\t\n\t        setExtent: function (start, end) {\n\t            var thisExtent = this._extent;\n\t            //start,end may be a Number like '25',so...\n\t            if (!isNaN(start)) {\n\t                thisExtent[0] = parseFloat(start);\n\t            }\n\t            if (!isNaN(end)) {\n\t                thisExtent[1] = parseFloat(end);\n\t            }\n\t        },\n\t\n\t        unionExtent: function (other) {\n\t            var extent = this._extent;\n\t            other[0] < extent[0] && (extent[0] = other[0]);\n\t            other[1] > extent[1] && (extent[1] = other[1]);\n\t\n\t            // unionExtent may called by it's sub classes\n\t            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n\t        },\n\t        /**\n\t         * Get interval\n\t         */\n\t        getInterval: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            return this._interval;\n\t        },\n\t\n\t        /**\n\t         * Set interval\n\t         */\n\t        setInterval: function (interval) {\n\t            this._interval = interval;\n\t            // Dropped auto calculated niceExtent and use user setted extent\n\t            // We assume user wan't to set both interval, min, max to get a better result\n\t            this._niceExtent = this._extent.slice();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            if (!this._interval) {\n\t                this.niceTicks();\n\t            }\n\t            var interval = this._interval;\n\t            var extent = this._extent;\n\t            var ticks = [];\n\t\n\t            // Consider this case: using dataZoom toolbox, zoom and zoom.\n\t            var safeLimit = 10000;\n\t\n\t            if (interval) {\n\t                var niceExtent = this._niceExtent;\n\t                var precision = getPrecisionSafe(interval) + 2;\n\t\n\t                if (extent[0] < niceExtent[0]) {\n\t                    ticks.push(extent[0]);\n\t                }\n\t                var tick = niceExtent[0];\n\t\n\t                while (tick <= niceExtent[1]) {\n\t                    ticks.push(tick);\n\t                    // Avoid rounding error\n\t                    tick = roundingErrorFix(tick + interval, precision);\n\t                    if (ticks.length > safeLimit) {\n\t                        return [];\n\t                    }\n\t                }\n\t                // Consider this case: the last item of ticks is smaller\n\t                // than niceExtent[1] and niceExtent[1] === extent[1].\n\t                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n\t                    ticks.push(extent[1]);\n\t                }\n\t            }\n\t\n\t            return ticks;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<string>}\n\t         */\n\t        getTicksLabels: function () {\n\t            var labels = [];\n\t            var ticks = this.getTicks();\n\t            for (var i = 0; i < ticks.length; i++) {\n\t                labels.push(this.getLabel(ticks[i]));\n\t            }\n\t            return labels;\n\t        },\n\t\n\t        /**\n\t         * @param {number} n\n\t         * @return {number}\n\t         */\n\t        getLabel: function (data) {\n\t            return formatUtil.addCommas(data);\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         *\n\t         * @param {number} [splitNumber = 5] Desired number of ticks\n\t         */\n\t        niceTicks: function (splitNumber) {\n\t            splitNumber = splitNumber || 5;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (!isFinite(span)) {\n\t                return;\n\t            }\n\t            // User may set axis min 0 and data are all negative\n\t            // FIXME If it needs to reverse ?\n\t            if (span < 0) {\n\t                span = -span;\n\t                extent.reverse();\n\t            }\n\t\n\t            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t            // var niceSpan = numberUtil.nice(span, false);\n\t            var step = roundingErrorFix(\n\t                numberUtil.nice(span / splitNumber, true),\n\t                Math.max(\n\t                    getPrecisionSafe(extent[0]),\n\t                    getPrecisionSafe(extent[1])\n\t                // extent may be [0, 1], and step should have 1 more digits.\n\t                // To make it safe we add 2 more digits\n\t                ) + 2\n\t            );\n\t\n\t            var precision = getPrecisionSafe(step) + 2;\n\t            // Niced extent inside original extent\n\t            var niceExtent = [\n\t                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n\t                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n\t            ];\n\t\n\t            this._interval = step;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [splitNumber = 5] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                if (extent[0] !== 0) {\n\t                    // Expand extent\n\t                    var expandSize = extent[0];\n\t                    // In the fowllowing case\n\t                    //      Axis has been fixed max 100\n\t                    //      Plus data are all 100 and axis extent are [100, 100].\n\t                    // Extend to the both side will cause expanded max is larger than fixed max.\n\t                    // So only expand to the smaller side.\n\t                    if (!fixMax) {\n\t                        extent[1] += expandSize / 2;\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                    else {\n\t                        extent[0] -= expandSize / 2;\n\t                    }\n\t                }\n\t                else {\n\t                    extent[1] = 1;\n\t                }\n\t            }\n\t            var span = extent[1] - extent[0];\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (!isFinite(span)) {\n\t                extent[0] = 0;\n\t                extent[1] = 1;\n\t            }\n\t\n\t            this.niceTicks(splitNumber);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        }\n\t    });\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    IntervalScale.create = function () {\n\t        return new IntervalScale();\n\t    };\n\t\n\t    module.exports = IntervalScale;\n\t\n\n\n/***/ },\n\n/***/ 545:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Interval scale\n\t * @module echarts/coord/scale/Time\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var numberUtil = __webpack_require__(128);\n\t    var formatUtil = __webpack_require__(127);\n\t\n\t    var IntervalScale = __webpack_require__(544);\n\t\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var mathCeil = Math.ceil;\n\t    var mathFloor = Math.floor;\n\t    var ONE_SECOND = 1000;\n\t    var ONE_MINUTE = ONE_SECOND * 60;\n\t    var ONE_HOUR = ONE_MINUTE * 60;\n\t    var ONE_DAY = ONE_HOUR * 24;\n\t\n\t    // FIXME 公用？\n\t    var bisect = function (a, x, lo, hi) {\n\t        while (lo < hi) {\n\t            var mid = lo + hi >>> 1;\n\t            if (a[mid][2] < x) {\n\t                lo = mid + 1;\n\t            }\n\t            else {\n\t                hi  = mid;\n\t            }\n\t        }\n\t        return lo;\n\t    };\n\t\n\t    /**\n\t     * @alias module:echarts/coord/scale/Time\n\t     * @constructor\n\t     */\n\t    var TimeScale = IntervalScale.extend({\n\t        type: 'time',\n\t\n\t        // Overwrite\n\t        getLabel: function (val) {\n\t            var stepLvl = this._stepLvl;\n\t\n\t            var date = new Date(val);\n\t\n\t            return formatUtil.formatTime(stepLvl[0], date);\n\t        },\n\t\n\t        // Overwrite\n\t        niceExtent: function (approxTickNum, fixMin, fixMax) {\n\t            var extent = this._extent;\n\t            // If extent start and end are same, expand them\n\t            if (extent[0] === extent[1]) {\n\t                // Expand extent\n\t                extent[0] -= ONE_DAY;\n\t                extent[1] += ONE_DAY;\n\t            }\n\t            // If there are no data and extent are [Infinity, -Infinity]\n\t            if (extent[1] === -Infinity && extent[0] === Infinity) {\n\t                var d = new Date();\n\t                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n\t                extent[0] = extent[1] - ONE_DAY;\n\t            }\n\t\n\t            this.niceTicks(approxTickNum);\n\t\n\t            // var extent = this._extent;\n\t            var interval = this._interval;\n\t\n\t            if (!fixMin) {\n\t                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n\t            }\n\t            if (!fixMax) {\n\t                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n\t            }\n\t        },\n\t\n\t        // Overwrite\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            var approxInterval = span / approxTickNum;\n\t            var scaleLevelsLen = scaleLevels.length;\n\t            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\t\n\t            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n\t            var interval = level[2];\n\t            // Same with interval scale if span is much larger than 1 year\n\t            if (level[0] === 'year') {\n\t                var yearSpan = span / interval;\n\t\n\t                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n\t                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n\t                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\t\n\t                interval *= yearStep;\n\t            }\n\t\n\t            var niceExtent = [\n\t                mathCeil(extent[0] / interval) * interval,\n\t                mathFloor(extent[1] / interval) * interval\n\t            ];\n\t\n\t            this._stepLvl = level;\n\t            // Interval will be used in getTicks\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        parse: function (val) {\n\t            // val might be float.\n\t            return +numberUtil.parseDate(val);\n\t        }\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        TimeScale.prototype[methodName] = function (val) {\n\t            return intervalScaleProto[methodName].call(this, this.parse(val));\n\t        };\n\t    });\n\t\n\t    // Steps from d3\n\t    var scaleLevels = [\n\t        // Format       step    interval\n\t        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n\t        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n\t        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n\t        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n\t        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n\t        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n\t        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n\t        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n\t        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n\t        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n\t        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n\t        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n\t        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n\t        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n\t        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n\t        ['week',        7,      ONE_DAY * 7],        // 7d\n\t        ['month',       1,      ONE_DAY * 31],       // 1M\n\t        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n\t        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n\t        ['year',        1,      ONE_DAY * 380]       // 1Y\n\t    ];\n\t\n\t    /**\n\t     * @return {module:echarts/scale/Time}\n\t     */\n\t    TimeScale.create = function () {\n\t        return new TimeScale();\n\t    };\n\t\n\t    module.exports = TimeScale;\n\n\n/***/ },\n\n/***/ 546:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Log scale\n\t * @module echarts/scale/Log\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var Scale = __webpack_require__(543);\n\t    var numberUtil = __webpack_require__(128);\n\t\n\t    // Use some method of IntervalScale\n\t    var IntervalScale = __webpack_require__(544);\n\t\n\t    var scaleProto = Scale.prototype;\n\t    var intervalScaleProto = IntervalScale.prototype;\n\t\n\t    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n\t    var roundingErrorFix = numberUtil.round;\n\t\n\t    var mathFloor = Math.floor;\n\t    var mathCeil = Math.ceil;\n\t    var mathPow = Math.pow;\n\t\n\t    var mathLog = Math.log;\n\t\n\t    var LogScale = Scale.extend({\n\t\n\t        type: 'log',\n\t\n\t        base: 10,\n\t\n\t        $constructor: function () {\n\t            Scale.apply(this, arguments);\n\t            this._originalScale = new IntervalScale();\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicks: function () {\n\t            var originalScale = this._originalScale;\n\t            var extent = this._extent;\n\t            var originalExtent = originalScale.getExtent();\n\t\n\t            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n\t                var powVal = numberUtil.round(mathPow(this.base, val));\n\t\n\t                // Fix #4158\n\t                powVal = (val === extent[0] && originalScale.__fixMin)\n\t                    ? fixRoundingError(powVal, originalExtent[0])\n\t                    : powVal;\n\t                powVal = (val === extent[1] && originalScale.__fixMax)\n\t                    ? fixRoundingError(powVal, originalExtent[1])\n\t                    : powVal;\n\t\n\t                return powVal;\n\t            }, this);\n\t        },\n\t\n\t        /**\n\t         * @param {number} val\n\t         * @return {string}\n\t         */\n\t        getLabel: intervalScaleProto.getLabel,\n\t\n\t        /**\n\t         * @param  {number} val\n\t         * @return {number}\n\t         */\n\t        scale: function (val) {\n\t            val = scaleProto.scale.call(this, val);\n\t            return mathPow(this.base, val);\n\t        },\n\t\n\t        /**\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var base = this.base;\n\t            start = mathLog(start) / mathLog(base);\n\t            end = mathLog(end) / mathLog(base);\n\t            intervalScaleProto.setExtent.call(this, start, end);\n\t        },\n\t\n\t        /**\n\t         * @return {number} end\n\t         */\n\t        getExtent: function () {\n\t            var base = this.base;\n\t            var extent = scaleProto.getExtent.call(this);\n\t            extent[0] = mathPow(base, extent[0]);\n\t            extent[1] = mathPow(base, extent[1]);\n\t\n\t            // Fix #4158\n\t            var originalScale = this._originalScale;\n\t            var originalExtent = originalScale.getExtent();\n\t            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n\t            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\t\n\t            return extent;\n\t        },\n\t\n\t        /**\n\t         * @param  {Array.<number>} extent\n\t         */\n\t        unionExtent: function (extent) {\n\t            this._originalScale.unionExtent(extent);\n\t\n\t            var base = this.base;\n\t            extent[0] = mathLog(extent[0]) / mathLog(base);\n\t            extent[1] = mathLog(extent[1]) / mathLog(base);\n\t            scaleProto.unionExtent.call(this, extent);\n\t        },\n\t\n\t        /**\n\t         * Update interval and extent of intervals for nice ticks\n\t         * @param  {number} [approxTickNum = 10] Given approx tick number\n\t         */\n\t        niceTicks: function (approxTickNum) {\n\t            approxTickNum = approxTickNum || 10;\n\t            var extent = this._extent;\n\t            var span = extent[1] - extent[0];\n\t            if (span === Infinity || span <= 0) {\n\t                return;\n\t            }\n\t\n\t            var interval = numberUtil.quantity(span);\n\t            var err = approxTickNum / span * interval;\n\t\n\t            // Filter ticks to get closer to the desired count.\n\t            if (err <= 0.5) {\n\t                interval *= 10;\n\t            }\n\t\n\t            // Interval should be integer\n\t            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n\t                interval *= 10;\n\t            }\n\t\n\t            var niceExtent = [\n\t                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n\t                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n\t            ];\n\t\n\t            this._interval = interval;\n\t            this._niceExtent = niceExtent;\n\t        },\n\t\n\t        /**\n\t         * Nice extent.\n\t         * @param {number} [approxTickNum = 10] Given approx tick number\n\t         * @param {boolean} [fixMin=false]\n\t         * @param {boolean} [fixMax=false]\n\t         */\n\t        niceExtent: function (splitNumber, fixMin, fixMax) {\n\t            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\t\n\t            var originalScale = this._originalScale;\n\t            originalScale.__fixMin = fixMin;\n\t            originalScale.__fixMax = fixMax;\n\t        }\n\t\n\t    });\n\t\n\t    zrUtil.each(['contain', 'normalize'], function (methodName) {\n\t        LogScale.prototype[methodName] = function (val) {\n\t            val = mathLog(val) / mathLog(this.base);\n\t            return scaleProto[methodName].call(this, val);\n\t        };\n\t    });\n\t\n\t    LogScale.create = function () {\n\t        return new LogScale();\n\t    };\n\t\n\t    function fixRoundingError(val, originalVal) {\n\t        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n\t    }\n\t\n\t    module.exports = LogScale;\n\n\n/***/ },\n\n/***/ 547:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var Cartesian = __webpack_require__(548);\n\t\n\t    function Cartesian2D(name) {\n\t\n\t        Cartesian.call(this, name);\n\t    }\n\t\n\t    Cartesian2D.prototype = {\n\t\n\t        constructor: Cartesian2D,\n\t\n\t        type: 'cartesian2d',\n\t\n\t        /**\n\t         * @type {Array.<string>}\n\t         * @readOnly\n\t         */\n\t        dimensions: ['x', 'y'],\n\t\n\t        /**\n\t         * Base axis will be used on stacking.\n\t         *\n\t         * @return {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        getBaseAxis: function () {\n\t            return this.getAxesByScale('ordinal')[0]\n\t                || this.getAxesByScale('time')[0]\n\t                || this.getAxis('x');\n\t        },\n\t\n\t        /**\n\t         * If contain point\n\t         * @param {Array.<number>} point\n\t         * @return {boolean}\n\t         */\n\t        containPoint: function (point) {\n\t            var axisX = this.getAxis('x');\n\t            var axisY = this.getAxis('y');\n\t            return axisX.contain(axisX.toLocalCoord(point[0]))\n\t                && axisY.contain(axisY.toLocalCoord(point[1]));\n\t        },\n\t\n\t        /**\n\t         * If contain data\n\t         * @param {Array.<number>} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.getAxis('x').containData(data[0])\n\t                && this.getAxis('y').containData(data[1]);\n\t        },\n\t\n\t        /**\n\t         * Convert series data to an array of points\n\t         * @param {module:echarts/data/List} data\n\t         * @param {boolean} stack\n\t         * @return {Array}\n\t         *  Return array of points. For example:\n\t         *  `[[10, 10], [20, 20], [30, 30]]`\n\t         */\n\t        dataToPoints: function (data, stack) {\n\t            return data.mapArray(['x', 'y'], function (x, y) {\n\t                return this.dataToPoint([x, y]);\n\t            }, stack, this);\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} data\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        dataToPoint: function (data, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n\t                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * @param {Array.<number>} point\n\t         * @param {boolean} [clamp=false]\n\t         * @return {Array.<number>}\n\t         */\n\t        pointToData: function (point, clamp) {\n\t            var xAxis = this.getAxis('x');\n\t            var yAxis = this.getAxis('y');\n\t            return [\n\t                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n\t                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n\t            ];\n\t        },\n\t\n\t        /**\n\t         * Get other axis\n\t         * @param {module:echarts/coord/cartesian/Axis2D} axis\n\t         */\n\t        getOtherAxis: function (axis) {\n\t            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n\t        }\n\t    };\n\t\n\t    zrUtil.inherits(Cartesian2D, Cartesian);\n\t\n\t    module.exports = Cartesian2D;\n\n\n/***/ },\n\n/***/ 548:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Cartesian coordinate system\n\t * @module  echarts/coord/Cartesian\n\t *\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    function dimAxisMapper(dim) {\n\t        return this._axes[dim];\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/coord/Cartesian\n\t     * @constructor\n\t     */\n\t    var Cartesian = function (name) {\n\t        this._axes = {};\n\t\n\t        this._dimList = [];\n\t\n\t        /**\n\t         * @type {string}\n\t         */\n\t        this.name = name || '';\n\t    };\n\t\n\t    Cartesian.prototype = {\n\t\n\t        constructor: Cartesian,\n\t\n\t        type: 'cartesian',\n\t\n\t        /**\n\t         * Get axis\n\t         * @param  {number|string} dim\n\t         * @return {module:echarts/coord/Cartesian~Axis}\n\t         */\n\t        getAxis: function (dim) {\n\t            return this._axes[dim];\n\t        },\n\t\n\t        /**\n\t         * Get axes list\n\t         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n\t         */\n\t        getAxes: function () {\n\t            return zrUtil.map(this._dimList, dimAxisMapper, this);\n\t        },\n\t\n\t        /**\n\t         * Get axes list by given scale type\n\t         */\n\t        getAxesByScale: function (scaleType) {\n\t            scaleType = scaleType.toLowerCase();\n\t            return zrUtil.filter(\n\t                this.getAxes(),\n\t                function (axis) {\n\t                    return axis.scale.type === scaleType;\n\t                }\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Add axis\n\t         * @param {module:echarts/coord/Cartesian.Axis}\n\t         */\n\t        addAxis: function (axis) {\n\t            var dim = axis.dim;\n\t\n\t            this._axes[dim] = axis;\n\t\n\t            this._dimList.push(dim);\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord in nd space\n\t         * @param {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        dataToCoord: function (val) {\n\t            return this._dataCoordConvert(val, 'dataToCoord');\n\t        },\n\t\n\t        /**\n\t         * Convert coord in nd space to data\n\t         * @param  {Array.<number>|Object.<string, number>} val\n\t         * @return {Array.<number>|Object.<string, number>}\n\t         */\n\t        coordToData: function (val) {\n\t            return this._dataCoordConvert(val, 'coordToData');\n\t        },\n\t\n\t        _dataCoordConvert: function (input, method) {\n\t            var dimList = this._dimList;\n\t\n\t            var output = input instanceof Array ? [] : {};\n\t\n\t            for (var i = 0; i < dimList.length; i++) {\n\t                var dim = dimList[i];\n\t                var axis = this._axes[dim];\n\t\n\t                output[dim] = axis[method](input[dim]);\n\t            }\n\t\n\t            return output;\n\t        }\n\t    };\n\t\n\t    module.exports = Cartesian;\n\n\n/***/ },\n\n/***/ 549:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var Axis = __webpack_require__(550);\n\t    var axisLabelInterval = __webpack_require__(551);\n\t\n\t    /**\n\t     * Extend axis 2d\n\t     * @constructor module:echarts/coord/cartesian/Axis2D\n\t     * @extends {module:echarts/coord/cartesian/Axis}\n\t     * @param {string} dim\n\t     * @param {*} scale\n\t     * @param {Array.<number>} coordExtent\n\t     * @param {string} axisType\n\t     * @param {string} position\n\t     */\n\t    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n\t        Axis.call(this, dim, scale, coordExtent);\n\t        /**\n\t         * Axis type\n\t         *  - 'category'\n\t         *  - 'value'\n\t         *  - 'time'\n\t         *  - 'log'\n\t         * @type {string}\n\t         */\n\t        this.type = axisType || 'value';\n\t\n\t        /**\n\t         * Axis position\n\t         *  - 'top'\n\t         *  - 'bottom'\n\t         *  - 'left'\n\t         *  - 'right'\n\t         */\n\t        this.position = position || 'bottom';\n\t    };\n\t\n\t    Axis2D.prototype = {\n\t\n\t        constructor: Axis2D,\n\t\n\t        /**\n\t         * Index of axis, can be used as key\n\t         */\n\t        index: 0,\n\t        /**\n\t         * If axis is on the zero position of the other axis\n\t         * @type {boolean}\n\t         */\n\t        onZero: false,\n\t\n\t        /**\n\t         * Axis model\n\t         * @param {module:echarts/coord/cartesian/AxisModel}\n\t         */\n\t        model: null,\n\t\n\t        isHorizontal: function () {\n\t            var position = this.position;\n\t            return position === 'top' || position === 'bottom';\n\t        },\n\t\n\t        getGlobalExtent: function () {\n\t            var ret = this.getExtent();\n\t            ret[0] = this.toGlobalCoord(ret[0]);\n\t            ret[1] = this.toGlobalCoord(ret[1]);\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * @return {number}\n\t         */\n\t        getLabelInterval: function () {\n\t            var labelInterval = this._labelInterval;\n\t            if (!labelInterval) {\n\t                labelInterval = this._labelInterval = axisLabelInterval(this);\n\t            }\n\t            return labelInterval;\n\t        },\n\t\n\t        /**\n\t         * If label is ignored.\n\t         * Automatically used when axis is category and label can not be all shown\n\t         * @param  {number}  idx\n\t         * @return {boolean}\n\t         */\n\t        isLabelIgnored: function (idx) {\n\t            if (this.type === 'category') {\n\t                var labelInterval = this.getLabelInterval();\n\t                return ((typeof labelInterval === 'function')\n\t                    && !labelInterval(idx, this.scale.getLabel(idx)))\n\t                    || idx % (labelInterval + 1);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var localCoord = axis.toLocalCoord(80);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toLocalCoord: null,\n\t\n\t        /**\n\t         * Transform global coord to local coord,\n\t         * i.e. var globalCoord = axis.toLocalCoord(40);\n\t         * designate by module:echarts/coord/cartesian/Grid.\n\t         * @type {Function}\n\t         */\n\t        toGlobalCoord: null\n\t\n\t    };\n\t    zrUtil.inherits(Axis2D, Axis);\n\t\n\t    module.exports = Axis2D;\n\n\n/***/ },\n\n/***/ 550:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var numberUtil = __webpack_require__(128);\n\t    var linearMap = numberUtil.linearMap;\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    function fixExtentWithBands(extent, nTick) {\n\t        var size = extent[1] - extent[0];\n\t        var len = nTick;\n\t        var margin = size / len / 2;\n\t        extent[0] += margin;\n\t        extent[1] -= margin;\n\t    }\n\t\n\t    var normalizedExtent = [0, 1];\n\t    /**\n\t     * @name module:echarts/coord/CartesianAxis\n\t     * @constructor\n\t     */\n\t    var Axis = function (dim, scale, extent) {\n\t\n\t        /**\n\t         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n\t         * @type {string}\n\t         */\n\t        this.dim = dim;\n\t\n\t        /**\n\t         * Axis scale\n\t         * @type {module:echarts/coord/scale/*}\n\t         */\n\t        this.scale = scale;\n\t\n\t        /**\n\t         * @type {Array.<number>}\n\t         * @private\n\t         */\n\t        this._extent = extent || [0, 0];\n\t\n\t        /**\n\t         * @type {boolean}\n\t         */\n\t        this.inverse = false;\n\t\n\t        /**\n\t         * Usually true when axis has a ordinal scale\n\t         * @type {boolean}\n\t         */\n\t        this.onBand = false;\n\t    };\n\t\n\t    Axis.prototype = {\n\t\n\t        constructor: Axis,\n\t\n\t        /**\n\t         * If axis extent contain given coord\n\t         * @param {number} coord\n\t         * @return {boolean}\n\t         */\n\t        contain: function (coord) {\n\t            var extent = this._extent;\n\t            var min = Math.min(extent[0], extent[1]);\n\t            var max = Math.max(extent[0], extent[1]);\n\t            return coord >= min && coord <= max;\n\t        },\n\t\n\t        /**\n\t         * If axis extent contain given data\n\t         * @param {number} data\n\t         * @return {boolean}\n\t         */\n\t        containData: function (data) {\n\t            return this.contain(this.dataToCoord(data));\n\t        },\n\t\n\t        /**\n\t         * Get coord extent.\n\t         * @return {Array.<number>}\n\t         */\n\t        getExtent: function () {\n\t            var ret = this._extent.slice();\n\t            return ret;\n\t        },\n\t\n\t        /**\n\t         * Get precision used for formatting\n\t         * @param {Array.<number>} [dataExtent]\n\t         * @return {number}\n\t         */\n\t        getPixelPrecision: function (dataExtent) {\n\t            return numberUtil.getPixelPrecision(\n\t                dataExtent || this.scale.getExtent(),\n\t                this._extent\n\t            );\n\t        },\n\t\n\t        /**\n\t         * Set coord extent\n\t         * @param {number} start\n\t         * @param {number} end\n\t         */\n\t        setExtent: function (start, end) {\n\t            var extent = this._extent;\n\t            extent[0] = start;\n\t            extent[1] = end;\n\t        },\n\t\n\t        /**\n\t         * Convert data to coord. Data is the rank if it has a ordinal scale\n\t         * @param {number} data\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        dataToCoord: function (data, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t            data = scale.normalize(data);\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            return linearMap(data, normalizedExtent, extent, clamp);\n\t        },\n\t\n\t        /**\n\t         * Convert coord to data. Data is the rank if it has a ordinal scale\n\t         * @param {number} coord\n\t         * @param  {boolean} clamp\n\t         * @return {number}\n\t         */\n\t        coordToData: function (coord, clamp) {\n\t            var extent = this._extent;\n\t            var scale = this.scale;\n\t\n\t            if (this.onBand && scale.type === 'ordinal') {\n\t                extent = extent.slice();\n\t                fixExtentWithBands(extent, scale.count());\n\t            }\n\t\n\t            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\t\n\t            return this.scale.scale(t);\n\t        },\n\t        /**\n\t         * @return {Array.<number>}\n\t         */\n\t        getTicksCoords: function (alignWithLabel) {\n\t            if (this.onBand && !alignWithLabel) {\n\t                var bands = this.getBands();\n\t                var coords = [];\n\t                for (var i = 0; i < bands.length; i++) {\n\t                    coords.push(bands[i][0]);\n\t                }\n\t                if (bands[i - 1]) {\n\t                    coords.push(bands[i - 1][1]);\n\t                }\n\t                return coords;\n\t            }\n\t            else {\n\t                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Coords of labels are on the ticks or on the middle of bands\n\t         * @return {Array.<number>}\n\t         */\n\t        getLabelsCoords: function () {\n\t            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n\t        },\n\t\n\t        /**\n\t         * Get bands.\n\t         *\n\t         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n\t         * |---1---|---2---|---3---|---4---|.\n\t         *\n\t         * @return {Array}\n\t         */\n\t         // FIXME Situation when labels is on ticks\n\t        getBands: function () {\n\t            var extent = this.getExtent();\n\t            var bands = [];\n\t            var len = this.scale.count();\n\t            var start = extent[0];\n\t            var end = extent[1];\n\t            var span = end - start;\n\t\n\t            for (var i = 0; i < len; i++) {\n\t                bands.push([\n\t                    span * i / len + start,\n\t                    span * (i + 1) / len + start\n\t                ]);\n\t            }\n\t            return bands;\n\t        },\n\t\n\t        /**\n\t         * Get width of band\n\t         * @return {number}\n\t         */\n\t        getBandWidth: function () {\n\t            var axisExtent = this._extent;\n\t            var dataExtent = this.scale.getExtent();\n\t\n\t            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n\t            // Fix #2728, avoid NaN when only one data.\n\t            len === 0 && (len = 1);\n\t\n\t            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\t\n\t            return Math.abs(size) / len;\n\t        }\n\t    };\n\t\n\t    module.exports = Axis;\n\n\n/***/ },\n\n/***/ 551:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/**\n\t * Helper function for axisLabelInterval calculation\n\t */\n\t\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var axisHelper = __webpack_require__(541);\n\t\n\t    module.exports = function (axis) {\n\t        var axisModel = axis.model;\n\t        var labelModel = axisModel.getModel('axisLabel');\n\t        var labelInterval = labelModel.get('interval');\n\t        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n\t            return labelInterval === 'auto' ? 0 : labelInterval;\n\t        }\n\t\n\t        return axisHelper.getAxisLabelInterval(\n\t            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n\t            axisModel.getFormattedLabels(),\n\t            labelModel.getModel('textStyle').getFont(),\n\t            axis.isHorizontal()\n\t        );\n\t    };\n\n\n/***/ },\n\n/***/ 552:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// Grid 是在有直角坐标系的时候必须要存在的\n\t// 所以这里也要被 Cartesian2D 依赖\n\t\n\t\n\t    __webpack_require__(553);\n\t    var ComponentModel = __webpack_require__(140);\n\t\n\t    module.exports = ComponentModel.extend({\n\t\n\t        type: 'grid',\n\t\n\t        dependencies: ['xAxis', 'yAxis'],\n\t\n\t        layoutMode: 'box',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Grid}\n\t         */\n\t        coordinateSystem: null,\n\t\n\t        defaultOption: {\n\t            show: false,\n\t            zlevel: 0,\n\t            z: 0,\n\t            left: '10%',\n\t            top: 60,\n\t            right: '10%',\n\t            bottom: 60,\n\t            // If grid size contain label\n\t            containLabel: false,\n\t            // width: {totalWidth} - left - right,\n\t            // height: {totalHeight} - top - bottom,\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            borderWidth: 1,\n\t            borderColor: '#ccc'\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 553:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var ComponentModel = __webpack_require__(140);\n\t    var zrUtil = __webpack_require__(125);\n\t    var axisModelCreator = __webpack_require__(554);\n\t\n\t    var AxisModel = ComponentModel.extend({\n\t\n\t        type: 'cartesian2dAxis',\n\t\n\t        /**\n\t         * @type {module:echarts/coord/cartesian/Axis2D}\n\t         */\n\t        axis: null,\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        init: function () {\n\t            AxisModel.superApply(this, 'init', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        mergeOption: function () {\n\t            AxisModel.superApply(this, 'mergeOption', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @override\n\t         */\n\t        restoreData: function () {\n\t            AxisModel.superApply(this, 'restoreData', arguments);\n\t            this.resetRange();\n\t        },\n\t\n\t        /**\n\t         * @return {module:echarts/model/Model}\n\t         */\n\t        findGridModel: function () {\n\t            return this.ecModel.queryComponents({\n\t                mainType: 'grid',\n\t                index: this.get('gridIndex'),\n\t                id: this.get('gridId')\n\t            })[0];\n\t        }\n\t\n\t    });\n\t\n\t    function getAxisType(axisDim, option) {\n\t        // Default axis with data is category axis\n\t        return option.type || (option.data ? 'category' : 'value');\n\t    }\n\t\n\t    zrUtil.merge(AxisModel.prototype, __webpack_require__(556));\n\t    zrUtil.merge(AxisModel.prototype, __webpack_require__(557));\n\t\n\t    var extraOption = {\n\t        // gridIndex: 0,\n\t        // gridId: '',\n\t\n\t        // Offset is for multiple axis on the same position\n\t        offset: 0\n\t    };\n\t\n\t    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n\t    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\t\n\t    module.exports = AxisModel;\n\n\n/***/ },\n\n/***/ 554:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var axisDefault = __webpack_require__(555);\n\t    var zrUtil = __webpack_require__(125);\n\t    var ComponentModel = __webpack_require__(140);\n\t    var layout = __webpack_require__(142);\n\t\n\t    // FIXME axisType is fixed ?\n\t    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\t\n\t    /**\n\t     * Generate sub axis model class\n\t     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n\t     * @param {module:echarts/model/Component} BaseAxisModelClass\n\t     * @param {Function} axisTypeDefaulter\n\t     * @param {Object} [extraDefaultOption]\n\t     */\n\t    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\t\n\t        zrUtil.each(AXIS_TYPES, function (axisType) {\n\t\n\t            BaseAxisModelClass.extend({\n\t\n\t                type: axisName + 'Axis.' + axisType,\n\t\n\t                mergeDefaultAndTheme: function (option, ecModel) {\n\t                    var layoutMode = this.layoutMode;\n\t                    var inputPositionParams = layoutMode\n\t                        ? layout.getLayoutParams(option) : {};\n\t\n\t                    var themeModel = ecModel.getTheme();\n\t                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n\t                    zrUtil.merge(option, this.getDefaultOption());\n\t\n\t                    option.type = axisTypeDefaulter(axisName, option);\n\t\n\t                    if (layoutMode) {\n\t                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n\t                    }\n\t                },\n\t\n\t                defaultOption: zrUtil.mergeAll(\n\t                    [\n\t                        {},\n\t                        axisDefault[axisType + 'Axis'],\n\t                        extraDefaultOption\n\t                    ],\n\t                    true\n\t                )\n\t            });\n\t        });\n\t\n\t        ComponentModel.registerSubTypeDefaulter(\n\t            axisName + 'Axis',\n\t            zrUtil.curry(axisTypeDefaulter, axisName)\n\t        );\n\t    };\n\n\n/***/ },\n\n/***/ 555:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    var defaultOption = {\n\t        show: true,\n\t        zlevel: 0,                  // 一级层叠\n\t        z: 0,                       // 二级层叠\n\t        // 反向坐标轴\n\t        inverse: false,\n\t\n\t        // 坐标轴名字，默认为空\n\t        name: '',\n\t        // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n\t        nameLocation: 'end',\n\t        // 坐标轴名字旋转，degree。\n\t        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n\t        nameTruncate: {\n\t            maxWidth: null,\n\t            ellipsis: '...',\n\t            placeholder: '.'\n\t        },\n\t        // 坐标轴文字样式，默认取全局样式\n\t        nameTextStyle: {},\n\t        // 文字与轴线距离\n\t        nameGap: 15,\n\t\n\t        silent: false, // Default false to support tooltip.\n\t        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\t\n\t        tooltip: {\n\t            show: false\n\t        },\n\t\n\t        // 坐标轴线\n\t        axisLine: {\n\t            // 默认显示，属性show控制显示与否\n\t            show: true,\n\t            onZero: true,\n\t            // 属性lineStyle控制线条样式\n\t            lineStyle: {\n\t                color: '#333',\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // 坐标轴小标记\n\t        axisTick: {\n\t            // 属性show控制显示与否，默认显示\n\t            show: true,\n\t            // 控制小标记是否在grid里\n\t            inside: false,\n\t            // 属性length控制线长\n\t            length: 5,\n\t            // 属性lineStyle控制线条样式\n\t            lineStyle: {\n\t                width: 1\n\t            }\n\t        },\n\t        // 坐标轴文本标签，详见axis.axisLabel\n\t        axisLabel: {\n\t            show: true,\n\t            // 控制文本标签是否在grid里\n\t            inside: false,\n\t            rotate: 0,\n\t            margin: 8,\n\t            // formatter: null,\n\t            // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n\t            textStyle: {\n\t                fontSize: 12\n\t            }\n\t        },\n\t        // 分隔线\n\t        splitLine: {\n\t            // 默认显示，属性show控制显示与否\n\t            show: true,\n\t            // 属性lineStyle（详见lineStyle）控制线条样式\n\t            lineStyle: {\n\t                color: ['#ccc'],\n\t                width: 1,\n\t                type: 'solid'\n\t            }\n\t        },\n\t        // 分隔区域\n\t        splitArea: {\n\t            // 默认不显示，属性show控制显示与否\n\t            show: false,\n\t            // 属性areaStyle（详见areaStyle）控制区域样式\n\t            areaStyle: {\n\t                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n\t            }\n\t        }\n\t    };\n\t\n\t    var categoryAxis = zrUtil.merge({\n\t        // 类目起始和结束两端空白策略\n\t        boundaryGap: true,\n\t        // splitArea: {\n\t            // show: false\n\t        // },\n\t        splitLine: {\n\t            show: false\n\t        },\n\t        // 坐标轴小标记\n\t        axisTick: {\n\t            // If tick is align with label when boundaryGap is true\n\t            // Default with axisTick\n\t            alignWithLabel: false,\n\t            interval: 'auto'\n\t        },\n\t        // 坐标轴文本标签，详见axis.axisLabel\n\t        axisLabel: {\n\t            interval: 'auto'\n\t        }\n\t    }, defaultOption);\n\t\n\t    var valueAxis = zrUtil.merge({\n\t        // 数值起始和结束两端空白策略\n\t        boundaryGap: [0, 0],\n\t        // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n\t        // min: null,\n\t        // 最大值，设置成 'dataMax' 则从数据中计算最大值\n\t        // max: null,\n\t        // Readonly prop, specifies start value of the range when using data zoom.\n\t        // rangeStart: null\n\t        // Readonly prop, specifies end value of the range when using data zoom.\n\t        // rangeEnd: null\n\t        // 脱离0值比例，放大聚焦到最终_min，_max区间\n\t        // scale: false,\n\t        // 分割段数，默认为5\n\t        splitNumber: 5\n\t        // Minimum interval\n\t        // minInterval: null\n\t    }, defaultOption);\n\t\n\t    // FIXME\n\t    var timeAxis = zrUtil.defaults({\n\t        scale: true,\n\t        min: 'dataMin',\n\t        max: 'dataMax'\n\t    }, valueAxis);\n\t    var logAxis = zrUtil.defaults({\n\t        logBase: 10\n\t    }, valueAxis);\n\t    logAxis.scale = true;\n\t\n\t    module.exports = {\n\t        categoryAxis: categoryAxis,\n\t        valueAxis: valueAxis,\n\t        timeAxis: timeAxis,\n\t        logAxis: logAxis\n\t    };\n\n\n/***/ },\n\n/***/ 556:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var axisHelper = __webpack_require__(541);\n\t\n\t    function getName(obj) {\n\t        if (zrUtil.isObject(obj) && obj.value != null) {\n\t            return obj.value;\n\t        }\n\t        else {\n\t            return obj;\n\t        }\n\t    }\n\t    /**\n\t     * Get categories\n\t     */\n\t    function getCategories() {\n\t        return this.get('type') === 'category'\n\t            && zrUtil.map(this.get('data'), getName);\n\t    }\n\t\n\t    /**\n\t     * Format labels\n\t     * @return {Array.<string>}\n\t     */\n\t    function getFormattedLabels() {\n\t        return axisHelper.getFormattedLabels(\n\t            this.axis,\n\t            this.get('axisLabel.formatter')\n\t        );\n\t    }\n\t\n\t    module.exports = {\n\t\n\t        getFormattedLabels: getFormattedLabels,\n\t\n\t        getCategories: getCategories\n\t    };\n\n\n/***/ },\n\n/***/ 557:\n/***/ function(module, exports) {\n\n\t\n\t\n\t    module.exports = {\n\t\n\t        /**\n\t         * @public\n\t         * @return {Array.<number|string|Date>}\n\t         */\n\t        getMin: function () {\n\t            var option = this.option;\n\t            var min = option.rangeStart != null ? option.rangeStart : option.min;\n\t            // In case of axis.type === 'time', Date should be converted to timestamp.\n\t            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n\t            if (min instanceof Date) {\n\t                min = +min;\n\t            }\n\t            return min;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {Array.<number|string|Date>}\n\t         */\n\t        getMax: function () {\n\t            var option = this.option;\n\t            var max = option.rangeEnd != null ? option.rangeEnd : option.max;\n\t            // In case of axis.type === 'time', Date should be converted to timestamp.\n\t            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n\t            if (max instanceof Date) {\n\t                max = +max;\n\t            }\n\t            return max;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @return {boolean}\n\t         */\n\t        getNeedCrossZero: function () {\n\t            var option = this.option;\n\t            return (option.rangeStart != null || option.rangeEnd != null)\n\t                ? false : !option.scale;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         * @param {number} rangeStart\n\t         * @param {number} rangeEnd\n\t         */\n\t        setRange: function (rangeStart, rangeEnd) {\n\t            this.option.rangeStart = rangeStart;\n\t            this.option.rangeEnd = rangeEnd;\n\t        },\n\t\n\t        /**\n\t         * @public\n\t         */\n\t        resetRange: function () {\n\t            // rangeStart and rangeEnd is readonly.\n\t            this.option.rangeStart = this.option.rangeEnd = null;\n\t        }\n\t    };\n\t\n\n\n/***/ },\n\n/***/ 558:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// TODO boundaryGap\n\t\n\t\n\t    __webpack_require__(553);\n\t\n\t    __webpack_require__(559);\n\n\n/***/ },\n\n/***/ 559:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var graphic = __webpack_require__(164);\n\t    var AxisBuilder = __webpack_require__(560);\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n\t    var getInterval = AxisBuilder.getInterval;\n\t\n\t    var axisBuilderAttrs = [\n\t        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n\t    ];\n\t    var selfBuilderAttrs = [\n\t        'splitArea', 'splitLine'\n\t    ];\n\t\n\t    // function getAlignWithLabel(model, axisModel) {\n\t    //     var alignWithLabel = model.get('alignWithLabel');\n\t    //     if (alignWithLabel === 'auto') {\n\t    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n\t    //     }\n\t    //     return alignWithLabel;\n\t    // }\n\t\n\t    var AxisView = __webpack_require__(122).extendComponentView({\n\t\n\t        type: 'axis',\n\t\n\t        render: function (axisModel, ecModel) {\n\t\n\t            this.group.removeAll();\n\t\n\t            var oldAxisGroup = this._axisGroup;\n\t            this._axisGroup = new graphic.Group();\n\t\n\t            this.group.add(this._axisGroup);\n\t\n\t            if (!axisModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var gridModel = axisModel.findGridModel();\n\t\n\t            var layout = layoutAxis(gridModel, axisModel);\n\t\n\t            var axisBuilder = new AxisBuilder(axisModel, layout);\n\t\n\t            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\t\n\t            this._axisGroup.add(axisBuilder.getGroup());\n\t\n\t            zrUtil.each(selfBuilderAttrs, function (name) {\n\t                if (axisModel.get(name + '.show')) {\n\t                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n\t                }\n\t            }, this);\n\t\n\t            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitLine: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            var splitLineModel = axisModel.getModel('splitLine');\n\t            var lineStyleModel = splitLineModel.getModel('lineStyle');\n\t            var lineColors = lineStyleModel.get('color');\n\t\n\t            var lineInterval = getInterval(splitLineModel, labelInterval);\n\t\n\t            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t            var isHorizontal = axis.isHorizontal();\n\t\n\t            var lineCount = 0;\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitLineModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var p1 = [];\n\t            var p2 = [];\n\t            // Simple optimization\n\t            // Batching the lines if color are the same\n\t            var lineStyle = lineStyleModel.getLineStyle();\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                if (isHorizontal) {\n\t                    p1[0] = tickCoord;\n\t                    p1[1] = gridRect.y;\n\t                    p2[0] = tickCoord;\n\t                    p2[1] = gridRect.y + gridRect.height;\n\t                }\n\t                else {\n\t                    p1[0] = gridRect.x;\n\t                    p1[1] = tickCoord;\n\t                    p2[0] = gridRect.x + gridRect.width;\n\t                    p2[1] = tickCoord;\n\t                }\n\t\n\t                var colorIndex = (lineCount++) % lineColors.length;\n\t                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t                    anid: 'line_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: p1[0],\n\t                        y1: p1[1],\n\t                        x2: p2[0],\n\t                        y2: p2[1]\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        stroke: lineColors[colorIndex]\n\t                    }, lineStyle),\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @param {number|Function} labelInterval\n\t         * @private\n\t         */\n\t        _splitArea: function (axisModel, gridModel, labelInterval) {\n\t            var axis = axisModel.axis;\n\t\n\t            var splitAreaModel = axisModel.getModel('splitArea');\n\t            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n\t            var areaColors = areaStyleModel.get('color');\n\t\n\t            var gridRect = gridModel.coordinateSystem.getRect();\n\t\n\t            var ticksCoords = axis.getTicksCoords(\n\t                // splitAreaModel.get('alignWithLabel')\n\t            );\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n\t            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\t\n\t            var count = 0;\n\t\n\t            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\t\n\t            var areaStyle = areaStyleModel.getAreaStyle();\n\t            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\t\n\t            for (var i = 1; i < ticksCoords.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n\t                    continue;\n\t                }\n\t\n\t                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\t\n\t                var x;\n\t                var y;\n\t                var width;\n\t                var height;\n\t                if (axis.isHorizontal()) {\n\t                    x = prevX;\n\t                    y = gridRect.y;\n\t                    width = tickCoord - x;\n\t                    height = gridRect.height;\n\t                }\n\t                else {\n\t                    x = gridRect.x;\n\t                    y = prevY;\n\t                    width = gridRect.width;\n\t                    height = tickCoord - y;\n\t                }\n\t\n\t                var colorIndex = (count++) % areaColors.length;\n\t                this._axisGroup.add(new graphic.Rect({\n\t                    anid: 'area_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x: x,\n\t                        y: y,\n\t                        width: width,\n\t                        height: height\n\t                    },\n\t                    style: zrUtil.defaults({\n\t                        fill: areaColors[colorIndex]\n\t                    }, areaStyle),\n\t                    silent: true\n\t                }));\n\t\n\t                prevX = x + width;\n\t                prevY = y + height;\n\t            }\n\t        }\n\t    });\n\t\n\t    AxisView.extend({\n\t        type: 'xAxis'\n\t    });\n\t    AxisView.extend({\n\t        type: 'yAxis'\n\t    });\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function layoutAxis(gridModel, axisModel) {\n\t        var grid = gridModel.coordinateSystem;\n\t        var axis = axisModel.axis;\n\t        var layout = {};\n\t\n\t        var rawAxisPosition = axis.position;\n\t        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n\t        var axisDim = axis.dim;\n\t\n\t        // [left, right, top, bottom]\n\t        var rect = grid.getRect();\n\t        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\t\n\t        var axisOffset = axisModel.get('offset') || 0;\n\t\n\t        var posMap = {\n\t            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n\t            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n\t        };\n\t\n\t        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n\t        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\t\n\t        function getZero(dim, val) {\n\t            var theAxis = grid.getAxis(dim);\n\t            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n\t        }\n\t\n\t        // Axis position\n\t        layout.position = [\n\t            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n\t            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n\t        ];\n\t\n\t        // Axis rotation\n\t        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\t\n\t        // Tick and label direction, x y is axisDim\n\t        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\t\n\t        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n\t        if (axis.onZero) {\n\t            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n\t        }\n\t\n\t        if (axisModel.getModel('axisTick').get('inside')) {\n\t            layout.tickDirection = -layout.tickDirection;\n\t        }\n\t        if (axisModel.getModel('axisLabel').get('inside')) {\n\t            layout.labelDirection = -layout.labelDirection;\n\t        }\n\t\n\t        // Special label rotation\n\t        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n\t        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\t\n\t        // label interval when auto mode.\n\t        layout.labelInterval = axis.getLabelInterval();\n\t\n\t        // Over splitLine and splitArea\n\t        layout.z2 = 1;\n\t\n\t        return layout;\n\t    }\n\n\n/***/ },\n\n/***/ 560:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var formatUtil = __webpack_require__(127);\n\t    var graphic = __webpack_require__(164);\n\t    var Model = __webpack_require__(133);\n\t    var numberUtil = __webpack_require__(128);\n\t    var remRadian = numberUtil.remRadian;\n\t    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n\t    var vec2 = __webpack_require__(131);\n\t    var v2ApplyTransform = vec2.applyTransform;\n\t    var retrieve = zrUtil.retrieve;\n\t\n\t    var PI = Math.PI;\n\t\n\t    function makeAxisEventDataBase(axisModel) {\n\t        var eventData = {\n\t            componentType: axisModel.mainType\n\t        };\n\t        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n\t        return eventData;\n\t    }\n\t\n\t    /**\n\t     * A final axis is translated and rotated from a \"standard axis\".\n\t     * So opt.position and opt.rotation is required.\n\t     *\n\t     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n\t     * for example: (0, 0) ------------> (0, 50)\n\t     *\n\t     * nameDirection or tickDirection or labelDirection is 1 means tick\n\t     * or label is below the standard axis, whereas is -1 means above\n\t     * the standard axis. labelOffset means offset between label and axis,\n\t     * which is useful when 'onZero', where axisLabel is in the grid and\n\t     * label in outside grid.\n\t     *\n\t     * Tips: like always,\n\t     * positive rotation represents anticlockwise, and negative rotation\n\t     * represents clockwise.\n\t     * The direction of position coordinate is the same as the direction\n\t     * of screen coordinate.\n\t     *\n\t     * Do not need to consider axis 'inverse', which is auto processed by\n\t     * axis extent.\n\t     *\n\t     * @param {module:zrender/container/Group} group\n\t     * @param {Object} axisModel\n\t     * @param {Object} opt Standard axis parameters.\n\t     * @param {Array.<number>} opt.position [x, y]\n\t     * @param {number} opt.rotation by radian\n\t     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n\t     * @param {number} [opt.tickDirection=1] 1 or -1\n\t     * @param {number} [opt.labelDirection=1] 1 or -1\n\t     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n\t     * @param {string} [opt.axisLabelShow] default get from axisModel.\n\t     * @param {string} [opt.axisName] default get from axisModel.\n\t     * @param {number} [opt.axisNameAvailableWidth]\n\t     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n\t     * @param {number} [opt.labelInterval] Default label interval when label\n\t     *                                     interval from model is null or 'auto'.\n\t     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n\t     */\n\t    var AxisBuilder = function (axisModel, opt) {\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.opt = opt;\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.axisModel = axisModel;\n\t\n\t        // Default value\n\t        zrUtil.defaults(\n\t            opt,\n\t            {\n\t                labelOffset: 0,\n\t                nameDirection: 1,\n\t                tickDirection: 1,\n\t                labelDirection: 1,\n\t                silent: true\n\t            }\n\t        );\n\t\n\t        /**\n\t         * @readOnly\n\t         */\n\t        this.group = new graphic.Group();\n\t\n\t        // FIXME Not use a seperate text group?\n\t        var dumbGroup = new graphic.Group({\n\t            position: opt.position.slice(),\n\t            rotation: opt.rotation\n\t        });\n\t\n\t        // this.group.add(dumbGroup);\n\t        // this._dumbGroup = dumbGroup;\n\t\n\t        dumbGroup.updateTransform();\n\t        this._transform = dumbGroup.transform;\n\t\n\t        this._dumbGroup = dumbGroup;\n\t    };\n\t\n\t    AxisBuilder.prototype = {\n\t\n\t        constructor: AxisBuilder,\n\t\n\t        hasBuilder: function (name) {\n\t            return !!builders[name];\n\t        },\n\t\n\t        add: function (name) {\n\t            builders[name].call(this);\n\t        },\n\t\n\t        getGroup: function () {\n\t            return this.group;\n\t        }\n\t\n\t    };\n\t\n\t    var builders = {\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisLine: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t\n\t            if (!axisModel.get('axisLine.show')) {\n\t                return;\n\t            }\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t\n\t            var matrix = this._transform;\n\t            var pt1 = [extent[0], 0];\n\t            var pt2 = [extent[1], 0];\n\t            if (matrix) {\n\t                v2ApplyTransform(pt1, pt1, matrix);\n\t                v2ApplyTransform(pt2, pt2, matrix);\n\t            }\n\t\n\t            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                // Id for animation\n\t                anid: 'line',\n\t\n\t                shape: {\n\t                    x1: pt1[0],\n\t                    y1: pt1[1],\n\t                    x2: pt2[0],\n\t                    y2: pt2[1]\n\t                },\n\t                style: zrUtil.extend(\n\t                    {lineCap: 'round'},\n\t                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n\t                ),\n\t                strokeContainThreshold: opt.strokeContainThreshold || 5,\n\t                silent: true,\n\t                z2: 1\n\t            })));\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisTick: function () {\n\t            var axisModel = this.axisModel;\n\t\n\t            if (!axisModel.get('axisTick.show')) {\n\t                return;\n\t            }\n\t\n\t            var axis = axisModel.axis;\n\t            var tickModel = axisModel.getModel('axisTick');\n\t            var opt = this.opt;\n\t\n\t            var lineStyleModel = tickModel.getModel('lineStyle');\n\t            var tickLen = tickModel.get('length');\n\t\n\t            var tickInterval = getInterval(tickModel, opt.labelInterval);\n\t            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n\t            var ticks = axis.scale.getTicks();\n\t\n\t            var pt1 = [];\n\t            var pt2 = [];\n\t            var matrix = this._transform;\n\t\n\t            for (var i = 0; i < ticksCoords.length; i++) {\n\t                // Only ordinal scale support tick interval\n\t                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n\t                     continue;\n\t                }\n\t\n\t                var tickCoord = ticksCoords[i];\n\t\n\t                pt1[0] = tickCoord;\n\t                pt1[1] = 0;\n\t                pt2[0] = tickCoord;\n\t                pt2[1] = opt.tickDirection * tickLen;\n\t\n\t                if (matrix) {\n\t                    v2ApplyTransform(pt1, pt1, matrix);\n\t                    v2ApplyTransform(pt2, pt2, matrix);\n\t                }\n\t                // Tick line, Not use group transform to have better line draw\n\t                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\t\n\t                    // Id for animation\n\t                    anid: 'tick_' + ticks[i],\n\t\n\t                    shape: {\n\t                        x1: pt1[0],\n\t                        y1: pt1[1],\n\t                        x2: pt2[0],\n\t                        y2: pt2[1]\n\t                    },\n\t                    style: zrUtil.defaults(\n\t                        lineStyleModel.getLineStyle(),\n\t                        {\n\t                            stroke: axisModel.get('axisLine.lineStyle.color')\n\t                        }\n\t                    ),\n\t                    z2: 2,\n\t                    silent: true\n\t                })));\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n\t         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n\t         * @private\n\t         */\n\t        axisLabel: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\t\n\t            if (!show) {\n\t                return;\n\t            }\n\t\n\t            var axis = axisModel.axis;\n\t            var labelModel = axisModel.getModel('axisLabel');\n\t            var textStyleModel = labelModel.getModel('textStyle');\n\t            var labelMargin = labelModel.get('margin');\n\t            var ticks = axis.scale.getTicks();\n\t            var labels = axisModel.getFormattedLabels();\n\t\n\t            // Special label rotate.\n\t            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n\t            // To radian.\n\t            labelRotation = labelRotation * PI / 180;\n\t\n\t            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n\t            var categoryData = axisModel.get('data');\n\t\n\t            var textEls = [];\n\t            var silent = isSilent(axisModel);\n\t            var triggerEvent = axisModel.get('triggerEvent');\n\t\n\t            for (var i = 0; i < ticks.length; i++) {\n\t                if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n\t                     continue;\n\t                }\n\t\n\t                var itemTextStyleModel = textStyleModel;\n\t                if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n\t                    itemTextStyleModel = new Model(\n\t                        categoryData[i].textStyle, textStyleModel, axisModel.ecModel\n\t                    );\n\t                }\n\t                var textColor = itemTextStyleModel.getTextColor()\n\t                    || axisModel.get('axisLine.lineStyle.color');\n\t\n\t                var tickCoord = axis.dataToCoord(ticks[i]);\n\t                var pos = [\n\t                    tickCoord,\n\t                    opt.labelOffset + opt.labelDirection * labelMargin\n\t                ];\n\t                var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\t\n\t                var textEl = new graphic.Text({\n\t\n\t                    // Id for animation\n\t                    anid: 'label_' + ticks[i],\n\t\n\t                    style: {\n\t                        text: labels[i],\n\t                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n\t                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n\t                        textFont: itemTextStyleModel.getFont(),\n\t                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n\t                    },\n\t                    position: pos,\n\t                    rotation: labelLayout.rotation,\n\t                    silent: silent,\n\t                    z2: 10\n\t                });\n\t\n\t                // Pack data for mouse event\n\t                if (triggerEvent) {\n\t                    textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                    textEl.eventData.targetType = 'axisLabel';\n\t                    textEl.eventData.value = labelBeforeFormat;\n\t                }\n\t\n\t\n\t                // FIXME\n\t                this._dumbGroup.add(textEl);\n\t                textEl.updateTransform();\n\t\n\t                textEls.push(textEl);\n\t                this.group.add(textEl);\n\t\n\t                textEl.decomposeTransform();\n\t            }\n\t\n\t            function isTwoLabelOverlapped(current, next) {\n\t                var firstRect = current && current.getBoundingRect().clone();\n\t                var nextRect = next && next.getBoundingRect().clone();\n\t                if (firstRect && nextRect) {\n\t                    firstRect.applyTransform(current.getLocalTransform());\n\t                    nextRect.applyTransform(next.getLocalTransform());\n\t                    return firstRect.intersect(nextRect);\n\t                }\n\t            }\n\t            if (axis.type !== 'category') {\n\t                // If min or max are user set, we need to check\n\t                // If the tick on min(max) are overlap on their neighbour tick\n\t                // If they are overlapped, we need to hide the min(max) tick label\n\t                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n\t                    var firstLabel = textEls[0];\n\t                    var nextLabel = textEls[1];\n\t                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n\t                        firstLabel.ignore = true;\n\t                    }\n\t                }\n\t                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n\t                    var lastLabel = textEls[textEls.length - 1];\n\t                    var prevLabel = textEls[textEls.length - 2];\n\t                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n\t                        lastLabel.ignore = true;\n\t                    }\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        axisName: function () {\n\t            var opt = this.opt;\n\t            var axisModel = this.axisModel;\n\t            var name = retrieve(opt.axisName, axisModel.get('name'));\n\t\n\t            if (!name) {\n\t                return;\n\t            }\n\t\n\t            var nameLocation = axisModel.get('nameLocation');\n\t            var nameDirection = opt.nameDirection;\n\t            var textStyleModel = axisModel.getModel('nameTextStyle');\n\t            var gap = axisModel.get('nameGap') || 0;\n\t\n\t            var extent = this.axisModel.axis.getExtent();\n\t            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n\t            var pos = [\n\t                nameLocation === 'start'\n\t                    ? extent[0] - gapSignal * gap\n\t                    : nameLocation === 'end'\n\t                    ? extent[1] + gapSignal * gap\n\t                    : (extent[0] + extent[1]) / 2, // 'middle'\n\t                // Reuse labelOffset.\n\t                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n\t            ];\n\t\n\t            var labelLayout;\n\t\n\t            var nameRotation = axisModel.get('nameRotate');\n\t            if (nameRotation != null) {\n\t                nameRotation = nameRotation * PI / 180; // To radian.\n\t            }\n\t\n\t            var axisNameAvailableWidth;\n\t\n\t            if (nameLocation === 'middle') {\n\t                labelLayout = innerTextLayout(\n\t                    opt,\n\t                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n\t                    nameDirection\n\t                );\n\t            }\n\t            else {\n\t                labelLayout = endTextLayout(\n\t                    opt, nameLocation, nameRotation || 0, extent\n\t                );\n\t\n\t                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\t                if (axisNameAvailableWidth != null) {\n\t                    axisNameAvailableWidth = Math.abs(\n\t                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n\t                    );\n\t                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n\t                }\n\t            }\n\t\n\t            var textFont = textStyleModel.getFont();\n\t\n\t            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n\t            var ellipsis = truncateOpt.ellipsis;\n\t            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n\t            var truncatedText = (ellipsis != null && maxWidth != null)\n\t                ? formatUtil.truncateText(\n\t                    name, maxWidth, textFont, ellipsis,\n\t                    {minChar: 2, placeholder: truncateOpt.placeholder}\n\t                )\n\t                : name;\n\t\n\t            var tooltipOpt = axisModel.get('tooltip', true);\n\t\n\t            var mainType = axisModel.mainType;\n\t            var formatterParams = {\n\t                componentType: mainType,\n\t                name: name,\n\t                $vars: ['name']\n\t            };\n\t            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\t\n\t            var textEl = new graphic.Text({\n\t\n\t                // Id for animation\n\t                anid: 'name',\n\t\n\t                __fullText: name,\n\t                __truncatedText: truncatedText,\n\t\n\t                style: {\n\t                    text: truncatedText,\n\t                    textFont: textFont,\n\t                    fill: textStyleModel.getTextColor()\n\t                        || axisModel.get('axisLine.lineStyle.color'),\n\t                    textAlign: labelLayout.textAlign,\n\t                    textVerticalAlign: labelLayout.verticalAlign\n\t                },\n\t                position: pos,\n\t                rotation: labelLayout.rotation,\n\t                silent: isSilent(axisModel),\n\t                z2: 1,\n\t                tooltip: (tooltipOpt && tooltipOpt.show)\n\t                    ? zrUtil.extend({\n\t                        content: name,\n\t                        formatter: function () {\n\t                            return name;\n\t                        },\n\t                        formatterParams: formatterParams\n\t                    }, tooltipOpt)\n\t                    : null\n\t            });\n\t\n\t            if (axisModel.get('triggerEvent')) {\n\t                textEl.eventData = makeAxisEventDataBase(axisModel);\n\t                textEl.eventData.targetType = 'axisName';\n\t                textEl.eventData.name = name;\n\t            }\n\t\n\t            // FIXME\n\t            this._dumbGroup.add(textEl);\n\t            textEl.updateTransform();\n\t\n\t            this.group.add(textEl);\n\t\n\t            textEl.decomposeTransform();\n\t        }\n\t\n\t    };\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function innerTextLayout(opt, textRotation, direction) {\n\t        var rotationDiff = remRadian(textRotation - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t\n\t        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n\t            verticalAlign = direction > 0 ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t\n\t            if (rotationDiff > 0 && rotationDiff < PI) {\n\t                textAlign = direction > 0 ? 'right' : 'left';\n\t            }\n\t            else {\n\t                textAlign = direction > 0 ? 'left' : 'right';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function endTextLayout(opt, textPosition, textRotate, extent) {\n\t        var rotationDiff = remRadian(textRotate - opt.rotation);\n\t        var textAlign;\n\t        var verticalAlign;\n\t        var inverse = extent[0] > extent[1];\n\t        var onLeft = (textPosition === 'start' && !inverse)\n\t            || (textPosition !== 'start' && inverse);\n\t\n\t        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n\t            verticalAlign = onLeft ? 'bottom' : 'top';\n\t            textAlign = 'center';\n\t        }\n\t        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n\t            verticalAlign = onLeft ? 'top' : 'bottom';\n\t            textAlign = 'center';\n\t        }\n\t        else {\n\t            verticalAlign = 'middle';\n\t            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n\t                textAlign = onLeft ? 'left' : 'right';\n\t            }\n\t            else {\n\t                textAlign = onLeft ? 'right' : 'left';\n\t            }\n\t        }\n\t\n\t        return {\n\t            rotation: rotationDiff,\n\t            textAlign: textAlign,\n\t            verticalAlign: verticalAlign\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function isSilent(axisModel) {\n\t        var tooltipOpt = axisModel.get('tooltip');\n\t        return axisModel.get('silent')\n\t            // Consider mouse cursor, add these restrictions.\n\t            || !(\n\t                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n\t            );\n\t    }\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n\t        var rawTick;\n\t        var scale = axis.scale;\n\t        return scale.type === 'ordinal'\n\t            && (\n\t                typeof interval === 'function'\n\t                    ? (\n\t                        rawTick = scale.getTicks()[i],\n\t                        !interval(rawTick, scale.getLabel(rawTick))\n\t                    )\n\t                    : i % (interval + 1)\n\t            );\n\t    };\n\t\n\t    /**\n\t     * @static\n\t     */\n\t    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n\t        var interval = model.get('interval');\n\t        if (interval == null || interval == 'auto') {\n\t            interval = labelInterval;\n\t        }\n\t        return interval;\n\t    };\n\t\n\t    module.exports = AxisBuilder;\n\t\n\n\n/***/ },\n\n/***/ 561:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// FIXME Better way to pack data in graphic element\n\t\n\t\n\t    __webpack_require__(562);\n\t\n\t    __webpack_require__(563);\n\t\n\t    // Show tip action\n\t    /**\n\t     * @action\n\t     * @property {string} type\n\t     * @property {number} seriesIndex\n\t     * @property {number} dataIndex\n\t     * @property {number} [x]\n\t     * @property {number} [y]\n\t     */\n\t    __webpack_require__(122).registerAction(\n\t        {\n\t            type: 'showTip',\n\t            event: 'showTip',\n\t            update: 'none'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\t    // Hide tip action\n\t    __webpack_require__(122).registerAction(\n\t        {\n\t            type: 'hideTip',\n\t            event: 'hideTip',\n\t            update: 'none'\n\t        },\n\t        // noop\n\t        function () {}\n\t    );\n\n\n/***/ },\n\n/***/ 562:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    __webpack_require__(122).extendComponentModel({\n\t\n\t        type: 'tooltip',\n\t\n\t        defaultOption: {\n\t            zlevel: 0,\n\t\n\t            z: 8,\n\t\n\t            show: true,\n\t\n\t            // tooltip主体内容\n\t            showContent: true,\n\t\n\t            // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'\n\t            trigger: 'item',\n\t\n\t            // 触发条件，支持 'click' | 'mousemove' | 'none'\n\t            triggerOn: 'mousemove',\n\t\n\t            // 是否永远显示 content\n\t            alwaysShowContent: false,\n\t\n\t            // 位置 {Array} | {Function}\n\t            // position: null\n\t\n\t            // 内容格式器：{string}（Template） ¦ {Function}\n\t            // formatter: null\n\t\n\t            showDelay: 0,\n\t\n\t            // 隐藏延迟，单位ms\n\t            hideDelay: 100,\n\t\n\t            // 动画变换时间，单位s\n\t            transitionDuration: 0.4,\n\t\n\t            enterable: false,\n\t\n\t            // 提示背景颜色，默认为透明度为0.7的黑色\n\t            backgroundColor: 'rgba(50,50,50,0.7)',\n\t\n\t            // 提示边框颜色\n\t            borderColor: '#333',\n\t\n\t            // 提示边框圆角，单位px，默认为4\n\t            borderRadius: 4,\n\t\n\t            // 提示边框线宽，单位px，默认为0（无边框）\n\t            borderWidth: 0,\n\t\n\t            // 提示内边距，单位px，默认各方向内边距为5，\n\t            // 接受数组分别设定上右下左边距，同css\n\t            padding: 5,\n\t\n\t            // Extra css text\n\t            extraCssText: '',\n\t\n\t            // 坐标轴指示器，坐标轴触发有效\n\t            axisPointer: {\n\t                // 默认为直线\n\t                // 可选为：'line' | 'shadow' | 'cross'\n\t                type: 'line',\n\t\n\t                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n\t                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n\t                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n\t                // 极坐标系会默认选择 angle 轴\n\t                axis: 'auto',\n\t\n\t                animation: true,\n\t                animationDurationUpdate: 200,\n\t                animationEasingUpdate: 'exponentialOut',\n\t\n\t                // 直线指示器样式设置\n\t                lineStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'solid'\n\t                },\n\t\n\t                crossStyle: {\n\t                    color: '#555',\n\t                    width: 1,\n\t                    type: 'dashed',\n\t\n\t                    // TODO formatter\n\t                    textStyle: {}\n\t                },\n\t\n\t                // 阴影指示器样式设置\n\t                shadowStyle: {\n\t                    color: 'rgba(150,150,150,0.3)'\n\t                }\n\t            },\n\t            textStyle: {\n\t                color: '#fff',\n\t                fontSize: 14\n\t            }\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 563:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var TooltipContent = __webpack_require__(564);\n\t    var graphic = __webpack_require__(164);\n\t    var zrUtil = __webpack_require__(125);\n\t    var formatUtil = __webpack_require__(127);\n\t    var numberUtil = __webpack_require__(128);\n\t    var modelUtil = __webpack_require__(126);\n\t    var parsePercent = numberUtil.parsePercent;\n\t    var env = __webpack_require__(123);\n\t    var Model = __webpack_require__(133);\n\t\n\t    function dataEqual(a, b) {\n\t        if (!a || !b) {\n\t            return false;\n\t        }\n\t        var round = numberUtil.round;\n\t        return round(a[0]) === round(b[0])\n\t            && round(a[1]) === round(b[1]);\n\t    }\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeLineShape(x1, y1, x2, y2) {\n\t        return {\n\t            x1: x1,\n\t            y1: y1,\n\t            x2: x2,\n\t            y2: y2\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeRectShape(x, y, width, height) {\n\t        return {\n\t            x: x,\n\t            y: y,\n\t            width: width,\n\t            height: height\n\t        };\n\t    }\n\t\n\t    /**\n\t     * @inner\n\t     */\n\t    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n\t        return {\n\t            cx: cx,\n\t            cy: cy,\n\t            r0: r0,\n\t            r: r,\n\t            startAngle: startAngle,\n\t            endAngle: endAngle,\n\t            clockwise: true\n\t        };\n\t    }\n\t\n\t    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n\t        var width = el.clientWidth;\n\t        var height = el.clientHeight;\n\t        var gap = 20;\n\t\n\t        if (x + width + gap > viewWidth) {\n\t            x -= width + gap;\n\t        }\n\t        else {\n\t            x += gap;\n\t        }\n\t        if (y + height + gap > viewHeight) {\n\t            y -= height + gap;\n\t        }\n\t        else {\n\t            y += gap;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    function calcTooltipPosition(position, rect, dom) {\n\t        var domWidth = dom.clientWidth;\n\t        var domHeight = dom.clientHeight;\n\t        var gap = 5;\n\t        var x = 0;\n\t        var y = 0;\n\t        var rectWidth = rect.width;\n\t        var rectHeight = rect.height;\n\t        switch (position) {\n\t            case 'inside':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'top':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y - domHeight - gap;\n\t                break;\n\t            case 'bottom':\n\t                x = rect.x + rectWidth / 2 - domWidth / 2;\n\t                y = rect.y + rectHeight + gap;\n\t                break;\n\t            case 'left':\n\t                x = rect.x - domWidth - gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t                break;\n\t            case 'right':\n\t                x = rect.x + rectWidth + gap;\n\t                y = rect.y + rectHeight / 2 - domHeight / 2;\n\t        }\n\t        return [x, y];\n\t    }\n\t\n\t    /**\n\t     * @param  {string|Function|Array.<number>} positionExpr\n\t     * @param  {number} x Mouse x\n\t     * @param  {number} y Mouse y\n\t     * @param  {module:echarts/component/tooltip/TooltipContent} content\n\t     * @param  {Object|<Array.<Object>} params\n\t     * @param  {module:zrender/Element} el target element\n\t     * @param  {module:echarts/ExtensionAPI} api\n\t     * @return {Array.<number>}\n\t     */\n\t    function updatePosition(positionExpr, x, y, content, params, el, api) {\n\t        var viewWidth = api.getWidth();\n\t        var viewHeight = api.getHeight();\n\t\n\t        var rect = el && el.getBoundingRect().clone();\n\t        el && rect.applyTransform(el.transform);\n\t        if (typeof positionExpr === 'function') {\n\t            // Callback of position can be an array or a string specify the position\n\t            positionExpr = positionExpr([x, y], params, content.el, rect);\n\t        }\n\t\n\t        if (zrUtil.isArray(positionExpr)) {\n\t            x = parsePercent(positionExpr[0], viewWidth);\n\t            y = parsePercent(positionExpr[1], viewHeight);\n\t        }\n\t        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n\t        else if (typeof positionExpr === 'string' && el) {\n\t            var pos = calcTooltipPosition(\n\t                positionExpr, rect, content.el\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t        else {\n\t            var pos = refixTooltipPosition(\n\t                x, y, content.el, viewWidth, viewHeight\n\t            );\n\t            x = pos[0];\n\t            y = pos[1];\n\t        }\n\t\n\t        content.moveTo(x, y);\n\t    }\n\t\n\t    function ifSeriesSupportAxisTrigger(seriesModel) {\n\t        var coordSys = seriesModel.coordinateSystem;\n\t        var trigger = seriesModel.get('tooltip.trigger', true);\n\t        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n\t        return !(!coordSys\n\t            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n\t            || trigger === 'item');\n\t    }\n\t\n\t    __webpack_require__(122).extendComponentView({\n\t\n\t        type: 'tooltip',\n\t\n\t        _axisPointers: {},\n\t\n\t        init: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var tooltipContent = new TooltipContent(api.getDom(), api);\n\t            this._tooltipContent = tooltipContent;\n\t\n\t            api.on('showTip', this._manuallyShowTip, this);\n\t            api.on('hideTip', this._manuallyHideTip, this);\n\t        },\n\t\n\t        render: function (tooltipModel, ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t\n\t            // Reset\n\t            this.group.removeAll();\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._axisPointers = {};\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/component/tooltip/TooltipModel}\n\t             */\n\t            this._tooltipModel = tooltipModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/model/Global}\n\t             */\n\t            this._ecModel = ecModel;\n\t\n\t            /**\n\t             * @private\n\t             * @type {module:echarts/ExtensionAPI}\n\t             */\n\t            this._api = api;\n\t\n\t            /**\n\t             * @type {Object}\n\t             * @private\n\t             */\n\t            this._lastHover = {\n\t                // data\n\t                // payloadBatch\n\t            };\n\t\n\t            var tooltipContent = this._tooltipContent;\n\t            tooltipContent.update();\n\t            tooltipContent.enterable = tooltipModel.get('enterable');\n\t            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\t\n\t            /**\n\t             * @type {Object.<string, Array>}\n\t             */\n\t            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n\t                tooltipModel, ecModel\n\t            );\n\t\n\t            var crossText = this._crossText;\n\t            if (crossText) {\n\t                this.group.add(crossText);\n\t            }\n\t\n\t            var triggerOn = tooltipModel.get('triggerOn');\n\t\n\t            // Try to keep the tooltip show when refreshing\n\t            if (this._lastX != null\n\t                && this._lastY != null\n\t                // When user is willing to control tooltip totally using API,\n\t                // self._manuallyShowTip({x, y}) might cause tooltip hide,\n\t                // which is not expected.\n\t                && triggerOn !== 'none'\n\t            ) {\n\t                var self = this;\n\t                clearTimeout(this._refreshUpdateTimeout);\n\t                this._refreshUpdateTimeout = setTimeout(function () {\n\t                    // Show tip next tick after other charts are rendered\n\t                    // In case highlight action has wrong result\n\t                    // FIXME\n\t                    self._manuallyShowTip({\n\t                        x: self._lastX,\n\t                        y: self._lastY\n\t                    });\n\t                });\n\t            }\n\t\n\t            var zr = this._api.getZr();\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t\n\t            if (triggerOn === 'click') {\n\t                zr.on('click', this._tryShow, this);\n\t            }\n\t            else if (triggerOn === 'mousemove') {\n\t                zr.on('mousemove', this._mousemove, this);\n\t                zr.on('mouseout', this._hide, this);\n\t                zr.on('globalout', this._hide, this);\n\t            }\n\t            // else triggerOn is 'none', which enable user\n\t            // to control tooltip totally using API.\n\t        },\n\t\n\t        _mousemove: function (e) {\n\t            var showDelay = this._tooltipModel.get('showDelay');\n\t            var self = this;\n\t            clearTimeout(this._showTimeout);\n\t            if (showDelay > 0) {\n\t                this._showTimeout = setTimeout(function () {\n\t                    self._tryShow(e);\n\t                }, showDelay);\n\t            }\n\t            else {\n\t                this._tryShow(e);\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tip manually by\n\t         * dispatchAction({\n\t         *     type: 'showTip',\n\t         *     x: 10,\n\t         *     y: 10\n\t         * });\n\t         * Or\n\t         * dispatchAction({\n\t         *      type: 'showTip',\n\t         *      seriesIndex: 0,\n\t         *      dataIndex or dataIndexInside or name\n\t         * });\n\t         *\n\t         *  TODO Batch\n\t         */\n\t        _manuallyShowTip: function (event) {\n\t            // From self\n\t            if (event.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            var ecModel = this._ecModel;\n\t            var seriesIndex = event.seriesIndex;\n\t            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n\t            var api = this._api;\n\t\n\t            if (event.x == null || event.y == null) {\n\t                if (!seriesModel) {\n\t                    // Find the first series can use axis trigger\n\t                    ecModel.eachSeries(function (_series) {\n\t                        if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n\t                            seriesModel = _series;\n\t                        }\n\t                    });\n\t                }\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var dataIndex = modelUtil.queryDataIndex(data, event);\n\t\n\t                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n\t                        return;\n\t                    }\n\t\n\t                    var el = data.getItemGraphicEl(dataIndex);\n\t                    var cx;\n\t                    var cy;\n\t                    // Try to get the point in coordinate system\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    if (seriesModel.getTooltipPosition) {\n\t                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n\t                        cx = point[0];\n\t                        cy = point[1];\n\t                    }\n\t                    else if (coordSys && coordSys.dataToPoint) {\n\t                        var point = coordSys.dataToPoint(\n\t                            data.getValues(\n\t                                zrUtil.map(coordSys.dimensions, function (dim) {\n\t                                    return seriesModel.coordDimToDataDim(dim)[0];\n\t                                }), dataIndex, true\n\t                            )\n\t                        );\n\t                        cx = point && point[0];\n\t                        cy = point && point[1];\n\t                    }\n\t                    else if (el) {\n\t                        // Use graphic bounding rect\n\t                        var rect = el.getBoundingRect().clone();\n\t                        rect.applyTransform(el.transform);\n\t                        cx = rect.x + rect.width / 2;\n\t                        cy = rect.y + rect.height / 2;\n\t                    }\n\t\n\t                    if (cx != null && cy != null) {\n\t                        this._tryShow({\n\t                            offsetX: cx,\n\t                            offsetY: cy,\n\t                            position: event.position,\n\t                            target: el,\n\t                            event: {}\n\t                        });\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                var el = api.getZr().handler.findHover(event.x, event.y);\n\t                this._tryShow({\n\t                    offsetX: event.x,\n\t                    offsetY: event.y,\n\t                    position: event.position,\n\t                    target: el,\n\t                    event: {}\n\t                });\n\t            }\n\t        },\n\t\n\t        _manuallyHideTip: function (e) {\n\t            if (e.from === this.uid) {\n\t                return;\n\t            }\n\t\n\t            this._hide();\n\t        },\n\t\n\t        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n\t            // Prepare data for axis trigger\n\t            var seriesGroupByAxis = {};\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n\t                    var coordSys = seriesModel.coordinateSystem;\n\t                    var baseAxis;\n\t                    var key;\n\t\n\t                    // Only cartesian2d, polar and single support axis trigger\n\t                    if (coordSys.type === 'cartesian2d') {\n\t                        // FIXME `axisPointer.axis` is not baseAxis\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + baseAxis.index;\n\t                    }\n\t                    else if (coordSys.type === 'singleAxis') {\n\t                        baseAxis = coordSys.getAxis();\n\t                        key = baseAxis.dim + baseAxis.type;\n\t                    }\n\t                    else {\n\t                        baseAxis = coordSys.getBaseAxis();\n\t                        key = baseAxis.dim + coordSys.name;\n\t                    }\n\t\n\t                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n\t                        coordSys: [],\n\t                        series: []\n\t                    };\n\t                    seriesGroupByAxis[key].coordSys.push(coordSys);\n\t                    seriesGroupByAxis[key].series.push(seriesModel);\n\t                }\n\t            }, this);\n\t\n\t            return seriesGroupByAxis;\n\t        },\n\t\n\t        /**\n\t         * mousemove handler\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _tryShow: function (e) {\n\t            var el = e.target;\n\t            var tooltipModel = this._tooltipModel;\n\t            var globalTrigger = tooltipModel.get('trigger');\n\t            var ecModel = this._ecModel;\n\t            var api = this._api;\n\t\n\t            if (!tooltipModel) {\n\t                return;\n\t            }\n\t\n\t            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n\t            this._lastX = e.offsetX;\n\t            this._lastY = e.offsetY;\n\t\n\t            // Always show item tooltip if mouse is on the element with dataIndex\n\t            if (el && el.dataIndex != null) {\n\t                // Use dataModel in element if possible\n\t                // Used when mouseover on a element like markPoint or edge\n\t                // In which case, the data is not main data in series.\n\t                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n\t                var dataIndex = el.dataIndex;\n\t                var itemModel = dataModel.getData().getItemModel(dataIndex);\n\t                // Series or single data may use item trigger when global is axis trigger\n\t                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t                else {\n\t                    // Reset ticket\n\t                    this._ticket = '';\n\t                    // If either single data or series use item trigger\n\t                    this._hideAxisPointer();\n\t                    // Reset last hover and dispatch downplay action\n\t                    this._resetLastHover();\n\t\n\t                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n\t                }\n\t\n\t                api.dispatchAction({\n\t                    type: 'showTip',\n\t                    from: this.uid,\n\t                    dataIndexInside: el.dataIndex,\n\t                    seriesIndex: el.seriesIndex\n\t                });\n\t            }\n\t            // Tooltip provided directly. Like legend\n\t            else if (el && el.tooltip) {\n\t                var tooltipOpt = el.tooltip;\n\t                if (typeof tooltipOpt === 'string') {\n\t                    var content = tooltipOpt;\n\t                    tooltipOpt = {\n\t                        content: content,\n\t                        // Fixed formatter\n\t                        formatter: content\n\t                    };\n\t                }\n\t                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n\t                var defaultHtml = subTooltipModel.get('content');\n\t                var asyncTicket = Math.random();\n\t                this._showTooltipContent(\n\t                    // TODO params\n\t                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n\t                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n\t                );\n\t            }\n\t            else {\n\t                if (globalTrigger === 'item') {\n\t                    this._hide();\n\t                }\n\t                else {\n\t                    // Try show axis tooltip\n\t                    this._showAxisTooltip(tooltipModel, ecModel, e);\n\t                }\n\t\n\t                // Action of cross pointer\n\t                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n\t                if (tooltipModel.get('axisPointer.type') === 'cross') {\n\t                    api.dispatchAction({\n\t                        type: 'showTip',\n\t                        from: this.uid,\n\t                        x: e.offsetX,\n\t                        y: e.offsetY\n\t                    });\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis\n\t         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n\t         * @param {module:echarts/model/Global} ecModel\n\t         * @param {Object} e\n\t         * @private\n\t         */\n\t        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n\t            var axisPointerModel = tooltipModel.getModel('axisPointer');\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            if (axisPointerType === 'cross') {\n\t                var el = e.target;\n\t                if (el && el.dataIndex != null) {\n\t                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n\t                    var dataIndex = el.dataIndex;\n\t                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n\t                }\n\t            }\n\t\n\t            this._showAxisPointer();\n\t            var allNotShow = true;\n\t            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n\t                // Try show the axis pointer\n\t                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n\t                var coordSys = allCoordSys[0];\n\t\n\t                // If mouse position is not in the grid or polar\n\t                var point = [e.offsetX, e.offsetY];\n\t\n\t                if (!coordSys.containPoint(point)) {\n\t                    // Hide axis pointer\n\t                    this._hideAxisPointer(coordSys.name);\n\t                    return;\n\t                }\n\t\n\t                allNotShow = false;\n\t                // Make sure point is discrete on cateogry axis\n\t                var dimensions = coordSys.dimensions;\n\t                var value = coordSys.pointToData(point, true);\n\t                point = coordSys.dataToPoint(value);\n\t                var baseAxis = coordSys.getBaseAxis();\n\t                var axisType = axisPointerModel.get('axis');\n\t                if (axisType === 'auto') {\n\t                    axisType = baseAxis.dim;\n\t                }\n\t\n\t                var contentNotChange = false;\n\t                var lastHover = this._lastHover;\n\t                if (axisPointerType === 'cross') {\n\t                    // If hover data not changed\n\t                    // Possible when two axes are all category\n\t                    if (dataEqual(lastHover.data, value)) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value;\n\t                }\n\t                else {\n\t                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\t\n\t                    // If hover data not changed on the axis dimension\n\t                    if (lastHover.data === value[valIndex]) {\n\t                        contentNotChange = true;\n\t                    }\n\t                    lastHover.data = value[valIndex];\n\t                }\n\t\n\t                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n\t                    this._showCartesianPointer(\n\t                        axisPointerModel, coordSys, axisType, point\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'polar' && !contentNotChange) {\n\t                    this._showPolarPointer(\n\t                        axisPointerModel, coordSys, axisType, point\n\t                    );\n\t                }\n\t                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n\t                    this._showSinglePointer(\n\t                        axisPointerModel, coordSys, axisType, point\n\t                    );\n\t                }\n\t\n\t                if (axisPointerType !== 'cross') {\n\t                    this._dispatchAndShowSeriesTooltipContent(\n\t                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n\t                    );\n\t                }\n\t            }, this);\n\t\n\t            if (!this._tooltipModel.get('show')) {\n\t                this._hideAxisPointer();\n\t            }\n\t\n\t            if (allNotShow) {\n\t                this._hide();\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of cartesian coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         * @private\n\t         */\n\t        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var baseAxis = cartesian.getBaseAxis();\n\t            var moveAnimation = axisPointerType !== 'cross'\n\t                && baseAxis.type === 'category'\n\t                && baseAxis.getBandWidth() > 20;\n\t\n\t            if (axisPointerType === 'cross') {\n\t                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n\t                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\t\n\t                this._updateCrossText(cartesian, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n\t                var otherExtent = otherAxis.getGlobalExtent();\n\t\n\t                if (cartesian.type === 'cartesian2d') {\n\t                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n\t                        axisType, point, otherExtent\n\t                    );\n\t                }\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridLine(axisType, point, otherExtent) {\n\t                var targetShape = axisType === 'x'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                graphic.subPixelOptimizeLine({\n\t                    shape: targetShape,\n\t                    style: pointerEl.style\n\t                });\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveGridShadow(axisType, point, otherExtent) {\n\t                var axis = cartesian.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t                var span = otherExtent[1] - otherExtent[0];\n\t                var targetShape = axisType === 'x'\n\t                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n\t                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    cartesian, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _showSinglePointer: function (axisPointerModel, single, axisType, point) {\n\t            var self = this;\n\t            var axisPointerType = axisPointerModel.get('type');\n\t            var moveAnimation = axisPointerType !== 'cross' && single.getBaseAxis().type === 'category';\n\t            var rect = single.getRect();\n\t            var otherExtent = [rect.y, rect.y + rect.height];\n\t\n\t            moveSingleLine(axisType, point, otherExtent);\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function moveSingleLine(axisType, point, otherExtent) {\n\t                var axis = single.getAxis();\n\t                var orient = axis.orient;\n\t\n\t                var targetShape = orient === 'horizontal'\n\t                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n\t                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    single, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on axis of polar coordinate\n\t         * @param {module:echarts/model/Model} axisPointerModel\n\t         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n\t         * @param {string} axisType\n\t         * @param {Array.<number>} point\n\t         */\n\t        _showPolarPointer: function (axisPointerModel, polar, axisType, point) {\n\t            var self = this;\n\t\n\t            var axisPointerType = axisPointerModel.get('type');\n\t\n\t            var angleAxis = polar.getAngleAxis();\n\t            var radiusAxis = polar.getRadiusAxis();\n\t\n\t            var moveAnimation = axisPointerType !== 'cross'\n\t                && polar.getBaseAxis().type === 'category';\n\t\n\t            if (axisPointerType === 'cross') {\n\t                movePolarLine('angle', point, radiusAxis.getExtent());\n\t                movePolarLine('radius', point, angleAxis.getExtent());\n\t\n\t                this._updateCrossText(polar, point, axisPointerModel);\n\t            }\n\t            else {\n\t                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n\t                var otherExtent = otherAxis.getExtent();\n\t\n\t                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n\t                    axisType, point, otherExtent\n\t                );\n\t            }\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarLine(axisType, point, otherExtent) {\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                if (axisType === 'angle') {\n\t                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n\t                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n\t                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n\t                }\n\t                else {\n\t                    targetShape = {\n\t                        cx: polar.cx,\n\t                        cy: polar.cy,\n\t                        r: mouseCoord[0]\n\t                    };\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t\n\t            /**\n\t             * @inner\n\t             */\n\t            function movePolarShadow(axisType, point, otherExtent) {\n\t                var axis = polar.getAxis(axisType);\n\t                var bandWidth = axis.getBandWidth();\n\t\n\t                var mouseCoord = polar.pointToCoord(point);\n\t\n\t                var targetShape;\n\t\n\t                var radian = Math.PI / 180;\n\t\n\t                if (axisType === 'angle') {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        otherExtent[0], otherExtent[1],\n\t                        // In ECharts y is negative if angle is positive\n\t                        (-mouseCoord[1] - bandWidth / 2) * radian,\n\t                        (-mouseCoord[1] + bandWidth / 2) * radian\n\t                    );\n\t                }\n\t                else {\n\t                    targetShape = makeSectorShape(\n\t                        polar.cx, polar.cy,\n\t                        mouseCoord[0] - bandWidth / 2,\n\t                        mouseCoord[0] + bandWidth / 2,\n\t                        0, Math.PI * 2\n\t                    );\n\t                }\n\t\n\t                var pointerEl = self._getPointerElement(\n\t                    polar, axisPointerModel, axisType, targetShape\n\t                );\n\t                moveAnimation\n\t                    ? graphic.updateProps(pointerEl, {\n\t                        shape: targetShape\n\t                    }, axisPointerModel)\n\t                    :  pointerEl.attr({\n\t                        shape: targetShape\n\t                    });\n\t            }\n\t        },\n\t\n\t        _updateCrossText: function (coordSys, point, axisPointerModel) {\n\t            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n\t            var textStyleModel = crossStyleModel.getModel('textStyle');\n\t\n\t            var tooltipModel = this._tooltipModel;\n\t\n\t            var text = this._crossText;\n\t            if (!text) {\n\t                text = this._crossText = new graphic.Text({\n\t                    style: {\n\t                        textAlign: 'left',\n\t                        textVerticalAlign: 'bottom'\n\t                    }\n\t                });\n\t                this.group.add(text);\n\t            }\n\t\n\t            var value = coordSys.pointToData(point);\n\t\n\t            var dims = coordSys.dimensions;\n\t            value = zrUtil.map(value, function (val, idx) {\n\t                var axis = coordSys.getAxis(dims[idx]);\n\t                if (axis.type === 'category' || axis.type === 'time') {\n\t                    val = axis.scale.getLabel(val);\n\t                }\n\t                else {\n\t                    val = formatUtil.addCommas(\n\t                        val.toFixed(axis.getPixelPrecision())\n\t                    );\n\t                }\n\t                return val;\n\t            });\n\t\n\t            text.setStyle({\n\t                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n\t                textFont: textStyleModel.getFont(),\n\t                text: value.join(', '),\n\t                x: point[0] + 5,\n\t                y: point[1] - 5\n\t            });\n\t            text.z = tooltipModel.get('z');\n\t            text.zlevel = tooltipModel.get('zlevel');\n\t        },\n\t\n\t        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n\t            var tooltipModel = this._tooltipModel;\n\t            var z = tooltipModel.get('z');\n\t            var zlevel = tooltipModel.get('zlevel');\n\t            var axisPointers = this._axisPointers;\n\t            var coordSysName = coordSys.name;\n\t            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n\t            if (axisPointers[coordSysName][axisType]) {\n\t                return axisPointers[coordSysName][axisType];\n\t            }\n\t\n\t            // Create if not exists\n\t            var pointerType = pointerModel.get('type');\n\t            var styleModel = pointerModel.getModel(pointerType + 'Style');\n\t            var isShadow = pointerType === 'shadow';\n\t            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\t\n\t            var elementType = coordSys.type === 'polar'\n\t                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n\t                : (isShadow ? 'Rect' : 'Line');\n\t\n\t            isShadow ? (style.stroke = null) : (style.fill = null);\n\t\n\t            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n\t                style: style,\n\t                z: z,\n\t                zlevel: zlevel,\n\t                silent: true,\n\t                shape: initShape\n\t            });\n\t\n\t            this.group.add(el);\n\t            return el;\n\t        },\n\t\n\t        /**\n\t         * Dispatch actions and show tooltip on series\n\t         * @param {Array.<module:echarts/model/Series>} seriesList\n\t         * @param {Array.<number>} point\n\t         * @param {Array.<number>} value\n\t         * @param {boolean} contentNotChange\n\t         * @param {Array.<number>|string|Function} [positionExpr]\n\t         */\n\t        _dispatchAndShowSeriesTooltipContent: function (\n\t            coordSys, seriesList, point, value, contentNotChange, positionExpr\n\t        ) {\n\t\n\t            var rootTooltipModel = this._tooltipModel;\n\t\n\t            var baseAxis = coordSys.getBaseAxis();\n\t            var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\t\n\t            var payloadBatch = zrUtil.map(seriesList, function (series) {\n\t                return {\n\t                    seriesIndex: series.seriesIndex,\n\t                    dataIndexInside: series.getAxisTooltipDataIndex\n\t                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n\t                        : series.getData().indexOfNearest(\n\t                            series.coordDimToDataDim(baseAxis.dim)[0],\n\t                            value[baseDimIndex],\n\t                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n\t                            false, baseAxis.type === 'category' ? 0.5 : null\n\t                        )\n\t                };\n\t            });\n\t\n\t            var lastHover = this._lastHover;\n\t            var api = this._api;\n\t            // Dispatch downplay action\n\t            if (lastHover.payloadBatch && !contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Dispatch highlight action\n\t            if (!contentNotChange) {\n\t                api.dispatchAction({\n\t                    type: 'highlight',\n\t                    batch: payloadBatch\n\t                });\n\t                lastHover.payloadBatch = payloadBatch;\n\t            }\n\t            // Dispatch showTip action\n\t            api.dispatchAction({\n\t                type: 'showTip',\n\t                dataIndexInside: payloadBatch[0].dataIndexInside,\n\t                seriesIndex: payloadBatch[0].seriesIndex,\n\t                from: this.uid\n\t            });\n\t\n\t            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n\t                var paramsList = zrUtil.map(seriesList, function (series, index) {\n\t                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n\t                });\n\t\n\t                if (!contentNotChange) {\n\t                    // Update html content\n\t                    var firstDataIndex = payloadBatch[0].dataIndexInside;\n\t\n\t                    // Default tooltip content\n\t                    // FIXME\n\t                    // (1) shold be the first data which has name?\n\t                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n\t                    var firstLine = baseAxis.type === 'time'\n\t                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n\t                        : seriesList[0].getData().getName(firstDataIndex);\n\t                    var defaultHtml = (firstLine ? firstLine + '<br />' : '')\n\t                        + zrUtil.map(seriesList, function (series, index) {\n\t                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n\t                        }).join('<br />');\n\t\n\t                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\t\n\t                    this._showTooltipContent(\n\t                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n\t                        point[0], point[1], positionExpr, null, api\n\t                    );\n\t                }\n\t                else {\n\t                    updatePosition(\n\t                        positionExpr || rootTooltipModel.get('position'), point[0], point[1],\n\t                        this._tooltipContent, paramsList, null, api\n\t                    );\n\t                }\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show tooltip on item\n\t         * @param {module:echarts/model/Series} seriesModel\n\t         * @param {number} dataIndex\n\t         * @param {string} dataType\n\t         * @param {Object} e\n\t         */\n\t        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n\t            // FIXME Graph data\n\t            var api = this._api;\n\t            var data = seriesModel.getData(dataType);\n\t            var itemModel = data.getItemModel(dataIndex);\n\t\n\t            var tooltipOpt = itemModel.get('tooltip', true);\n\t            if (typeof tooltipOpt === 'string') {\n\t                // In each data item tooltip can be simply write:\n\t                // {\n\t                //  value: 10,\n\t                //  tooltip: 'Something you need to know'\n\t                // }\n\t                var tooltipContent = tooltipOpt;\n\t                tooltipOpt = {\n\t                    formatter: tooltipContent\n\t                };\n\t            }\n\t            var rootTooltipModel = this._tooltipModel;\n\t            var seriesTooltipModel = seriesModel.getModel(\n\t                'tooltip', rootTooltipModel\n\t            );\n\t            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\t\n\t            var params = seriesModel.getDataParams(dataIndex, dataType);\n\t            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\t\n\t            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\t\n\t            this._showTooltipContent(\n\t                tooltipModel, defaultHtml, params, asyncTicket,\n\t                e.offsetX, e.offsetY, e.position, e.target, api\n\t            );\n\t        },\n\t\n\t        _showTooltipContent: function (\n\t            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n\t        ) {\n\t            // Reset ticket\n\t            this._ticket = '';\n\t\n\t            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n\t                var tooltipContent = this._tooltipContent;\n\t\n\t                var formatter = tooltipModel.get('formatter');\n\t                positionExpr = positionExpr || tooltipModel.get('position');\n\t                var html = defaultHtml;\n\t\n\t                if (formatter) {\n\t                    if (typeof formatter === 'string') {\n\t                        html = formatUtil.formatTpl(formatter, params);\n\t                    }\n\t                    else if (typeof formatter === 'function') {\n\t                        var self = this;\n\t                        var ticket = asyncTicket;\n\t                        var callback = function (cbTicket, html) {\n\t                            if (cbTicket === self._ticket) {\n\t                                tooltipContent.setContent(html);\n\t\n\t                                updatePosition(\n\t                                    positionExpr, x, y,\n\t                                    tooltipContent, params, target, api\n\t                                );\n\t                            }\n\t                        };\n\t                        self._ticket = ticket;\n\t                        html = formatter(params, ticket, callback);\n\t                    }\n\t                }\n\t\n\t                tooltipContent.show(tooltipModel);\n\t                tooltipContent.setContent(html);\n\t\n\t                updatePosition(\n\t                    positionExpr, x, y,\n\t                    tooltipContent, params, target, api\n\t                );\n\t            }\n\t        },\n\t\n\t        /**\n\t         * Show axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _showAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.show();\n\t                });\n\t            }\n\t            else {\n\t                this.group.eachChild(function (child) {\n\t                    child.show();\n\t                });\n\t                this.group.show();\n\t            }\n\t        },\n\t\n\t        _resetLastHover: function () {\n\t            var lastHover = this._lastHover;\n\t            if (lastHover.payloadBatch) {\n\t                this._api.dispatchAction({\n\t                    type: 'downplay',\n\t                    batch: lastHover.payloadBatch\n\t                });\n\t            }\n\t            // Reset lastHover\n\t            this._lastHover = {};\n\t        },\n\t        /**\n\t         * Hide axis pointer\n\t         * @param {string} [coordSysName]\n\t         */\n\t        _hideAxisPointer: function (coordSysName) {\n\t            if (coordSysName) {\n\t                var axisPointers = this._axisPointers[coordSysName];\n\t                axisPointers && zrUtil.each(axisPointers, function (el) {\n\t                    el.hide();\n\t                });\n\t            }\n\t            else {\n\t                if (this.group.children().length) {\n\t                    this.group.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        _hide: function () {\n\t            clearTimeout(this._showTimeout);\n\t\n\t            this._hideAxisPointer();\n\t            this._resetLastHover();\n\t            if (!this._alwaysShowContent) {\n\t                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n\t            }\n\t\n\t            this._api.dispatchAction({\n\t                type: 'hideTip',\n\t                from: this.uid\n\t            });\n\t\n\t            this._lastX = this._lastY = null;\n\t        },\n\t\n\t        dispose: function (ecModel, api) {\n\t            if (env.node) {\n\t                return;\n\t            }\n\t            var zr = api.getZr();\n\t            this._tooltipContent.hide();\n\t\n\t            zr.off('click', this._tryShow);\n\t            zr.off('mousemove', this._mousemove);\n\t            zr.off('mouseout', this._hide);\n\t            zr.off('globalout', this._hide);\n\t\n\t            api.off('showTip', this._manuallyShowTip);\n\t            api.off('hideTip', this._manuallyHideTip);\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 564:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @module echarts/component/tooltip/TooltipContent\n\t */\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var zrColor = __webpack_require__(160);\n\t    var eventUtil = __webpack_require__(208);\n\t    var formatUtil = __webpack_require__(127);\n\t    var each = zrUtil.each;\n\t    var toCamelCase = formatUtil.toCamelCase;\n\t    var env = __webpack_require__(123);\n\t\n\t    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\t\n\t    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\t\n\t    /**\n\t     * @param {number} duration\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleTransition(duration) {\n\t        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n\t        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n\t                            + 'top ' + duration + 's ' + transitionCurve;\n\t        return zrUtil.map(vendors, function (vendorPrefix) {\n\t            return vendorPrefix + 'transition:' + transitionText;\n\t        }).join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} textStyle\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleFont(textStyleModel) {\n\t        var cssText = [];\n\t\n\t        var fontSize = textStyleModel.get('fontSize');\n\t        var color = textStyleModel.getTextColor();\n\t\n\t        color && cssText.push('color:' + color);\n\t\n\t        cssText.push('font:' + textStyleModel.getFont());\n\t\n\t        fontSize &&\n\t            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\t\n\t        each(['decoration', 'align'], function (name) {\n\t            var val = textStyleModel.get(name);\n\t            val && cssText.push('text-' + name + ':' + val);\n\t        });\n\t\n\t        return cssText.join(';');\n\t    }\n\t\n\t    /**\n\t     * @param {Object} tooltipModel\n\t     * @return {string}\n\t     * @inner\n\t     */\n\t    function assembleCssText(tooltipModel) {\n\t\n\t        tooltipModel = tooltipModel;\n\t\n\t        var cssText = [];\n\t\n\t        var transitionDuration = tooltipModel.get('transitionDuration');\n\t        var backgroundColor = tooltipModel.get('backgroundColor');\n\t        var textStyleModel = tooltipModel.getModel('textStyle');\n\t        var padding = tooltipModel.get('padding');\n\t\n\t        // Animation transition\n\t        transitionDuration &&\n\t            cssText.push(assembleTransition(transitionDuration));\n\t\n\t        if (backgroundColor) {\n\t            if (env.canvasSupported) {\n\t                cssText.push('background-Color:' + backgroundColor);\n\t            }\n\t            else {\n\t                // for ie\n\t                cssText.push(\n\t                    'background-Color:#' + zrColor.toHex(backgroundColor)\n\t                );\n\t                cssText.push('filter:alpha(opacity=70)');\n\t            }\n\t        }\n\t\n\t        // Border style\n\t        each(['width', 'color', 'radius'], function (name) {\n\t            var borderName = 'border-' + name;\n\t            var camelCase = toCamelCase(borderName);\n\t            var val = tooltipModel.get(camelCase);\n\t            val != null &&\n\t                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n\t        });\n\t\n\t        // Text style\n\t        cssText.push(assembleFont(textStyleModel));\n\t\n\t        // Padding\n\t        if (padding != null) {\n\t            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n\t        }\n\t\n\t        return cssText.join(';') + ';';\n\t    }\n\t\n\t    /**\n\t     * @alias module:echarts/component/tooltip/TooltipContent\n\t     * @constructor\n\t     */\n\t    function TooltipContent(container, api) {\n\t        var el = document.createElement('div');\n\t        var zr = api.getZr();\n\t\n\t        this.el = el;\n\t\n\t        this._x = api.getWidth() / 2;\n\t        this._y = api.getHeight() / 2;\n\t\n\t        container.appendChild(el);\n\t\n\t        this._container = container;\n\t\n\t        this._show = false;\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        this._hideTimeout;\n\t\n\t        var self = this;\n\t        el.onmouseenter = function () {\n\t            // clear the timeout in hideLater and keep showing tooltip\n\t            if (self.enterable) {\n\t                clearTimeout(self._hideTimeout);\n\t                self._show = true;\n\t            }\n\t            self._inContent = true;\n\t        };\n\t        el.onmousemove = function (e) {\n\t            e = e || window.event;\n\t            if (!self.enterable) {\n\t                // Try trigger zrender event to avoid mouse\n\t                // in and out shape too frequently\n\t                var handler = zr.handler;\n\t                eventUtil.normalizeEvent(container, e, true);\n\t                handler.dispatch('mousemove', e);\n\t            }\n\t        };\n\t        el.onmouseleave = function () {\n\t            if (self.enterable) {\n\t                if (self._show) {\n\t                    self.hideLater(self._hideDelay);\n\t                }\n\t            }\n\t            self._inContent = false;\n\t        };\n\t\n\t        compromiseMobile(el, container);\n\t    }\n\t\n\t    function compromiseMobile(tooltipContentEl, container) {\n\t        // Prevent default behavior on mobile. For example,\n\t        // default pinch gesture will cause browser zoom.\n\t        // We do not preventing event on tooltip content el,\n\t        // because user may need customization in tooltip el.\n\t        eventUtil.addEventListener(container, 'touchstart', preventDefault);\n\t        eventUtil.addEventListener(container, 'touchmove', preventDefault);\n\t        eventUtil.addEventListener(container, 'touchend', preventDefault);\n\t\n\t        function preventDefault(e) {\n\t            if (!contains(e.target)) {\n\t                e.preventDefault();\n\t            }\n\t        }\n\t\n\t        function contains(targetEl) {\n\t            while (targetEl && targetEl !== container) {\n\t                if (targetEl === tooltipContentEl) {\n\t                    return true;\n\t                }\n\t                targetEl = targetEl.parentNode;\n\t            }\n\t        }\n\t    }\n\t\n\t    TooltipContent.prototype = {\n\t\n\t        constructor: TooltipContent,\n\t\n\t        enterable: true,\n\t\n\t        /**\n\t         * Update when tooltip is rendered\n\t         */\n\t        update: function () {\n\t            var container = this._container;\n\t            var stl = container.currentStyle\n\t                || document.defaultView.getComputedStyle(container);\n\t            var domStyle = container.style;\n\t            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n\t                domStyle.position = 'relative';\n\t            }\n\t            // Hide the tooltip\n\t            // PENDING\n\t            // this.hide();\n\t        },\n\t\n\t        show: function (tooltipModel) {\n\t            clearTimeout(this._hideTimeout);\n\t            var el = this.el;\n\t\n\t            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n\t                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n\t                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n\t                + (tooltipModel.get('extraCssText') || '');\n\t\n\t            el.style.display = el.innerHTML ?  'block' : 'none';\n\t\n\t            this._show = true;\n\t        },\n\t\n\t        setContent: function (content) {\n\t            var el = this.el;\n\t            el.innerHTML = content;\n\t            el.style.display = content ? 'block' : 'none';\n\t        },\n\t\n\t        moveTo: function (x, y) {\n\t            var style = this.el.style;\n\t            style.left = x + 'px';\n\t            style.top = y + 'px';\n\t\n\t            this._x = x;\n\t            this._y = y;\n\t        },\n\t\n\t        hide: function () {\n\t            this.el.style.display = 'none';\n\t            this._show = false;\n\t        },\n\t\n\t        // showLater: function ()\n\t\n\t        hideLater: function (time) {\n\t            if (this._show && !(this._inContent && this.enterable)) {\n\t                if (time) {\n\t                    this._hideDelay = time;\n\t                    // Set show false to avoid invoke hideLater mutiple times\n\t                    this._show = false;\n\t                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n\t                }\n\t                else {\n\t                    this.hide();\n\t                }\n\t            }\n\t        },\n\t\n\t        isShow: function () {\n\t            return this._show;\n\t        }\n\t    };\n\t\n\t    module.exports = TooltipContent;\n\n\n/***/ },\n\n/***/ 565:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var echarts = __webpack_require__(122);\n\t    var graphic = __webpack_require__(164);\n\t    var layout = __webpack_require__(142);\n\t\n\t    // Model\n\t    echarts.extendComponentModel({\n\t\n\t        type: 'title',\n\t\n\t        layoutMode: {type: 'box', ignoreSize: true},\n\t\n\t        defaultOption: {\n\t            // 一级层叠\n\t            zlevel: 0,\n\t            // 二级层叠\n\t            z: 6,\n\t            show: true,\n\t\n\t            text: '',\n\t            // 超链接跳转\n\t            // link: null,\n\t            // 仅支持self | blank\n\t            target: 'blank',\n\t            subtext: '',\n\t\n\t            // 超链接跳转\n\t            // sublink: null,\n\t            // 仅支持self | blank\n\t            subtarget: 'blank',\n\t\n\t            // 'center' ¦ 'left' ¦ 'right'\n\t            // ¦ {number}（x坐标，单位px）\n\t            left: 0,\n\t            // 'top' ¦ 'bottom' ¦ 'center'\n\t            // ¦ {number}（y坐标，单位px）\n\t            top: 0,\n\t\n\t            // 水平对齐\n\t            // 'auto' | 'left' | 'right' | 'center'\n\t            // 默认根据 left 的位置判断是左对齐还是右对齐\n\t            // textAlign: null\n\t            //\n\t            // 垂直对齐\n\t            // 'auto' | 'top' | 'bottom' | 'middle'\n\t            // 默认根据 top 位置判断是上对齐还是下对齐\n\t            // textBaseline: null\n\t\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t\n\t            // 标题边框颜色\n\t            borderColor: '#ccc',\n\t\n\t            // 标题边框线宽，单位px，默认为0（无边框）\n\t            borderWidth: 0,\n\t\n\t            // 标题内边距，单位px，默认各方向内边距为5，\n\t            // 接受数组分别设定上右下左边距，同css\n\t            padding: 5,\n\t\n\t            // 主副标题纵向间隔，单位px，默认为10，\n\t            itemGap: 10,\n\t            textStyle: {\n\t                fontSize: 18,\n\t                fontWeight: 'bolder',\n\t                color: '#333'\n\t            },\n\t            subtextStyle: {\n\t                color: '#aaa'\n\t            }\n\t        }\n\t    });\n\t\n\t    // View\n\t    echarts.extendComponentView({\n\t\n\t        type: 'title',\n\t\n\t        render: function (titleModel, ecModel, api) {\n\t            this.group.removeAll();\n\t\n\t            if (!titleModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var group = this.group;\n\t\n\t            var textStyleModel = titleModel.getModel('textStyle');\n\t            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\t\n\t            var textAlign = titleModel.get('textAlign');\n\t            var textBaseline = titleModel.get('textBaseline');\n\t\n\t            var textEl = new graphic.Text({\n\t                style: {\n\t                    text: titleModel.get('text'),\n\t                    textFont: textStyleModel.getFont(),\n\t                    fill: textStyleModel.getTextColor()\n\t                },\n\t                z2: 10\n\t            });\n\t\n\t            var textRect = textEl.getBoundingRect();\n\t\n\t            var subText = titleModel.get('subtext');\n\t            var subTextEl = new graphic.Text({\n\t                style: {\n\t                    text: subText,\n\t                    textFont: subtextStyleModel.getFont(),\n\t                    fill: subtextStyleModel.getTextColor(),\n\t                    y: textRect.height + titleModel.get('itemGap'),\n\t                    textBaseline: 'top'\n\t                },\n\t                z2: 10\n\t            });\n\t\n\t            var link = titleModel.get('link');\n\t            var sublink = titleModel.get('sublink');\n\t\n\t            textEl.silent = !link;\n\t            subTextEl.silent = !sublink;\n\t\n\t            if (link) {\n\t                textEl.on('click', function () {\n\t                    window.open(link, '_' + titleModel.get('target'));\n\t                });\n\t            }\n\t            if (sublink) {\n\t                subTextEl.on('click', function () {\n\t                    window.open(sublink, '_' + titleModel.get('subtarget'));\n\t                });\n\t            }\n\t\n\t            group.add(textEl);\n\t            subText && group.add(subTextEl);\n\t            // If no subText, but add subTextEl, there will be an empty line.\n\t\n\t            var groupRect = group.getBoundingRect();\n\t            var layoutOption = titleModel.getBoxLayoutParams();\n\t            layoutOption.width = groupRect.width;\n\t            layoutOption.height = groupRect.height;\n\t            var layoutRect = layout.getLayoutRect(\n\t                layoutOption, {\n\t                    width: api.getWidth(),\n\t                    height: api.getHeight()\n\t                }, titleModel.get('padding')\n\t            );\n\t            // Adjust text align based on position\n\t            if (!textAlign) {\n\t                // Align left if title is on the left. center and right is same\n\t                textAlign = titleModel.get('left') || titleModel.get('right');\n\t                if (textAlign === 'middle') {\n\t                    textAlign = 'center';\n\t                }\n\t                // Adjust layout by text align\n\t                if (textAlign === 'right') {\n\t                    layoutRect.x += layoutRect.width;\n\t                }\n\t                else if (textAlign === 'center') {\n\t                    layoutRect.x += layoutRect.width / 2;\n\t                }\n\t            }\n\t            if (!textBaseline) {\n\t                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n\t                if (textBaseline === 'center') {\n\t                    textBaseline = 'middle';\n\t                }\n\t                if (textBaseline === 'bottom') {\n\t                    layoutRect.y += layoutRect.height;\n\t                }\n\t                else if (textBaseline === 'middle') {\n\t                    layoutRect.y += layoutRect.height / 2;\n\t                }\n\t\n\t                textBaseline = textBaseline || 'top';\n\t            }\n\t\n\t            group.attr('position', [layoutRect.x, layoutRect.y]);\n\t            var alignStyle = {\n\t                textAlign: textAlign,\n\t                textVerticalAlign: textBaseline\n\t            };\n\t            textEl.setStyle(alignStyle);\n\t            subTextEl.setStyle(alignStyle);\n\t\n\t            // Render background\n\t            // Get groupRect again because textAlign has been changed\n\t            groupRect = group.getBoundingRect();\n\t            var padding = layoutRect.margin;\n\t            var style = titleModel.getItemStyle(['color', 'opacity']);\n\t            style.fill = titleModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                shape: {\n\t                    x: groupRect.x - padding[3],\n\t                    y: groupRect.y - padding[0],\n\t                    width: groupRect.width + padding[1] + padding[3],\n\t                    height: groupRect.height + padding[0] + padding[2]\n\t                },\n\t                style: style,\n\t                silent: true\n\t            });\n\t            graphic.subPixelOptimizeRect(rect);\n\t\n\t            group.add(rect);\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 566:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Legend component entry file8\n\t */\n\t\n\t\n\t    __webpack_require__(567);\n\t    __webpack_require__(568);\n\t    __webpack_require__(569);\n\t\n\t    var echarts = __webpack_require__(122);\n\t    // Series Filter\n\t    echarts.registerProcessor(__webpack_require__(571));\n\n\n/***/ },\n\n/***/ 567:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var Model = __webpack_require__(133);\n\t\n\t    var LegendModel = __webpack_require__(122).extendComponentModel({\n\t\n\t        type: 'legend',\n\t\n\t        dependencies: ['series'],\n\t\n\t        layoutMode: {\n\t            type: 'box',\n\t            ignoreSize: true\n\t        },\n\t\n\t        init: function (option, parentModel, ecModel) {\n\t            this.mergeDefaultAndTheme(option, ecModel);\n\t\n\t            option.selected = option.selected || {};\n\t        },\n\t\n\t        mergeOption: function (option) {\n\t            LegendModel.superCall(this, 'mergeOption', option);\n\t        },\n\t\n\t        optionUpdated: function () {\n\t            this._updateData(this.ecModel);\n\t\n\t            var legendData = this._data;\n\t\n\t            // If selectedMode is single, try to select one\n\t            if (legendData[0] && this.get('selectedMode') === 'single') {\n\t                var hasSelected = false;\n\t                // If has any selected in option.selected\n\t                for (var i = 0; i < legendData.length; i++) {\n\t                    var name = legendData[i].get('name');\n\t                    if (this.isSelected(name)) {\n\t                        // Force to unselect others\n\t                        this.select(name);\n\t                        hasSelected = true;\n\t                        break;\n\t                    }\n\t                }\n\t                // Try select the first if selectedMode is single\n\t                !hasSelected && this.select(legendData[0].get('name'));\n\t            }\n\t        },\n\t\n\t        _updateData: function (ecModel) {\n\t            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n\t                // Can be string or number\n\t                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n\t                    dataItem = {\n\t                        name: dataItem\n\t                    };\n\t                }\n\t                return new Model(dataItem, this, this.ecModel);\n\t            }, this);\n\t            this._data = legendData;\n\t\n\t            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n\t                return series.name;\n\t            });\n\t            ecModel.eachSeries(function (seriesModel) {\n\t                if (seriesModel.legendDataProvider) {\n\t                    var data = seriesModel.legendDataProvider();\n\t                    availableNames = availableNames.concat(data.mapArray(data.getName));\n\t                }\n\t            });\n\t            /**\n\t             * @type {Array.<string>}\n\t             * @private\n\t             */\n\t            this._availableNames = availableNames;\n\t        },\n\t\n\t        /**\n\t         * @return {Array.<module:echarts/model/Model>}\n\t         */\n\t        getData: function () {\n\t            return this._data;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        select: function (name) {\n\t            var selected = this.option.selected;\n\t            var selectedMode = this.get('selectedMode');\n\t            if (selectedMode === 'single') {\n\t                var data = this._data;\n\t                zrUtil.each(data, function (dataItem) {\n\t                    selected[dataItem.get('name')] = false;\n\t                });\n\t            }\n\t            selected[name] = true;\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        unSelect: function (name) {\n\t            if (this.get('selectedMode') !== 'single') {\n\t                this.option.selected[name] = false;\n\t            }\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        toggleSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            // Default is true\n\t            if (!selected.hasOwnProperty(name)) {\n\t                selected[name] = true;\n\t            }\n\t            this[selected[name] ? 'unSelect' : 'select'](name);\n\t        },\n\t\n\t        /**\n\t         * @param {string} name\n\t         */\n\t        isSelected: function (name) {\n\t            var selected = this.option.selected;\n\t            return !(selected.hasOwnProperty(name) && !selected[name])\n\t                && zrUtil.indexOf(this._availableNames, name) >= 0;\n\t        },\n\t\n\t        defaultOption: {\n\t            // 一级层叠\n\t            zlevel: 0,\n\t            // 二级层叠\n\t            z: 4,\n\t            show: true,\n\t\n\t            // 布局方式，默认为水平布局，可选为：\n\t            // 'horizontal' | 'vertical'\n\t            orient: 'horizontal',\n\t\n\t            left: 'center',\n\t            // right: 'center',\n\t\n\t            top: 'top',\n\t            // bottom: 'top',\n\t\n\t            // 水平对齐\n\t            // 'auto' | 'left' | 'right'\n\t            // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n\t            align: 'auto',\n\t\n\t            backgroundColor: 'rgba(0,0,0,0)',\n\t            // 图例边框颜色\n\t            borderColor: '#ccc',\n\t            // 图例边框线宽，单位px，默认为0（无边框）\n\t            borderWidth: 0,\n\t            // 图例内边距，单位px，默认各方向内边距为5，\n\t            // 接受数组分别设定上右下左边距，同css\n\t            padding: 5,\n\t            // 各个item之间的间隔，单位px，默认为10，\n\t            // 横向布局时为水平间隔，纵向布局时为纵向间隔\n\t            itemGap: 10,\n\t            // 图例图形宽度\n\t            itemWidth: 25,\n\t            // 图例图形高度\n\t            itemHeight: 14,\n\t\n\t            // 图例关闭时候的颜色\n\t            inactiveColor: '#ccc',\n\t\n\t            textStyle: {\n\t                // 图例文字颜色\n\t                color: '#333'\n\t            },\n\t            // formatter: '',\n\t            // 选择模式，默认开启图例开关\n\t            selectedMode: true,\n\t            // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n\t            // selected: null,\n\t            // 图例内容（详见legend.data，数组中每一项代表一个item\n\t            // data: [],\n\t\n\t            // Tooltip 相关配置\n\t            tooltip: {\n\t                show: false\n\t            }\n\t        }\n\t    });\n\t\n\t    module.exports = LegendModel;\n\n\n/***/ },\n\n/***/ 568:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * @file Legend action\n\t */\n\t\n\t\n\t    var echarts = __webpack_require__(122);\n\t    var zrUtil = __webpack_require__(125);\n\t\n\t    function legendSelectActionHandler(methodName, payload, ecModel) {\n\t        var selectedMap = {};\n\t        var isToggleSelect = methodName === 'toggleSelected';\n\t        var isSelected;\n\t        // Update all legend components\n\t        ecModel.eachComponent('legend', function (legendModel) {\n\t            if (isToggleSelect && isSelected != null) {\n\t                // Force other legend has same selected status\n\t                // Or the first is toggled to true and other are toggled to false\n\t                // In the case one legend has some item unSelected in option. And if other legend\n\t                // doesn't has the item, they will assume it is selected.\n\t                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n\t            }\n\t            else {\n\t                legendModel[methodName](payload.name);\n\t                isSelected = legendModel.isSelected(payload.name);\n\t            }\n\t            var legendData = legendModel.getData();\n\t            zrUtil.each(legendData, function (model) {\n\t                var name = model.get('name');\n\t                // Wrap element\n\t                if (name === '\\n' || name === '') {\n\t                    return;\n\t                }\n\t                var isItemSelected = legendModel.isSelected(name);\n\t                if (name in selectedMap) {\n\t                    // Unselected if any legend is unselected\n\t                    selectedMap[name] = selectedMap[name] && isItemSelected;\n\t                }\n\t                else {\n\t                    selectedMap[name] = isItemSelected;\n\t                }\n\t            });\n\t        });\n\t        // Return the event explicitly\n\t        return {\n\t            name: payload.name,\n\t            selected: selectedMap\n\t        };\n\t    }\n\t    /**\n\t     * @event legendToggleSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendToggleSelect'\n\t     * @property {string} [from]\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendToggleSelect', 'legendselectchanged',\n\t        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n\t    );\n\t\n\t    /**\n\t     * @event legendSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendSelect', 'legendselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'select')\n\t    );\n\t\n\t    /**\n\t     * @event legendUnSelect\n\t     * @type {Object}\n\t     * @property {string} type 'legendUnSelect'\n\t     * @property {string} name Series name or data item name\n\t     */\n\t    echarts.registerAction(\n\t        'legendUnSelect', 'legendunselected',\n\t        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n\t    );\n\n\n/***/ },\n\n/***/ 569:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t    var zrUtil = __webpack_require__(125);\n\t    var symbolCreator = __webpack_require__(533);\n\t    var graphic = __webpack_require__(164);\n\t    var listComponentHelper = __webpack_require__(570);\n\t\n\t    var curry = zrUtil.curry;\n\t\n\t    function dispatchSelectAction(name, api) {\n\t        api.dispatchAction({\n\t            type: 'legendToggleSelect',\n\t            name: name\n\t        });\n\t    }\n\t\n\t    function dispatchHighlightAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'highlight',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    function dispatchDownplayAction(seriesModel, dataName, api) {\n\t        // If element hover will move to a hoverLayer.\n\t        var el = api.getZr().storage.getDisplayList()[0];\n\t        if (!(el && el.useHoverLayer)) {\n\t            seriesModel.get('legendHoverLink') && api.dispatchAction({\n\t                type: 'downplay',\n\t                seriesName: seriesModel.name,\n\t                name: dataName\n\t            });\n\t        }\n\t    }\n\t\n\t    module.exports = __webpack_require__(122).extendComponentView({\n\t\n\t        type: 'legend',\n\t\n\t        init: function () {\n\t            this._symbolTypeStore = {};\n\t        },\n\t\n\t        render: function (legendModel, ecModel, api) {\n\t            var group = this.group;\n\t            group.removeAll();\n\t\n\t            if (!legendModel.get('show')) {\n\t                return;\n\t            }\n\t\n\t            var selectMode = legendModel.get('selectedMode');\n\t            var itemAlign = legendModel.get('align');\n\t\n\t            if (itemAlign === 'auto') {\n\t                itemAlign = (legendModel.get('left') === 'right'\n\t                    && legendModel.get('orient') === 'vertical')\n\t                    ? 'right' : 'left';\n\t            }\n\t\n\t            var legendDrawedMap = {};\n\t\n\t            zrUtil.each(legendModel.getData(), function (itemModel) {\n\t                var name = itemModel.get('name');\n\t\n\t                // Use empty string or \\n as a newline string\n\t                if (name === '' || name === '\\n') {\n\t                    group.add(new graphic.Group({\n\t                        newline: true\n\t                    }));\n\t                    return;\n\t                }\n\t\n\t                var seriesModel = ecModel.getSeriesByName(name)[0];\n\t\n\t                if (legendDrawedMap[name]) {\n\t                    // Have been drawed\n\t                    return;\n\t                }\n\t\n\t                // Series legend\n\t                if (seriesModel) {\n\t                    var data = seriesModel.getData();\n\t                    var color = data.getVisual('color');\n\t\n\t                    // If color is a callback function\n\t                    if (typeof color === 'function') {\n\t                        // Use the first data\n\t                        color = color(seriesModel.getDataParams(0));\n\t                    }\n\t\n\t                    // Using rect symbol defaultly\n\t                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n\t                    var symbolType = data.getVisual('symbol');\n\t\n\t                    var itemGroup = this._createItem(\n\t                        name, itemModel, legendModel,\n\t                        legendSymbolType, symbolType,\n\t                        itemAlign, color,\n\t                        selectMode\n\t                    );\n\t\n\t                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n\t                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\t\n\t                    legendDrawedMap[name] = true;\n\t                }\n\t                else {\n\t                    // Data legend of pie, funnel\n\t                    ecModel.eachRawSeries(function (seriesModel) {\n\t                        // In case multiple series has same data name\n\t                        if (legendDrawedMap[name]) {\n\t                            return;\n\t                        }\n\t                        if (seriesModel.legendDataProvider) {\n\t                            var data = seriesModel.legendDataProvider();\n\t                            var idx = data.indexOfName(name);\n\t                            if (idx < 0) {\n\t                                return;\n\t                            }\n\t\n\t                            var color = data.getItemVisual(idx, 'color');\n\t\n\t                            var legendSymbolType = 'roundRect';\n\t\n\t                            var itemGroup = this._createItem(\n\t                                name, itemModel, legendModel,\n\t                                legendSymbolType, null,\n\t                                itemAlign, color,\n\t                                selectMode\n\t                            );\n\t\n\t                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n\t                                // FIXME Should not specify the series name\n\t                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n\t                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\t\n\t                            legendDrawedMap[name] = true;\n\t                        }\n\t                    }, this);\n\t                }\n\t\n\t                if (__DEV__) {\n\t                    if (!legendDrawedMap[name]) {\n\t                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n\t                    }\n\t                }\n\t            }, this);\n\t\n\t            listComponentHelper.layout(group, legendModel, api);\n\t            // Render background after group is layout\n\t            // FIXME\n\t            listComponentHelper.addBackground(group, legendModel);\n\t        },\n\t\n\t        _createItem: function (\n\t            name, itemModel, legendModel,\n\t            legendSymbolType, symbolType,\n\t            itemAlign, color, selectMode\n\t        ) {\n\t            var itemWidth = legendModel.get('itemWidth');\n\t            var itemHeight = legendModel.get('itemHeight');\n\t            var inactiveColor = legendModel.get('inactiveColor');\n\t\n\t            var isSelected = legendModel.isSelected(name);\n\t            var itemGroup = new graphic.Group();\n\t\n\t            var textStyleModel = itemModel.getModel('textStyle');\n\t\n\t            var itemIcon = itemModel.get('icon');\n\t\n\t            var tooltipModel = itemModel.getModel('tooltip');\n\t            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\t\n\t            // Use user given icon first\n\t            legendSymbolType = itemIcon || legendSymbolType;\n\t            itemGroup.add(symbolCreator.createSymbol(\n\t                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n\t            ));\n\t\n\t            // Compose symbols\n\t            // PENDING\n\t            if (!itemIcon && symbolType\n\t                // At least show one symbol, can't be all none\n\t                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n\t            ) {\n\t                var size = itemHeight * 0.8;\n\t                if (symbolType === 'none') {\n\t                    symbolType = 'circle';\n\t                }\n\t                // Put symbol in the center\n\t                itemGroup.add(symbolCreator.createSymbol(\n\t                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n\t                    isSelected ? color : inactiveColor\n\t                ));\n\t            }\n\t\n\t            // Text\n\t            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n\t            var textAlign = itemAlign;\n\t\n\t            var formatter = legendModel.get('formatter');\n\t            var content = name;\n\t            if (typeof formatter === 'string' && formatter) {\n\t                content = formatter.replace('{name}', name);\n\t            }\n\t            else if (typeof formatter === 'function') {\n\t                content = formatter(name);\n\t            }\n\t\n\t            var text = new graphic.Text({\n\t                style: {\n\t                    text: content,\n\t                    x: textX,\n\t                    y: itemHeight / 2,\n\t                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n\t                    textFont: textStyleModel.getFont(),\n\t                    textAlign: textAlign,\n\t                    textVerticalAlign: 'middle'\n\t                }\n\t            });\n\t            itemGroup.add(text);\n\t\n\t            // Add a invisible rect to increase the area of mouse hover\n\t            var hitRect = new graphic.Rect({\n\t                shape: itemGroup.getBoundingRect(),\n\t                invisible: true,\n\t                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n\t                    content: name,\n\t                    // Defaul formatter\n\t                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n\t                        return name;\n\t                    },\n\t                    formatterParams: {\n\t                        componentType: 'legend',\n\t                        legendIndex: legendModel.componentIndex,\n\t                        name: name,\n\t                        $vars: ['name']\n\t                    }\n\t                }, tooltipModel.option) : null\n\t            });\n\t            itemGroup.add(hitRect);\n\t\n\t            itemGroup.eachChild(function (child) {\n\t                child.silent = true;\n\t            });\n\t\n\t            hitRect.silent = !selectMode;\n\t\n\t\n\t\n\t            this.group.add(itemGroup);\n\t\n\t            graphic.setHoverStyle(itemGroup);\n\t\n\t            return itemGroup;\n\t        }\n\t    });\n\n\n/***/ },\n\n/***/ 570:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t    // List layout\n\t    var layout = __webpack_require__(142);\n\t    var formatUtil = __webpack_require__(127);\n\t    var graphic = __webpack_require__(164);\n\t\n\t    function positionGroup(group, model, api) {\n\t        layout.positionGroup(\n\t            group, model.getBoxLayoutParams(),\n\t            {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            },\n\t            model.get('padding')\n\t        );\n\t    }\n\t\n\t    module.exports = {\n\t        /**\n\t         * Layout list like component.\n\t         * It will box layout each items in group of component and then position the whole group in the viewport\n\t         * @param {module:zrender/group/Group} group\n\t         * @param {module:echarts/model/Component} componentModel\n\t         * @param {module:echarts/ExtensionAPI}\n\t         */\n\t        layout: function (group, componentModel, api) {\n\t            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n\t                width: api.getWidth(),\n\t                height: api.getHeight()\n\t            }, componentModel.get('padding'));\n\t            layout.box(\n\t                componentModel.get('orient'),\n\t                group,\n\t                componentModel.get('itemGap'),\n\t                rect.width,\n\t                rect.height\n\t            );\n\t\n\t            positionGroup(group, componentModel, api);\n\t        },\n\t\n\t        addBackground: function (group, componentModel) {\n\t            var padding = formatUtil.normalizeCssArray(\n\t                componentModel.get('padding')\n\t            );\n\t            var boundingRect = group.getBoundingRect();\n\t            var style = componentModel.getItemStyle(['color', 'opacity']);\n\t            style.fill = componentModel.get('backgroundColor');\n\t            var rect = new graphic.Rect({\n\t                shape: {\n\t                    x: boundingRect.x - padding[3],\n\t                    y: boundingRect.y - padding[0],\n\t                    width: boundingRect.width + padding[1] + padding[3],\n\t                    height: boundingRect.height + padding[0] + padding[2]\n\t                },\n\t                style: style,\n\t                silent: true,\n\t                z2: -1\n\t            });\n\t            graphic.subPixelOptimizeRect(rect);\n\t\n\t            group.add(rect);\n\t        }\n\t    };\n\n\n/***/ },\n\n/***/ 571:\n/***/ function(module, exports) {\n\n\t\n\t   module.exports = function (ecModel) {\n\t        var legendModels = ecModel.findComponents({\n\t            mainType: 'legend'\n\t        });\n\t        if (legendModels && legendModels.length) {\n\t            ecModel.filterSeries(function (series) {\n\t                // If in any legend component the status is not selected.\n\t                // Because in legend series is assumed selected when it is not in the legend data.\n\t                for (var i = 0; i < legendModels.length; i++) {\n\t                    if (!legendModels[i].isSelected(series.name)) {\n\t                        return false;\n\t                    }\n\t                }\n\t                return true;\n\t            });\n\t        }\n\t    };\n\n\n/***/ },\n\n/***/ 572:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(573);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(100)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./chart.less\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./chart.less\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n\n/***/ 573:\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(94)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".echarts-container{float:none;height:150px}.echarts{width:100%;height:100%;display:block}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// chart.min.js","import chartComponent from './chart.component';\nexport default angular.module('chart', [\n\t\n])\n/**\n * 轻在routerConfig.js里定义路由\n */\n.component('chart', chartComponent);\n\n\n\n// WEBPACK FOOTER //\n// ./client/app/components/chart/chart.js","import template from './chart.html';\nimport controller from './chart.controller';\nimport './chart.less';\n\nexport default {\n  restrict: 'E',\n  bindings: {},\n  template,\n  controller,\n  controllerAs: 'vm'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./client/app/components/chart/chart.component.js","module.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1>图表</h1>\\n\\t<h2>饼图</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"bs-example\\\">\\n\\t<div class=\\\"col-md-4 echarts-container\\\">\\n\\t\\t<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.pieConfig\\\" ec-option=\\\"vm.pieOption\\\" ></ng-echarts>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.pieConfig\\\" ec-option=\\\"vm.pieOption\\\" ></ng-echarts>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nlet self = this;\\nself.pieConfig = {\\n\\ttheme: 'default',\\n\\tdataLoaded: true\\n};\\n\\nself.pieOption = {\\n\\ttooltip: {\\n\\t\\ttrigger: 'item',\\n\\t\\tformatter: \\\"{a} <br/>{b} : {c} ({d}%)\\\"\\n\\t},\\n\\tlegend: {\\n\\t\\torient: 'vertical',\\n\\t\\tx: '65%',\\n\\t\\ttop: '25%',\\n\\t\\tdata: ['正常', '断开', '等待'],\\n\\t\\tformatter: function (name) {\\n\\t\\t\\tvar oa = self.pieOption.series[0].data;\\n\\t\\t\\tfor (var i = 0; i < self.pieOption.series[0].data.length; i++) {\\n\\t\\t\\t\\tif (name == oa[i].name) {\\n\\t\\t\\t\\t\\treturn name + ':' + oa[i].value + '个';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\tcolor: ['#bdea75', '#fe5454', '#faba3c'],\\n\\tseries: [{\\n\\t\\tname: '比例分析',\\n\\t\\ttype: 'pie',\\n\\t\\tradius: '55%',\\n\\t\\tcenter: ['35%', '50%'],\\n\\t\\tdata: [\\n\\t\\t{\\n\\t\\t\\tvalue: '2',\\n\\t\\t\\tname: '正常'\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tvalue: '2',\\n\\t\\t\\tname: '断开'\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tvalue: '2',\\n\\t\\t\\tname: '等待'\\n\\t\\t}],\\n\\t\\titemStyle: {\\n\\t\\t\\tnormal: {\\n\\t\\t\\t\\tlabel: {\\n\\t\\t\\t\\t\\tshow: false,\\n\\t\\t\\t\\t\\tformatter: '{b} : {c} ({d}%)'\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tlabelLine: {\\n\\t\\t\\t\\tshow: true\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}]\\n};\\n</div>\\n</div>\\n\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>仪表盘</h2>\\n</section>\\n<div class=\\\"example-block\\\">\\n<div class=\\\"bs-example\\\">\\n\\t<div class=\\\"col-md-4 echarts-container\\\">\\n\\t\\t<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.gaugeConfig\\\" ec-option=\\\"vm.gaugeOption\\\" ></ng-echarts>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.gaugeConfig\\\" ec-option=\\\"vm.gaugeOption\\\" ></ng-echarts>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nthis.gaugeConfig = {\\n\\ttheme: 'default',\\n\\tdataLoaded: true\\n};\\nthis.gaugeOption = {\\n\\tseries: [{\\n\\t\\tname: \\\"外层\\\",\\n\\t\\tz: 3,\\n\\t\\ttype: \\\"gauge\\\",\\n\\t\\tstartAngle: 180, //总的360，设置180就是半圆\\n\\t\\tendAngle: 0,\\n\\t\\tcenter: [\\\"50%\\\", \\\"77%\\\"], //整体的位置设置\\n\\t\\tradius: 80,\\n\\t\\taxisLine: {\\n\\t\\t\\tlineStyle: {\\n\\t\\t\\t\\twidth: 3, //柱子的宽度\\n\\t\\t\\t\\tcolor: [[1, \\\"#1fbba6\\\"], [1, \\\"#dbdbdb\\\"]]\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\taxisTick: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\taxisLabel: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tsplitLine: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tpointer: {\\n\\t\\t\\twidth: 0, //指针的宽度\\n\\t\\t\\tlength: \\\"80%\\\", //指针长度，按照半圆半径的百分比\\n\\t\\t\\tcolor: \\\"#2d99e2\\\"\\n\\t\\t},\\n\\t\\ttitle: {\\n\\t\\tshow: false\\n\\t\\t},\\n\\t\\tdetail: {\\n\\t\\tshow: false\\n\\t\\t},\\n\\t\\tdata: [{ //显示数据\\n\\t\\t\\tvalue: 100,\\n\\t\\t\\tname: \\\"100%\\\"\\n\\t\\t}]\\n\\t},\\n\\t{\\n\\t\\tname: \\\"内层\\\",\\n\\t\\ttype: \\\"gauge\\\",\\n\\t\\tstartAngle: 180, //总的360，设置180就是半圆\\n\\t\\tendAngle: 0,\\n\\t\\tcenter: [\\\"50%\\\", \\\"77%\\\"], //整体的位置设置\\n\\t\\tradius: 75,\\n\\t\\taxisLine: {\\n\\t\\t\\tlineStyle: {\\n\\t\\t\\twidth: 30, //柱子的宽度\\n\\t\\t\\tcolor: [[0.305, \\\"#1fbba6\\\"], [1, \\\"#dbdbdb\\\"]] //0.298是百分比的比例值（小数），还有对应两个颜色值\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\taxisTick: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\taxisLabel: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tsplitLine: {\\n\\t\\t\\tshow: false\\n\\t\\t},\\n\\t\\tpointer: {\\n\\t\\t\\twidth: 0, //指针的宽度\\n\\t\\t\\tlength: \\\"80%\\\", //指针长度，按照半圆半径的百分比\\n\\t\\t\\tcolor: \\\"#2d99e2\\\"\\n\\t\\t},\\n\\t\\ttitle: {\\n\\t\\t\\tshow: true,\\n\\t\\t\\toffsetCenter: [0, '-10px'], //标题位置设置\\n\\t\\t\\ttextStyle: { //标题样式设置\\n\\t\\t\\tcolor: \\\"#1fbba6\\\",\\n\\t\\t\\tfontSize: 18,\\n\\t\\t\\tfontFamily: \\\"Arial\\\",\\n\\t\\t\\tfontWeight: \\\"normal\\\"\\n\\t\\t}\\n\\t},\\n\\tdetail: {\\n\\t\\tshow: false\\n\\t},\\n\\tdata: [{ //显示数据\\n\\t\\tvalue: 30.50,\\n\\t\\tname: \\\"30.50%\\\"\\n\\t}]\\n}]\\n};\\n</div>\\n</div>\\n\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>曲线图</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"bs-example\\\">\\n\\t<div class=\\\"col-md-12 echarts-container\\\" style=\\\"height: 400px\\\">\\n\\t\\t<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.lineConfig\\\" ec-option=\\\"vm.lineOption\\\" ></ng-echarts>\\n\\t</div>\\n</div>\\n\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<ng-echarts class=\\\"echarts\\\" ec-config=\\\"vm.lineConfig\\\" ec-option=\\\"vm.lineOption\\\" ></ng-echarts>\\n</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nlet self =  this;\\nthis.lineConfig = {\\n\\ttheme: 'default',\\n\\tdataLoaded: true\\n};\\n\\nthis.lineOption = {\\n\\ttitle: {\\n\\t\\ttext: '内存使用情况',\\n\\t\\tsubtext: 'pod memory usage',\\n\\t\\ttextAlign: 'left',\\n\\t\\tx: \\\"0\\\",\\n\\t\\ttextStyle: {\\n\\t\\t\\tcolor: '#666',\\n\\t\\t\\tfontSize: '14'\\n\\t\\t},\\n\\t\\tsubtextStyle: {\\n\\t\\t\\tcolor: '#d6d6d6',\\n\\t\\t\\tfontSize: '12',\\n\\t\\t\\tdisplay: 'inline'\\n\\t\\t}\\n\\t},\\n\\tgrid: {\\n\\t\\tborderWidth: 0,\\n\\t\\tborderColor: '#f2f2f2'\\n\\t},\\n\\tlegend: {\\n\\t\\torient: 'horizontal',\\n\\t\\ttop: '0',\\n\\t\\tright: '0',\\n\\t\\talign: 'left',\\n\\t\\tdata: ['op-lodgings-sync', 'elasticsearch-logging']\\n\\t},\\n\\ttooltip: {\\n\\t\\ttrigger: 'axis'\\n\\t},\\n\\txAxis: {\\n\\t\\ttype: 'category',\\n\\t\\tboundaryGap: false,\\n\\t\\tdata: ['13:25', '13:30', '13:35', '13:40', '13:45', '13:50', '13:55', '14:00', '14:05', '14:10', '14:15', '14:20'],\\n\\t\\tsplitLine: {\\n\\t\\t\\tshow: true,\\n\\t\\t\\tinterval: 'auto'\\n\\t\\t}\\n\\t},\\n\\tyAxis: {\\n\\t\\ttype: 'value',\\n\\t\\taxisLabel: {\\n\\t\\t\\tformatter: '{value} GiB'\\n\\t\\t}\\n\\t},\\n\\tcolor: ['#64b1e4', '#fa9073'],\\n\\tseries: [\\n\\t\\t{\\n\\t\\t\\tname: 'op-lodgings-sync',\\n\\t\\t\\ttype: 'line',\\n\\t\\t\\tsmooth: false,\\n\\t\\t\\tdata: [1.1, 4.5, 3.4, 1.7, 3.8, 2.1, 4.5, 4.7, 5.1, 3.8, 5.5, 6.2]\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tname: 'elasticsearch-logging',\\n\\t\\t\\ttype: 'line',\\n\\t\\t\\tsmooth: false,\\n\\t\\t\\tdata: [2.6, 3.7, 5.1, 8.2, 3.2, 6.1, 3.9, 4.5, 3.4, 1.7, 3.8, 2.1]\\n\\t\\t}\\n\\t]\\n};\\n</div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/app/components/chart/chart.html\n// module id = 511\n// module chunks = 16","/**\n * (description)\n *\n * @author yourname\n */\n\n// include pie chart\nrequire('echarts/lib/chart/pie');\n// include gauge chart\nrequire('echarts/lib/chart/gauge');\n// include line chart\nrequire('echarts/lib/chart/line');\n\n// include tooltip component\nrequire('echarts/lib/component/tooltip');\n// include title component\nrequire('echarts/lib/component/title');\n// include legend component\nrequire('echarts/lib/component/legend');\n\nexport default class ChartController {\n\tconstructor() {\n\t\t\"ngInject\";\n\t\tthis.initPieChart();\n\t\tthis.initGaugeChart();\n\t\tthis.initLineChart();\n\t}\n\n\tinitGaugeChart() {\n\t\tthis.gaugeConfig = {\n\t\t\ttheme: 'default',\n\t\t\tdataLoaded: true\n\t\t};\n\n\t\tthis.gaugeOption = {\n\t\t\tseries: [{\n\t\t\t\tname: \"外层\",\n\t\t\t\tz: 3,\n\t\t\t\ttype: \"gauge\",\n\t\t\t\tstartAngle: 180, //总的360，设置180就是半圆\n\t\t\t\tendAngle: 0,\n\t\t\t\tcenter: [\"50%\", \"77%\"], //整体的位置设置\n\t\t\t\tradius: 80,\n\t\t\t\taxisLine: {\n\t\t\t\t\tlineStyle: {\n\t\t\t\t\t\twidth: 3, //柱子的宽度\n\t\t\t\t\t\tcolor: [[1, \"#1fbba6\"], [1, \"#dbdbdb\"]] //0.298是百分比的比例值（小数），还有对应两个颜色值\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\taxisTick: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\taxisLabel: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\tsplitLine: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\tpointer: {\n\t\t\t\t\twidth: 0, //指针的宽度\n\t\t\t\t\tlength: \"80%\", //指针长度，按照半圆半径的百分比\n\t\t\t\t\tcolor: \"#2d99e2\"\n\t\t\t\t},\n\t\t\t\ttitle: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\tdetail: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\tdata: [{ //显示数据\n\t\t\t\t\tvalue: 100,\n\t\t\t\t\tname: \"100%\"\n\t\t\t\t}]\n\t\t\t},\n\t\t\t{\n\t\t\t\tname: \"内层\",\n\t\t\t\ttype: \"gauge\",\n\t\t\t\tstartAngle: 180, //总的360，设置180就是半圆\n\t\t\t\tendAngle: 0,\n\t\t\t\tcenter: [\"50%\", \"77%\"], //整体的位置设置\n\t\t\t\tradius: 75,\n\t\t\t\taxisLine: {\n\t\t\t\t\tlineStyle: {\n\t\t\t\t\t\twidth: 30, //柱子的宽度\n\t\t\t\t\t\tcolor: [[0.305, \"#1fbba6\"], [1, \"#dbdbdb\"]] //0.298是百分比的比例值（小数），还有对应两个颜色值\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\taxisTick: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\taxisLabel: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\tsplitLine: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\tpointer: {\n\t\t\t\t\twidth: 0, //指针的宽度\n\t\t\t\t\tlength: \"80%\", //指针长度，按照半圆半径的百分比\n\t\t\t\t\tcolor: \"#2d99e2\"\n\t\t\t\t},\n\t\t\t\ttitle: {\n\t\t\t\t\tshow: true,\n\t\t\t\t\toffsetCenter: [0, '-10px'], //标题位置设置\n\t\t\t\t\ttextStyle: { //标题样式设置\n\t\t\t\t\t\tcolor: \"#1fbba6\",\n\t\t\t\t\t\tfontSize: 18,\n\t\t\t\t\t\tfontFamily: \"Arial\",\n\t\t\t\t\t\tfontWeight: \"normal\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tdetail: {\n\t\t\t\t\tshow: false\n\t\t\t\t},\n\t\t\t\tdata: [{ //显示数据\n\t\t\t\t\tvalue: 30.50,\n\t\t\t\t\tname: \"30.50%\"\n\t\t\t\t}]\n\t\t\t}]\n\t\t};\n\t}\n\n\tinitPieChart() {\n\t\tlet self = this;\n\t\tself.pieConfig = {\n\t\t\ttheme: 'default',\n\t\t\tdataLoaded: true\n\t\t};\n\n\t\tself.pieOption = {\n\t\t\ttooltip: {\n\t\t\t\ttrigger: 'item',\n\t\t\t\tformatter: \"{a} <br/>{b} : {c} ({d}%)\"\n\t\t\t},\n\t\t\tlegend: {\n\t\t\t\torient: 'vertical',\n\t\t\t\tx: '65%',\n\t\t\t\ttop: '25%',\n\t\t\t\tdata: ['正常', '断开', '等待'],\n\t\t\t\tformatter: function (name) {\n\t\t\t\t\tvar oa = self.pieOption.series[0].data;\n\t\t\t\t\tfor (var i = 0; i < self.pieOption.series[0].data.length; i++) {\n\t\t\t\t\t\tif (name == oa[i].name) {\n\t\t\t\t\t\t\treturn name + ':' + oa[i].value + '个';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tcolor: ['#bdea75', '#fe5454', '#faba3c'],\n\t\t\tseries: [{\n\t\t\t\tname: '比例分析',\n\t\t\t\ttype: 'pie',\n\t\t\t\tradius: '55%',\n\t\t\t\tcenter: ['35%', '50%'],\n\t\t\t\tdata: [{\n\t\t\t\t\tvalue: '2',\n\t\t\t\t\tname: '正常'\n\t\t\t\t}, {\n\t\t\t\t\tvalue: '2',\n\t\t\t\t\tname: '断开'\n\t\t\t\t}, {\n\t\t\t\t\tvalue: '2',\n\t\t\t\t\tname: '等待'\n\t\t\t\t}],\n\t\t\t\titemStyle: {\n\t\t\t\t\tnormal: {\n\t\t\t\t\t\tlabel: {\n\t\t\t\t\t\t\tshow: false,\n\t\t\t\t\t\t\tformatter: '{b} : {c} ({d}%)'\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tlabelLine: {\n\t\t\t\t\t\tshow: true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]\n\t\t};\n\t}\n\n\tinitLineChart() {\n\t\tlet self =  this;\n\t\tthis.lineConfig = {\n\t\t\ttheme: 'default',\n\t\t\tdataLoaded: true\n\t\t};\n\n\t\tthis.lineOption = {\n\t\t\ttitle: {\n\t\t\t\ttext: '内存使用情况',\n\t\t\t\tsubtext: 'pod memory usage',\n\t\t\t\ttextAlign: 'left',\n\t\t\t\tx: \"0\",\n\t\t\t\ttextStyle: {\n\t\t\t\t\tcolor: '#666',\n\t\t\t\t\tfontSize: '14'\n\t\t\t\t},\n\t\t\t\tsubtextStyle: {\n\t\t\t\t\tcolor: '#d6d6d6',\n\t\t\t\t\tfontSize: '12',\n\t\t\t\t\tdisplay: 'inline'\n\t\t\t\t}\n\t\t\t},\n\t\t\tgrid: {\n\t\t\t\tborderWidth: 0,\n\t\t\t\tborderColor: '#f2f2f2'\n\t\t\t},\n\t\t\tlegend: {\n\t\t\t\torient: 'horizontal',\n\t\t\t\ttop: '0',\n\t\t\t\tright: '0',\n\t\t\t\talign: 'left',\n\t\t\t\tdata: ['op-lodgings-sync', 'elasticsearch-logging']\n\t\t\t},\n\t\t\ttooltip: {\n\t\t\t\ttrigger: 'axis'\n\t\t\t},\n\t\t\txAxis: {\n\t\t\t\ttype: 'category',\n\t\t\t\tboundaryGap: false,\n\t\t\t\tdata: ['13:25', '13:30', '13:35', '13:40', '13:45', '13:50', '13:55', '14:00', '14:05', '14:10', '14:15', '14:20'],\n\t\t\t\tsplitLine: {\n\t\t\t\t\tshow: true,\n\t\t\t\t\tinterval: 'auto'\n\t\t\t\t}\n\t\t\t},\n\t\t\tyAxis: {\n\t\t\t\ttype: 'value',\n\t\t\t\taxisLabel: {\n\t\t\t\t\tformatter: '{value} GiB'\n\t\t\t\t}\n\t\t\t},\n\t\t\tcolor: ['#64b1e4', '#fa9073'],\n\t\t\tseries: [\n\t\t\t\t{\n\t\t\t\t\tname: 'op-lodgings-sync',\n\t\t\t\t\ttype: 'line',\n\t\t\t\t\tsmooth: false,\n\t\t\t\t\tdata: [1.1, 4.5, 3.4, 1.7, 3.8, 2.1, 4.5, 4.7, 5.1, 3.8, 5.5, 6.2]\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: 'elasticsearch-logging',\n\t\t\t\t\ttype: 'line',\n\t\t\t\t\tsmooth: false,\n\t\t\t\t\tdata: [2.6, 3.7, 5.1, 8.2, 3.2, 6.1, 3.9, 4.5, 3.4, 1.7, 3.8, 2.1]\n\t\t\t\t}\n\t\t\t]\n\t\t};\n\t}\n}\n\n\n// WEBPACK FOOTER //\n// ./client/app/components/chart/chart.controller.js","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('./pie/PieSeries');\n    require('./pie/PieView');\n\n    require('../action/createDataSelectAction')('pie', [{\n        type: 'pieToggleSelect',\n        event: 'pieselectchanged',\n        method: 'toggleSelected'\n    }, {\n        type: 'pieSelect',\n        event: 'pieselected',\n        method: 'select'\n    }, {\n        type: 'pieUnSelect',\n        event: 'pieunselected',\n        method: 'unSelect'\n    }]);\n\n    echarts.registerVisual(zrUtil.curry(require('../visual/dataColor'), 'pie'));\n\n    echarts.registerLayout(zrUtil.curry(\n        require('./pie/pieLayout'), 'pie'\n    ));\n\n    echarts.registerProcessor(zrUtil.curry(require('../processor/dataFilter'), 'pie'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie.js\n// module id = 513\n// module chunks = 16","'use strict';\n\n\n    var List = require('../../data/List');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n\n    var dataSelectableMixin = require('../../component/helper/selectableMixin');\n\n    var PieSeries = require('../../echarts').extendSeriesModel({\n\n        type: 'series.pie',\n\n        // Overwrite\n        init: function (option) {\n            PieSeries.superApply(this, 'init', arguments);\n\n            // Enable legend selection for each data item\n            // Use a function instead of direct access because data reference may changed\n            this.legendDataProvider = function () {\n                return this._dataBeforeProcessed;\n            };\n\n            this.updateSelectedMap(option.data);\n\n            this._defaultLabelLine(option);\n        },\n\n        // Overwrite\n        mergeOption: function (newOption) {\n            PieSeries.superCall(this, 'mergeOption', newOption);\n            this.updateSelectedMap(this.option.data);\n        },\n\n        getInitialData: function (option, ecModel) {\n            var dimensions = completeDimensions(['value'], option.data);\n            var list = new List(dimensions, this);\n            list.initData(option.data);\n            return list;\n        },\n\n        // Overwrite\n        getDataParams: function (dataIndex) {\n            var data = this._data;\n            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);\n            var sum = data.getSum('value');\n            // FIXME toFixed?\n            //\n            // Percent is 0 if sum is 0\n            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);\n\n            params.$vars.push('percent');\n            return params;\n        },\n\n        _defaultLabelLine: function (option) {\n            // Extend labelLine emphasis\n            modelUtil.defaultEmphasis(option.labelLine, ['show']);\n\n            var labelLineNormalOpt = option.labelLine.normal;\n            var labelLineEmphasisOpt = option.labelLine.emphasis;\n            // Not show label line if `label.normal.show = false`\n            labelLineNormalOpt.show = labelLineNormalOpt.show\n                && option.label.normal.show;\n            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show\n                && option.label.emphasis.show;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // 默认全局居中\n            center: ['50%', '50%'],\n            radius: [0, '75%'],\n            // 默认顺时针\n            clockwise: true,\n            startAngle: 90,\n            // 最小角度改为0\n            minAngle: 0,\n            // 选中是扇区偏移量\n            selectedOffset: 10,\n\n            // If use strategy to avoid label overlapping\n            avoidLabelOverlap: true,\n            // 选择模式，默认关闭，可选single，multiple\n            // selectedMode: false,\n            // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）\n            // roseType: null,\n\n            label: {\n                normal: {\n                    // If rotate around circle\n                    rotate: false,\n                    show: true,\n                    // 'outer', 'inside', 'center'\n                    position: 'outer'\n                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调\n                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE\n                    // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数\n                },\n                emphasis: {}\n            },\n            // Enabled when label.normal.position is 'outer'\n            labelLine: {\n                normal: {\n                    show: true,\n                    // 引导线两段中的第一段长度\n                    length: 15,\n                    // 引导线两段中的第二段长度\n                    length2: 15,\n                    smooth: false,\n                    lineStyle: {\n                        // color: 各异,\n                        width: 1,\n                        type: 'solid'\n                    }\n                }\n            },\n            itemStyle: {\n                normal: {\n                    borderWidth: 1\n                },\n                emphasis: {}\n            },\n\n            animationEasing: 'cubicOut',\n\n            data: []\n        }\n    });\n\n    zrUtil.mixin(PieSeries, dataSelectableMixin);\n\n    module.exports = PieSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieSeries.js\n// module id = 514\n// module chunks = 16","/**\n * Complete dimensions by data (guess dimension).\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * Complete the dimensions array guessed from the data structure.\n     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']\n     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]\n     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']\n     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.\n     * @return {Array.<string>}\n     */\n    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {\n        if (!data) {\n            return dimensions;\n        }\n\n        var value0 = retrieveValue(data[0]);\n        var dimSize = zrUtil.isArray(value0) && value0.length || 1;\n\n        defaultNames = defaultNames || [];\n        extraPrefix = extraPrefix || 'extra';\n        for (var i = 0; i < dimSize; i++) {\n            if (!dimensions[i]) {\n                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));\n                dimensions[i] = guessOrdinal(data, i)\n                    ? {type: 'ordinal', name: name}\n                    : name;\n            }\n        }\n\n        return dimensions;\n    }\n\n    // The rule should not be complex, otherwise user might not\n    // be able to known where the data is wrong.\n    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {\n        for (var i = 0, len = data.length; i < len; i++) {\n            var value = retrieveValue(data[i]);\n\n            if (!zrUtil.isArray(value)) {\n                return false;\n            }\n\n            var value = value[dimIndex];\n            if (value != null && isFinite(value)) {\n                return false;\n            }\n            else if (zrUtil.isString(value) && value !== '-') {\n                return true;\n            }\n        }\n        return false;\n    };\n\n    function retrieveValue(o) {\n        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;\n    }\n\n    module.exports = completeDimensions;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/data/helper/completeDimensions.js\n// module id = 515\n// module chunks = 16","/**\n * Data selectable mixin for chart series.\n * To eanble data select, option of series must have `selectedMode`.\n * And each data item will use `selected` to toggle itself selected status\n *\n * @module echarts/chart/helper/DataSelectable\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    module.exports = {\n\n        updateSelectedMap: function (targetList) {\n            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {\n                targetMap[target.name] = target;\n                return targetMap;\n            }, {});\n        },\n        /**\n         * @param {string} name\n         */\n        // PENGING If selectedMode is null ?\n        select: function (name) {\n            var targetMap = this._selectTargetMap;\n            var target = targetMap[name];\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                zrUtil.each(targetMap, function (target) {\n                    target.selected = false;\n                });\n            }\n            target && (target.selected = true);\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            var target = this._selectTargetMap[name];\n            // var selectedMode = this.get('selectedMode');\n            // selectedMode !== 'single' && target && (target.selected = false);\n            target && (target.selected = false);\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            if (target != null) {\n                this[target.selected ? 'unSelect' : 'select'](name);\n                return target.selected;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var target = this._selectTargetMap[name];\n            return target && target.selected;\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/selectableMixin.js\n// module id = 516\n// module chunks = 16","\n\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n\n    /**\n     * @param {module:echarts/model/Series} seriesModel\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function updateDataSelected(uid, seriesModel, hasAnimation, api) {\n        var data = seriesModel.getData();\n        var dataIndex = this.dataIndex;\n        var name = data.getName(dataIndex);\n        var selectedOffset = seriesModel.get('selectedOffset');\n\n        api.dispatchAction({\n            type: 'pieToggleSelect',\n            from: uid,\n            name: name,\n            seriesId: seriesModel.id\n        });\n\n        data.each(function (idx) {\n            toggleItemSelected(\n                data.getItemGraphicEl(idx),\n                data.getItemLayout(idx),\n                seriesModel.isSelected(data.getName(idx)),\n                selectedOffset,\n                hasAnimation\n            );\n        });\n    }\n\n    /**\n     * @param {module:zrender/graphic/Sector} el\n     * @param {Object} layout\n     * @param {boolean} isSelected\n     * @param {number} selectedOffset\n     * @param {boolean} hasAnimation\n     * @inner\n     */\n    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {\n        var midAngle = (layout.startAngle + layout.endAngle) / 2;\n\n        var dx = Math.cos(midAngle);\n        var dy = Math.sin(midAngle);\n\n        var offset = isSelected ? selectedOffset : 0;\n        var position = [dx * offset, dy * offset];\n\n        hasAnimation\n            // animateTo will stop revious animation like update transition\n            ? el.animate()\n                .when(200, {\n                    position: position\n                })\n                .start('bounceOut')\n            : el.attr('position', position);\n    }\n\n    /**\n     * Piece of pie including Sector, Label, LabelLine\n     * @constructor\n     * @extends {module:zrender/graphic/Group}\n     */\n    function PiePiece(data, idx) {\n\n        graphic.Group.call(this);\n\n        var sector = new graphic.Sector({\n            z2: 2\n        });\n        var polyline = new graphic.Polyline();\n        var text = new graphic.Text();\n        this.add(sector);\n        this.add(polyline);\n        this.add(text);\n\n        this.updateData(data, idx, true);\n\n        // Hover to change label and labelLine\n        function onEmphasis() {\n            polyline.ignore = polyline.hoverIgnore;\n            text.ignore = text.hoverIgnore;\n        }\n        function onNormal() {\n            polyline.ignore = polyline.normalIgnore;\n            text.ignore = text.normalIgnore;\n        }\n        this.on('emphasis', onEmphasis)\n            .on('normal', onNormal)\n            .on('mouseover', onEmphasis)\n            .on('mouseout', onNormal);\n    }\n\n    var piePieceProto = PiePiece.prototype;\n\n    function getLabelStyle(data, idx, state, labelModel, labelPosition) {\n        var textStyleModel = labelModel.getModel('textStyle');\n        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n        return {\n            fill: textStyleModel.getTextColor()\n                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),\n            opacity: data.getItemVisual(idx, 'opacity'),\n            textFont: textStyleModel.getFont(),\n            text: zrUtil.retrieve(\n                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)\n            )\n        };\n    }\n\n    piePieceProto.updateData = function (data, idx, firstCreate) {\n\n        var sector = this.childAt(0);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var sectorShape = zrUtil.extend({}, layout);\n        sectorShape.label = null;\n        if (firstCreate) {\n            sector.setShape(sectorShape);\n            sector.shape.endAngle = layout.startAngle;\n            graphic.updateProps(sector, {\n                shape: {\n                    endAngle: layout.endAngle\n                }\n            }, seriesModel, idx);\n        }\n        else {\n            graphic.updateProps(sector, {\n                shape: sectorShape\n            }, seriesModel, idx);\n        }\n\n        // Update common style\n        var itemStyleModel = itemModel.getModel('itemStyle');\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        sector.useStyle(\n            zrUtil.defaults(\n                {\n                    lineJoin: 'bevel',\n                    fill: visualColor\n                },\n                itemStyleModel.getModel('normal').getItemStyle()\n            )\n        );\n        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();\n\n        // Toggle selected\n        toggleItemSelected(\n            this,\n            data.getItemLayout(idx),\n            itemModel.get('selected'),\n            seriesModel.get('selectedOffset'),\n            seriesModel.get('animation')\n        );\n\n        function onEmphasis() {\n            // Sector may has animation of updating data. Force to move to the last frame\n            // Or it may stopped on the wrong shape\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r + 10\n                }\n            }, 300, 'elasticOut');\n        }\n        function onNormal() {\n            sector.stopAnimation(true);\n            sector.animateTo({\n                shape: {\n                    r: layout.r\n                }\n            }, 300, 'elasticOut');\n        }\n        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');\n        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {\n            sector\n                .on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n\n        this._updateLabel(data, idx);\n\n        graphic.setHoverStyle(this);\n    };\n\n    piePieceProto._updateLabel = function (data, idx) {\n\n        var labelLine = this.childAt(1);\n        var labelText = this.childAt(2);\n\n        var seriesModel = data.hostModel;\n        var itemModel = data.getItemModel(idx);\n        var layout = data.getItemLayout(idx);\n        var labelLayout = layout.label;\n        var visualColor = data.getItemVisual(idx, 'color');\n\n        graphic.updateProps(labelLine, {\n            shape: {\n                points: labelLayout.linePoints || [\n                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]\n                ]\n            }\n        }, seriesModel, idx);\n\n        graphic.updateProps(labelText, {\n            style: {\n                x: labelLayout.x,\n                y: labelLayout.y\n            }\n        }, seriesModel, idx);\n        labelText.attr({\n            style: {\n                textVerticalAlign: labelLayout.verticalAlign,\n                textAlign: labelLayout.textAlign,\n                textFont: labelLayout.font\n            },\n            rotation: labelLayout.rotation,\n            origin: [labelLayout.x, labelLayout.y],\n            z2: 10\n        });\n\n        var labelModel = itemModel.getModel('label.normal');\n        var labelHoverModel = itemModel.getModel('label.emphasis');\n        var labelLineModel = itemModel.getModel('labelLine.normal');\n        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');\n        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');\n\n        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));\n\n        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');\n        labelText.hoverIgnore = !labelHoverModel.get('show');\n\n        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');\n        labelLine.hoverIgnore = !labelLineHoverModel.get('show');\n\n        // Default use item visual color\n        labelLine.setStyle({\n            stroke: visualColor,\n            opacity: data.getItemVisual(idx, 'opacity')\n        });\n        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());\n\n        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);\n        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();\n\n        var smooth = labelLineModel.get('smooth');\n        if (smooth && smooth === true) {\n            smooth = 0.4;\n        }\n        labelLine.setShape({\n            smooth: smooth\n        });\n    };\n\n    zrUtil.inherits(PiePiece, graphic.Group);\n\n\n    // Pie view\n    var Pie = require('../../view/Chart').extend({\n\n        type: 'pie',\n\n        init: function () {\n            var sectorGroup = new graphic.Group();\n            this._sectorGroup = sectorGroup;\n        },\n\n        render: function (seriesModel, ecModel, api, payload) {\n            if (payload && (payload.from === this.uid)) {\n                return;\n            }\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n            var group = this.group;\n\n            var hasAnimation = ecModel.get('animation');\n            var isFirstRender = !oldData;\n\n            var onSectorClick = zrUtil.curry(\n                updateDataSelected, this.uid, seriesModel, hasAnimation, api\n            );\n\n            var selectedMode = seriesModel.get('selectedMode');\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var piePiece = new PiePiece(data, idx);\n                    if (isFirstRender) {\n                        piePiece.eachChild(function (child) {\n                            child.stopAnimation(true);\n                        });\n                    }\n\n                    selectedMode && piePiece.on('click', onSectorClick);\n\n                    data.setItemGraphicEl(idx, piePiece);\n\n                    group.add(piePiece);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var piePiece = oldData.getItemGraphicEl(oldIdx);\n\n                    piePiece.updateData(data, newIdx);\n\n                    piePiece.off('click');\n                    selectedMode && piePiece.on('click', onSectorClick);\n                    group.add(piePiece);\n                    data.setItemGraphicEl(newIdx, piePiece);\n                })\n                .remove(function (idx) {\n                    var piePiece = oldData.getItemGraphicEl(idx);\n                    group.remove(piePiece);\n                })\n                .execute();\n\n            if (hasAnimation && isFirstRender && data.count() > 0) {\n                var shape = data.getItemLayout(0);\n                var r = Math.max(api.getWidth(), api.getHeight()) / 2;\n\n                var removeClipPath = zrUtil.bind(group.removeClipPath, group);\n                group.setClipPath(this._createClipPath(\n                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel\n                ));\n            }\n\n            this._data = data;\n        },\n\n        dispose: function () {},\n\n        _createClipPath: function (\n            cx, cy, r, startAngle, clockwise, cb, seriesModel\n        ) {\n            var clipPath = new graphic.Sector({\n                shape: {\n                    cx: cx,\n                    cy: cy,\n                    r0: 0,\n                    r: r,\n                    startAngle: startAngle,\n                    endAngle: startAngle,\n                    clockwise: clockwise\n                }\n            });\n\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2\n                }\n            }, seriesModel, cb);\n\n            return clipPath;\n        },\n\n        /**\n         * @implement\n         */\n        containPoint: function (point, seriesModel) {\n            var data = seriesModel.getData();\n            var itemLayout = data.getItemLayout(0);\n            if (itemLayout) {\n                var dx = point[0] - itemLayout.cx;\n                var dy = point[1] - itemLayout.cy;\n                var radius = Math.sqrt(dx * dx + dy * dy);\n                return radius <= itemLayout.r && radius >= itemLayout.r0;\n            }\n        }\n\n    });\n\n    module.exports = Pie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/PieView.js\n// module id = 517\n// module chunks = 16","\n    var echarts = require('../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n    module.exports = function (seriesType, actionInfos) {\n        zrUtil.each(actionInfos, function (actionInfo) {\n            actionInfo.update = 'updateView';\n            /**\n             * @payload\n             * @property {string} seriesName\n             * @property {string} name\n             */\n            echarts.registerAction(actionInfo, function (payload, ecModel) {\n                var selected = {};\n                ecModel.eachComponent(\n                    {mainType: 'series', subType: seriesType, query: payload},\n                    function (seriesModel) {\n                        if (seriesModel[actionInfo.method]) {\n                            seriesModel[actionInfo.method](payload.name);\n                        }\n                        var data = seriesModel.getData();\n                        // Create selected map\n                        data.each(function (idx) {\n                            var name = data.getName(idx);\n                            selected[name] = seriesModel.isSelected(name) || false;\n                        });\n                    }\n                );\n                return {\n                    name: payload.name,\n                    selected: selected\n                };\n            });\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/action/createDataSelectAction.js\n// module id = 518\n// module chunks = 16","// Pick color from palette for each data item\n\n\n    module.exports = function (seriesType, ecModel) {\n        // Pie and funnel may use diferrent scope\n        var paletteScope = {};\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var dataAll = seriesModel.getRawData();\n            var idxMap = {};\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                var data = seriesModel.getData();\n                data.each(function (idx) {\n                    var rawIdx = data.getRawIndex(idx);\n                    idxMap[rawIdx] = idx;\n                });\n                dataAll.each(function (rawIdx) {\n                    // FIXME Performance\n                    var itemModel = dataAll.getItemModel(rawIdx);\n                    var filteredIdx = idxMap[rawIdx];\n\n                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded\n                    var singleDataColor = filteredIdx != null\n                        && data.getItemVisual(filteredIdx, 'color', true);\n\n                    if (!singleDataColor) {\n                        var color = itemModel.get('itemStyle.normal.color')\n                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);\n                        // Legend may use the visual info in data before processed\n                        dataAll.setItemVisual(rawIdx, 'color', color);\n\n                        // Data is not filtered\n                        if (filteredIdx != null) {\n                            data.setItemVisual(filteredIdx, 'color', color);\n                        }\n                    }\n                    else {\n                        // Set data all color for legend\n                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/dataColor.js\n// module id = 519\n// module chunks = 16","// TODO minAngle\n\n\n\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n    var labelLayout = require('./labelLayout');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var PI2 = Math.PI * 2;\n    var RADIAN = Math.PI / 180;\n\n    module.exports = function (seriesType, ecModel, api, payload) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var center = seriesModel.get('center');\n            var radius = seriesModel.get('radius');\n\n            if (!zrUtil.isArray(radius)) {\n                radius = [0, radius];\n            }\n            if (!zrUtil.isArray(center)) {\n                center = [center, center];\n            }\n\n            var width = api.getWidth();\n            var height = api.getHeight();\n            var size = Math.min(width, height);\n            var cx = parsePercent(center[0], width);\n            var cy = parsePercent(center[1], height);\n            var r0 = parsePercent(radius[0], size / 2);\n            var r = parsePercent(radius[1], size / 2);\n\n            var data = seriesModel.getData();\n\n            var startAngle = -seriesModel.get('startAngle') * RADIAN;\n\n            var minAngle = seriesModel.get('minAngle') * RADIAN;\n\n            var sum = data.getSum('value');\n            // Sum may be 0\n            var unitRadian = Math.PI / (sum || data.count()) * 2;\n\n            var clockwise = seriesModel.get('clockwise');\n\n            var roseType = seriesModel.get('roseType');\n\n            // [0...max]\n            var extent = data.getDataExtent('value');\n            extent[0] = 0;\n\n            // In the case some sector angle is smaller than minAngle\n            var restAngle = PI2;\n            var valueSumLargerThanMinAngle = 0;\n\n            var currentAngle = startAngle;\n\n            var dir = clockwise ? 1 : -1;\n            data.each('value', function (value, idx) {\n                var angle;\n                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？\n                if (roseType !== 'area') {\n                    angle = sum === 0 ? unitRadian : (value * unitRadian);\n                }\n                else {\n                    angle = PI2 / (data.count() || 1);\n                }\n\n                if (angle < minAngle) {\n                    angle = minAngle;\n                    restAngle -= minAngle;\n                }\n                else {\n                    valueSumLargerThanMinAngle += value;\n                }\n\n                var endAngle = currentAngle + dir * angle;\n                data.setItemLayout(idx, {\n                    angle: angle,\n                    startAngle: currentAngle,\n                    endAngle: endAngle,\n                    clockwise: clockwise,\n                    cx: cx,\n                    cy: cy,\n                    r0: r0,\n                    r: roseType\n                        ? numberUtil.linearMap(value, extent, [r0, r])\n                        : r\n                });\n\n                currentAngle = endAngle;\n            }, true);\n\n            // Some sector is constrained by minAngle\n            // Rest sectors needs recalculate angle\n            if (restAngle < PI2) {\n                // Average the angle if rest angle is not enough after all angles is\n                // Constrained by minAngle\n                if (restAngle <= 1e-3) {\n                    var angle = PI2 / data.count();\n                    data.each(function (idx) {\n                        var layout = data.getItemLayout(idx);\n                        layout.startAngle = startAngle + dir * idx * angle;\n                        layout.endAngle = startAngle + dir * (idx + 1) * angle;\n                    });\n                }\n                else {\n                    unitRadian = restAngle / valueSumLargerThanMinAngle;\n                    currentAngle = startAngle;\n                    data.each('value', function (value, idx) {\n                        var layout = data.getItemLayout(idx);\n                        var angle = layout.angle === minAngle\n                            ? minAngle : value * unitRadian;\n                        layout.startAngle = currentAngle;\n                        layout.endAngle = currentAngle + dir * angle;\n                        currentAngle += angle;\n                    });\n                }\n            }\n\n            labelLayout(seriesModel, r, width, height);\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/pieLayout.js\n// module id = 520\n// module chunks = 16","'use strict';\n// FIXME emphasis label position is not same with normal label position\n\n\n    var textContain = require('zrender/lib/contain/text');\n\n    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {\n        list.sort(function (a, b) {\n            return a.y - b.y;\n        });\n\n        // 压\n        function shiftDown(start, end, delta, dir) {\n            for (var j = start; j < end; j++) {\n                list[j].y += delta;\n                if (j > start\n                    && j + 1 < end\n                    && list[j + 1].y > list[j].y + list[j].height\n                ) {\n                    shiftUp(j, delta / 2);\n                    return;\n                }\n            }\n\n            shiftUp(end - 1, delta / 2);\n        }\n\n        // 弹\n        function shiftUp(end, delta) {\n            for (var j = end; j >= 0; j--) {\n                list[j].y -= delta;\n                if (j > 0\n                    && list[j].y > list[j - 1].y + list[j - 1].height\n                ) {\n                    break;\n                }\n            }\n        }\n\n        function changeX(list, isDownList, cx, cy, r, dir) {\n            var lastDeltaX = dir > 0\n                ? isDownList                // 右侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0                     // 上\n                : isDownList                // 左侧\n                    ? Number.MAX_VALUE      // 下\n                    : 0;                    // 上\n\n            for (var i = 0, l = list.length; i < l; i++) {\n                // Not change x for center label\n                if (list[i].position === 'center') {\n                    continue;\n                }\n                var deltaY = Math.abs(list[i].y - cy);\n                var length = list[i].len;\n                var length2 = list[i].len2;\n                var deltaX = (deltaY < r + length)\n                    ? Math.sqrt(\n                          (r + length + length2) * (r + length + length2)\n                          - deltaY * deltaY\n                      )\n                    : Math.abs(list[i].x - cx);\n                if (isDownList && deltaX >= lastDeltaX) {\n                    // 右下，左下\n                    deltaX = lastDeltaX - 10;\n                }\n                if (!isDownList && deltaX <= lastDeltaX) {\n                    // 右上，左上\n                    deltaX = lastDeltaX + 10;\n                }\n\n                list[i].x = cx + deltaX * dir;\n                lastDeltaX = deltaX;\n            }\n        }\n\n        var lastY = 0;\n        var delta;\n        var len = list.length;\n        var upList = [];\n        var downList = [];\n        for (var i = 0; i < len; i++) {\n            delta = list[i].y - lastY;\n            if (delta < 0) {\n                shiftDown(i, len, -delta, dir);\n            }\n            lastY = list[i].y + list[i].height;\n        }\n        if (viewHeight - lastY < 0) {\n            shiftUp(len - 1, lastY - viewHeight);\n        }\n        for (var i = 0; i < len; i++) {\n            if (list[i].y >= cy) {\n                downList.push(list[i]);\n            }\n            else {\n                upList.push(list[i]);\n            }\n        }\n        changeX(upList, false, cx, cy, r, dir);\n        changeX(downList, true, cx, cy, r, dir);\n    }\n\n    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {\n        var leftList = [];\n        var rightList = [];\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            if (labelLayoutList[i].x < cx) {\n                leftList.push(labelLayoutList[i]);\n            }\n            else {\n                rightList.push(labelLayoutList[i]);\n            }\n        }\n\n        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);\n        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);\n\n        for (var i = 0; i < labelLayoutList.length; i++) {\n            var linePoints = labelLayoutList[i].linePoints;\n            if (linePoints) {\n                var dist = linePoints[1][0] - linePoints[2][0];\n                if (labelLayoutList[i].x < cx) {\n                    linePoints[2][0] = labelLayoutList[i].x + 3;\n                }\n                else {\n                    linePoints[2][0] = labelLayoutList[i].x - 3;\n                }\n                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;\n                linePoints[1][0] = linePoints[2][0] + dist;\n            }\n        }\n    }\n\n    module.exports = function (seriesModel, r, viewWidth, viewHeight) {\n        var data = seriesModel.getData();\n        var labelLayoutList = [];\n        var cx;\n        var cy;\n        var hasLabelRotate = false;\n\n        data.each(function (idx) {\n            var layout = data.getItemLayout(idx);\n\n            var itemModel = data.getItemModel(idx);\n            var labelModel = itemModel.getModel('label.normal');\n            // Use position in normal or emphasis\n            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');\n\n            var labelLineModel = itemModel.getModel('labelLine.normal');\n            var labelLineLen = labelLineModel.get('length');\n            var labelLineLen2 = labelLineModel.get('length2');\n\n            var midAngle = (layout.startAngle + layout.endAngle) / 2;\n            var dx = Math.cos(midAngle);\n            var dy = Math.sin(midAngle);\n\n            var textX;\n            var textY;\n            var linePoints;\n            var textAlign;\n\n            cx = layout.cx;\n            cy = layout.cy;\n\n            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n            if (labelPosition === 'center') {\n                textX = layout.cx;\n                textY = layout.cy;\n                textAlign = 'center';\n            }\n            else {\n                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;\n                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;\n\n                textX = x1 + dx * 3;\n                textY = y1 + dy * 3;\n\n                if (!isLabelInside) {\n                    // For roseType\n                    var x2 = x1 + dx * (labelLineLen + r - layout.r);\n                    var y2 = y1 + dy * (labelLineLen + r - layout.r);\n                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);\n                    var y3 = y2;\n\n                    textX = x3 + (dx < 0 ? -5 : 5);\n                    textY = y3;\n                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n                }\n\n                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');\n            }\n            var font = labelModel.getModel('textStyle').getFont();\n\n            var labelRotate = labelModel.get('rotate')\n                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;\n            var text = seriesModel.getFormattedLabel(idx, 'normal')\n                        || data.getName(idx);\n            var textRect = textContain.getBoundingRect(\n                text, font, textAlign, 'top'\n            );\n            hasLabelRotate = !!labelRotate;\n            layout.label = {\n                x: textX,\n                y: textY,\n                position: labelPosition,\n                height: textRect.height,\n                len: labelLineLen,\n                len2: labelLineLen2,\n                linePoints: linePoints,\n                textAlign: textAlign,\n                verticalAlign: 'middle',\n                font: font,\n                rotation: labelRotate\n            };\n\n            // Not layout the inside label\n            if (!isLabelInside) {\n                labelLayoutList.push(layout.label);\n            }\n        });\n        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/pie/labelLayout.js\n// module id = 521\n// module chunks = 16","\n    module.exports = function (seriesType, ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (!legendModels || !legendModels.length) {\n            return;\n        }\n        ecModel.eachSeriesByType(seriesType, function (series) {\n            var data = series.getData();\n            data.filterSelf(function (idx) {\n                var name = data.getName(idx);\n                // If in any legend component the status is not selected.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(name)) {\n                        return false;\n                    }\n                }\n                return true;\n            }, this);\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/processor/dataFilter.js\n// module id = 522\n// module chunks = 16","\n    require('./gauge/GaugeSeries');\n    require('./gauge/GaugeView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/gauge.js\n// module id = 523\n// module chunks = 16","\n\n    var List = require('../../data/List');\n    var SeriesModel = require('../../model/Series');\n    var zrUtil = require('zrender/lib/core/util');\n\n    var GaugeSeries = SeriesModel.extend({\n\n        type: 'series.gauge',\n\n        getInitialData: function (option, ecModel) {\n            var list = new List(['value'], this);\n            var dataOpt = option.data || [];\n            if (!zrUtil.isArray(dataOpt)) {\n                dataOpt = [dataOpt];\n            }\n            // Only use the first data item\n            list.initData(dataOpt);\n            return list;\n        },\n\n        defaultOption: {\n            zlevel: 0,\n            z: 2,\n            // 默认全局居中\n            center: ['50%', '50%'],\n            legendHoverLink: true,\n            radius: '75%',\n            startAngle: 225,\n            endAngle: -45,\n            clockwise: true,\n            // 最小值\n            min: 0,\n            // 最大值\n            max: 100,\n            // 分割段数，默认为10\n            splitNumber: 10,\n            // 坐标轴线\n            axisLine: {\n                // 默认显示，属性show控制显示与否\n                show: true,\n                lineStyle: {       // 属性lineStyle控制线条样式\n                    color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],\n                    width: 30\n                }\n            },\n            // 分隔线\n            splitLine: {\n                // 默认显示，属性show控制显示与否\n                show: true,\n                // 属性length控制线长\n                length: 30,\n                // 属性lineStyle（详见lineStyle）控制线条样式\n                lineStyle: {\n                    color: '#eee',\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // 坐标轴小标记\n            axisTick: {\n                // 属性show控制显示与否，默认不显示\n                show: true,\n                // 每份split细分多少段\n                splitNumber: 5,\n                // 属性length控制线长\n                length: 8,\n                // 属性lineStyle控制线条样式\n                lineStyle: {\n                    color: '#eee',\n                    width: 1,\n                    type: 'solid'\n                }\n            },\n            axisLabel: {\n                show: true,\n                distance: 5,\n                // formatter: null,\n                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                    color: 'auto'\n                }\n            },\n            pointer: {\n                show: true,\n                length: '80%',\n                width: 8\n            },\n            itemStyle: {\n                normal: {\n                    color: 'auto'\n                }\n            },\n            title: {\n                show: true,\n                // x, y，单位px\n                offsetCenter: [0, '-40%'],\n                // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                textStyle: {\n                    color: '#333',\n                    fontSize: 15\n                }\n            },\n            detail: {\n                show: true,\n                backgroundColor: 'rgba(0,0,0,0)',\n                borderWidth: 0,\n                borderColor: '#ccc',\n                width: 100,\n                height: 40,\n                // x, y，单位px\n                offsetCenter: [0, '40%'],\n                // formatter: null,\n                // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n                textStyle: {\n                    color: 'auto',\n                    fontSize: 30\n                }\n            }\n        }\n    });\n\n    module.exports = GaugeSeries;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/gauge/GaugeSeries.js\n// module id = 524\n// module chunks = 16","\n\n    var PointerPath = require('./PointerPath');\n\n    var graphic = require('../../util/graphic');\n    var numberUtil = require('../../util/number');\n    var parsePercent = numberUtil.parsePercent;\n\n    function parsePosition(seriesModel, api) {\n        var center = seriesModel.get('center');\n        var width = api.getWidth();\n        var height = api.getHeight();\n        var size = Math.min(width, height);\n        var cx = parsePercent(center[0], api.getWidth());\n        var cy = parsePercent(center[1], api.getHeight());\n        var r = parsePercent(seriesModel.get('radius'), size / 2);\n\n        return {\n            cx: cx,\n            cy: cy,\n            r: r\n        };\n    }\n\n    function formatLabel(label, labelFormatter) {\n        if (labelFormatter) {\n            if (typeof labelFormatter === 'string') {\n                label = labelFormatter.replace('{value}', label);\n            }\n            else if (typeof labelFormatter === 'function') {\n                label = labelFormatter(label);\n            }\n        }\n\n        return label;\n    }\n\n    var PI2 = Math.PI * 2;\n\n    var GaugeView = require('../../view/Chart').extend({\n\n        type: 'gauge',\n\n        render: function (seriesModel, ecModel, api) {\n\n            this.group.removeAll();\n\n            var colorList = seriesModel.get('axisLine.lineStyle.color');\n            var posInfo = parsePosition(seriesModel, api);\n\n            this._renderMain(\n                seriesModel, ecModel, api, colorList, posInfo\n            );\n        },\n\n        dispose: function () {},\n\n        _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {\n            var group = this.group;\n\n            var axisLineModel = seriesModel.getModel('axisLine');\n            var lineStyleModel = axisLineModel.getModel('lineStyle');\n\n            var clockwise = seriesModel.get('clockwise');\n            var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n            var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n\n            var angleRangeSpan = (endAngle - startAngle) % PI2;\n\n            var prevEndAngle = startAngle;\n            var axisLineWidth = lineStyleModel.get('width');\n\n            for (var i = 0; i < colorList.length; i++) {\n                // Clamp\n                var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n                var endAngle = startAngle + angleRangeSpan * percent;\n                var sector = new graphic.Sector({\n                    shape: {\n                        startAngle: prevEndAngle,\n                        endAngle: endAngle,\n                        cx: posInfo.cx,\n                        cy: posInfo.cy,\n                        clockwise: clockwise,\n                        r0: posInfo.r - axisLineWidth,\n                        r: posInfo.r\n                    },\n                    silent: true\n                });\n\n                sector.setStyle({\n                    fill: colorList[i][1]\n                });\n\n                sector.setStyle(lineStyleModel.getLineStyle(\n                    // Because we use sector to simulate arc\n                    // so the properties for stroking are useless\n                    ['color', 'borderWidth', 'borderColor']\n                ));\n\n                group.add(sector);\n\n                prevEndAngle = endAngle;\n            }\n\n            var getColor = function (percent) {\n                // Less than 0\n                if (percent <= 0) {\n                    return colorList[0][1];\n                }\n                for (var i = 0; i < colorList.length; i++) {\n                    if (colorList[i][0] >= percent\n                        && (i === 0 ? 0 : colorList[i - 1][0]) < percent\n                    ) {\n                        return colorList[i][1];\n                    }\n                }\n                // More than 1\n                return colorList[i - 1][1];\n            };\n\n            if (!clockwise) {\n                var tmp = startAngle;\n                startAngle = endAngle;\n                endAngle = tmp;\n            }\n\n            this._renderTicks(\n                seriesModel, ecModel, api, getColor, posInfo,\n                startAngle, endAngle, clockwise\n            );\n\n            this._renderPointer(\n                seriesModel, ecModel, api, getColor, posInfo,\n                startAngle, endAngle, clockwise\n            );\n\n            this._renderTitle(\n                seriesModel, ecModel, api, getColor, posInfo\n            );\n            this._renderDetail(\n                seriesModel, ecModel, api, getColor, posInfo\n            );\n        },\n\n        _renderTicks: function (\n            seriesModel, ecModel, api, getColor, posInfo,\n            startAngle, endAngle, clockwise\n        ) {\n            var group = this.group;\n            var cx = posInfo.cx;\n            var cy = posInfo.cy;\n            var r = posInfo.r;\n\n            var minVal = seriesModel.get('min');\n            var maxVal = seriesModel.get('max');\n\n            var splitLineModel = seriesModel.getModel('splitLine');\n            var tickModel = seriesModel.getModel('axisTick');\n            var labelModel = seriesModel.getModel('axisLabel');\n\n            var splitNumber = seriesModel.get('splitNumber');\n            var subSplitNumber = tickModel.get('splitNumber');\n\n            var splitLineLen = parsePercent(\n                splitLineModel.get('length'), r\n            );\n            var tickLen = parsePercent(\n                tickModel.get('length'), r\n            );\n\n            var angle = startAngle;\n            var step = (endAngle - startAngle) / splitNumber;\n            var subStep = step / subSplitNumber;\n\n            var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n            var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n            var textStyleModel = labelModel.getModel('textStyle');\n\n            for (var i = 0; i <= splitNumber; i++) {\n                var unitX = Math.cos(angle);\n                var unitY = Math.sin(angle);\n                // Split line\n                if (splitLineModel.get('show')) {\n                    var splitLine = new graphic.Line({\n                        shape: {\n                            x1: unitX * r + cx,\n                            y1: unitY * r + cy,\n                            x2: unitX * (r - splitLineLen) + cx,\n                            y2: unitY * (r - splitLineLen) + cy\n                        },\n                        style: splitLineStyle,\n                        silent: true\n                    });\n                    if (splitLineStyle.stroke === 'auto') {\n                        splitLine.setStyle({\n                            stroke: getColor(i / splitNumber)\n                        });\n                    }\n\n                    group.add(splitLine);\n                }\n\n                // Label\n                if (labelModel.get('show')) {\n                    var label = formatLabel(\n                        numberUtil.round(i / splitNumber * (maxVal - minVal) + minVal),\n                        labelModel.get('formatter')\n                    );\n                    var distance = labelModel.get('distance');\n\n                    var text = new graphic.Text({\n                        style: {\n                            text: label,\n                            x: unitX * (r - splitLineLen - distance) + cx,\n                            y: unitY * (r - splitLineLen - distance) + cy,\n                            fill: textStyleModel.getTextColor(),\n                            textFont: textStyleModel.getFont(),\n                            textVerticalAlign: unitY < -0.4 ? 'top' : (unitY > 0.4 ? 'bottom' : 'middle'),\n                            textAlign: unitX < -0.4 ? 'left' : (unitX > 0.4 ? 'right' : 'center')\n                        },\n                        silent: true\n                    });\n                    if (text.style.fill === 'auto') {\n                        text.setStyle({\n                            fill: getColor(i / splitNumber)\n                        });\n                    }\n\n                    group.add(text);\n                }\n\n                // Axis tick\n                if (tickModel.get('show') && i !== splitNumber) {\n                    for (var j = 0; j <= subSplitNumber; j++) {\n                        var unitX = Math.cos(angle);\n                        var unitY = Math.sin(angle);\n                        var tickLine = new graphic.Line({\n                            shape: {\n                                x1: unitX * r + cx,\n                                y1: unitY * r + cy,\n                                x2: unitX * (r - tickLen) + cx,\n                                y2: unitY * (r - tickLen) + cy\n                            },\n                            silent: true,\n                            style: tickLineStyle\n                        });\n\n                        if (tickLineStyle.stroke === 'auto') {\n                            tickLine.setStyle({\n                                stroke: getColor((i + j / subSplitNumber) / splitNumber)\n                            });\n                        }\n\n                        group.add(tickLine);\n                        angle += subStep;\n                    }\n                    angle -= subStep;\n                }\n                else {\n                    angle += step;\n                }\n            }\n        },\n\n        _renderPointer: function (\n            seriesModel, ecModel, api, getColor, posInfo,\n            startAngle, endAngle, clockwise\n        ) {\n            var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];\n            var angleExtent = [startAngle, endAngle];\n\n            var data = seriesModel.getData();\n            var oldData = this._data;\n\n            var group = this.group;\n\n            data.diff(oldData)\n                .add(function (idx) {\n                    var pointer = new PointerPath({\n                        shape: {\n                            angle: startAngle\n                        }\n                    });\n\n                    graphic.updateProps(pointer, {\n                        shape: {\n                            angle: numberUtil.linearMap(data.get('value', idx), valueExtent, angleExtent, true)\n                        }\n                    }, seriesModel);\n\n                    group.add(pointer);\n                    data.setItemGraphicEl(idx, pointer);\n                })\n                .update(function (newIdx, oldIdx) {\n                    var pointer = oldData.getItemGraphicEl(oldIdx);\n\n                    graphic.updateProps(pointer, {\n                        shape: {\n                            angle: numberUtil.linearMap(data.get('value', newIdx), valueExtent, angleExtent, true)\n                        }\n                    }, seriesModel);\n\n                    group.add(pointer);\n                    data.setItemGraphicEl(newIdx, pointer);\n                })\n                .remove(function (idx) {\n                    var pointer = oldData.getItemGraphicEl(idx);\n                    group.remove(pointer);\n                })\n                .execute();\n\n            data.eachItemGraphicEl(function (pointer, idx) {\n                var itemModel = data.getItemModel(idx);\n                var pointerModel = itemModel.getModel('pointer');\n\n                pointer.setShape({\n                    x: posInfo.cx,\n                    y: posInfo.cy,\n                    width: parsePercent(\n                        pointerModel.get('width'), posInfo.r\n                    ),\n                    r: parsePercent(pointerModel.get('length'), posInfo.r)\n                });\n\n                pointer.useStyle(itemModel.getModel('itemStyle.normal').getItemStyle());\n\n                if (pointer.style.fill === 'auto') {\n                    pointer.setStyle('fill', getColor(\n                        (data.get('value', idx) - valueExtent[0]) / (valueExtent[1] - valueExtent[0])\n                    ));\n                }\n\n                graphic.setHoverStyle(\n                    pointer, itemModel.getModel('itemStyle.emphasis').getItemStyle()\n                );\n            });\n\n            this._data = data;\n        },\n\n        _renderTitle: function (\n            seriesModel, ecModel, api, getColor, posInfo\n        ) {\n            var titleModel = seriesModel.getModel('title');\n            if (titleModel.get('show')) {\n                var textStyleModel = titleModel.getModel('textStyle');\n                var offsetCenter = titleModel.get('offsetCenter');\n                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n                var text = new graphic.Text({\n                    style: {\n                        x: x,\n                        y: y,\n                        // FIXME First data name ?\n                        text: seriesModel.getData().getName(0),\n                        fill: textStyleModel.getTextColor(),\n                        textFont: textStyleModel.getFont(),\n                        textAlign: 'center',\n                        textVerticalAlign: 'middle'\n                    }\n                });\n                this.group.add(text);\n            }\n        },\n\n        _renderDetail: function (\n            seriesModel, ecModel, api, getColor, posInfo\n        ) {\n            var detailModel = seriesModel.getModel('detail');\n            var minVal = seriesModel.get('min');\n            var maxVal = seriesModel.get('max');\n            if (detailModel.get('show')) {\n                var textStyleModel = detailModel.getModel('textStyle');\n                var offsetCenter = detailModel.get('offsetCenter');\n                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);\n                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);\n                var width = parsePercent(detailModel.get('width'), posInfo.r);\n                var height = parsePercent(detailModel.get('height'), posInfo.r);\n                var value = seriesModel.getData().get('value', 0);\n                var rect = new graphic.Rect({\n                    shape: {\n                        x: x - width / 2,\n                        y: y - height / 2,\n                        width: width,\n                        height: height\n                    },\n                    style: {\n                        text: formatLabel(\n                            // FIXME First data name ?\n                            value, detailModel.get('formatter')\n                        ),\n                        fill: detailModel.get('backgroundColor'),\n                        textFill: textStyleModel.getTextColor(),\n                        textFont: textStyleModel.getFont()\n                    }\n                });\n                if (rect.style.textFill === 'auto') {\n                    rect.setStyle('textFill', getColor(\n                        numberUtil.linearMap(value, [minVal, maxVal], [0, 1], true)\n                    ));\n                }\n                rect.setStyle(detailModel.getItemStyle(['color']));\n                this.group.add(rect);\n            }\n        }\n    });\n\n    module.exports = GaugeView;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/gauge/GaugeView.js\n// module id = 525\n// module chunks = 16","\n\n    module.exports = require('zrender/lib/graphic/Path').extend({\n\n        type: 'echartsGaugePointer',\n\n        shape: {\n            angle: 0,\n\n            width: 10,\n\n            r: 10,\n\n            x: 0,\n\n            y: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var mathCos = Math.cos;\n            var mathSin = Math.sin;\n\n            var r = shape.r;\n            var width = shape.width;\n            var angle = shape.angle;\n            var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);\n            var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);\n\n            angle = shape.angle - Math.PI / 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(\n                shape.x + mathCos(angle) * width,\n                shape.y + mathSin(angle) * width\n            );\n            ctx.lineTo(\n                shape.x + mathCos(shape.angle) * r,\n                shape.y + mathSin(shape.angle) * r\n            );\n            ctx.lineTo(\n                shape.x - mathCos(angle) * width,\n                shape.y - mathSin(angle) * width\n            );\n            ctx.lineTo(x, y);\n            return;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/gauge/PointerPath.js\n// module id = 526\n// module chunks = 16","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n    var PRIORITY = echarts.PRIORITY;\n\n    require('./line/LineSeries');\n    require('./line/LineView');\n\n    echarts.registerVisual(zrUtil.curry(\n        require('../visual/symbol'), 'line', 'circle', 'line'\n    ));\n    echarts.registerLayout(zrUtil.curry(\n        require('../layout/points'), 'line'\n    ));\n\n    // Down sample after filter\n    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(\n        require('../processor/dataSample'), 'line'\n    ));\n\n    // In case developer forget to include grid component\n    require('../component/grid');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line.js\n// module id = 527\n// module chunks = 16","'use strict';\n\n\n    var createListFromArray = require('../helper/createListFromArray');\n    var SeriesModel = require('../../model/Series');\n\n    module.exports = SeriesModel.extend({\n\n        type: 'series.line',\n\n        dependencies: ['grid', 'polar'],\n\n        getInitialData: function (option, ecModel) {\n            if (__DEV__) {\n                var coordSys = option.coordinateSystem;\n                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {\n                    throw new Error('Line not support coordinateSystem besides cartesian and polar');\n                }\n            }\n            return createListFromArray(option.data, this, ecModel);\n        },\n\n        defaultOption: {\n            zlevel: 0,                  // 一级层叠\n            z: 2,                       // 二级层叠\n            coordinateSystem: 'cartesian2d',\n            legendHoverLink: true,\n\n            hoverAnimation: true,\n            // stack: null\n            // xAxisIndex: 0,\n            // yAxisIndex: 0,\n\n            // polarIndex: 0,\n\n            // If clip the overflow value\n            clipOverflow: true,\n\n            label: {\n                normal: {\n                    position: 'top'\n                }\n            },\n            // itemStyle: {\n            //     normal: {},\n            //     emphasis: {}\n            // },\n            lineStyle: {\n                normal: {\n                    width: 2,\n                    type: 'solid'\n                }\n            },\n            // areaStyle: {},\n            // false, 'start', 'end', 'middle'\n            step: false,\n\n            // Disabled if step is true\n            smooth: false,\n            smoothMonotone: null,\n            // 拐点图形类型\n            symbol: 'emptyCircle',\n            // 拐点图形大小\n            symbolSize: 4,\n            // 拐点图形旋转控制\n            symbolRotate: null,\n\n            // 是否显示 symbol, 只有在 tooltip hover 的时候显示\n            showSymbol: true,\n            // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）\n            showAllSymbol: false,\n\n            // 是否连接断点\n            connectNulls: false,\n\n            // 数据过滤，'average', 'max', 'min', 'sum'\n            sampling: 'none',\n\n            animationEasing: 'linear',\n\n            // Disable progressive\n            progressive: 0,\n            hoverLayerThreshold: Infinity\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/LineSeries.js\n// module id = 528\n// module chunks = 16","'use strict';\n\n\n    var List = require('../../data/List');\n    var completeDimensions = require('../../data/helper/completeDimensions');\n    var zrUtil = require('zrender/lib/core/util');\n    var modelUtil = require('../../util/model');\n    var CoordinateSystem = require('../../CoordinateSystem');\n    var getDataItemValue = modelUtil.getDataItemValue;\n    var converDataValue = modelUtil.converDataValue;\n\n    function firstDataNotNull(data) {\n        var i = 0;\n        while (i < data.length && data[i] == null) {\n            i++;\n        }\n        return data[i];\n    }\n    function ifNeedCompleteOrdinalData(data) {\n        var sampleItem = firstDataNotNull(data);\n        return sampleItem != null\n            && !zrUtil.isArray(getDataItemValue(sampleItem));\n    }\n\n    /**\n     * Helper function to create a list from option data\n     */\n    function createListFromArray(data, seriesModel, ecModel) {\n        // If data is undefined\n        data = data || [];\n\n        if (__DEV__) {\n            if (!zrUtil.isArray(data)) {\n                throw new Error('Invalid data.');\n            }\n        }\n\n        var coordSysName = seriesModel.get('coordinateSystem');\n        var creator = creators[coordSysName];\n        var registeredCoordSys = CoordinateSystem.get(coordSysName);\n        // FIXME\n        var axesInfo = creator && creator(data, seriesModel, ecModel);\n        var dimensions = axesInfo && axesInfo.dimensions;\n        if (!dimensions) {\n            // Get dimensions from registered coordinate system\n            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];\n            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));\n        }\n        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;\n\n        var list = new List(dimensions, seriesModel);\n\n        var nameList = createNameList(axesInfo, data);\n\n        var categories = {};\n        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))\n            ? function (itemOpt, dimName, dataIndex, dimIndex) {\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                // Use dataIndex as ordinal value in categoryAxis\n                return dimIndex === categoryIndex\n                    ? dataIndex\n                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);\n            }\n            : function (itemOpt, dimName, dataIndex, dimIndex) {\n                var value = getDataItemValue(itemOpt);\n                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);\n                // If any dataItem is like { value: 10 }\n                if (modelUtil.isDataItemOption(itemOpt)) {\n                    list.hasItemOption = true;\n                }\n\n                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;\n                if (categoryAxesModels && categoryAxesModels[dimName]) {\n                    // If given value is a category string\n                    if (typeof val === 'string') {\n                        // Lazy get categories\n                        categories[dimName] = categories[dimName]\n                            || categoryAxesModels[dimName].getCategories();\n                        val = zrUtil.indexOf(categories[dimName], val);\n                        if (val < 0 && !isNaN(val)) {\n                            // In case some one write '1', '2' istead of 1, 2\n                            val = +val;\n                        }\n                    }\n                }\n                return val;\n            };\n\n        list.hasItemOption = false;\n        list.initData(data, nameList, dimValueGetter);\n\n        return list;\n    }\n\n    function isStackable(axisType) {\n        return axisType !== 'category' && axisType !== 'time';\n    }\n\n    function getDimTypeByAxis(axisType) {\n        return axisType === 'category'\n            ? 'ordinal'\n            : axisType === 'time'\n            ? 'time'\n            : 'float';\n    }\n\n    /**\n     * Creaters for each coord system.\n     */\n    var creators = {\n\n        cartesian2d: function (data, seriesModel, ecModel) {\n\n            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {\n                return ecModel.queryComponents({\n                    mainType: name,\n                    index: seriesModel.get(name + 'Index'),\n                    id: seriesModel.get(name + 'Id')\n                })[0];\n            });\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            if (__DEV__) {\n                if (!xAxisModel) {\n                    throw new Error('xAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('xAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n                if (!yAxisModel) {\n                    throw new Error('yAxis \"' + zrUtil.retrieve(\n                        seriesModel.get('xAxisIndex'),\n                        seriesModel.get('yAxisId'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n\n            var xAxisType = xAxisModel.get('type');\n            var yAxisType = yAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'x',\n                    type: getDimTypeByAxis(xAxisType),\n                    stackable: isStackable(xAxisType)\n                },\n                {\n                    name: 'y',\n                    // If two category axes\n                    type: getDimTypeByAxis(yAxisType),\n                    stackable: isStackable(yAxisType)\n                }\n            ];\n\n            var isXAxisCateogry = xAxisType === 'category';\n            var isYAxisCategory = yAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['x', 'y', 'z']);\n\n            var categoryAxesModels = {};\n            if (isXAxisCateogry) {\n                categoryAxesModels.x = xAxisModel;\n            }\n            if (isYAxisCategory) {\n                categoryAxesModels.y = yAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        polar: function (data, seriesModel, ecModel) {\n            var polarModel = ecModel.queryComponents({\n                mainType: 'polar',\n                index: seriesModel.get('polarIndex'),\n                id: seriesModel.get('polarId')\n            })[0];\n\n            var angleAxisModel = polarModel.findAxisModel('angleAxis');\n            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n\n            if (__DEV__) {\n                if (!angleAxisModel) {\n                    throw new Error('angleAxis option not found');\n                }\n                if (!radiusAxisModel) {\n                    throw new Error('radiusAxis option not found');\n                }\n            }\n\n            var radiusAxisType = radiusAxisModel.get('type');\n            var angleAxisType = angleAxisModel.get('type');\n\n            var dimensions = [\n                {\n                    name: 'radius',\n                    type: getDimTypeByAxis(radiusAxisType),\n                    stackable: isStackable(radiusAxisType)\n                },\n                {\n                    name: 'angle',\n                    type: getDimTypeByAxis(angleAxisType),\n                    stackable: isStackable(angleAxisType)\n                }\n            ];\n            var isAngleAxisCateogry = angleAxisType === 'category';\n            var isRadiusAxisCateogry = radiusAxisType === 'category';\n\n            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);\n\n            var categoryAxesModels = {};\n            if (isRadiusAxisCateogry) {\n                categoryAxesModels.radius = radiusAxisModel;\n            }\n            if (isAngleAxisCateogry) {\n                categoryAxesModels.angle = angleAxisModel;\n            }\n            return {\n                dimensions: dimensions,\n                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),\n                categoryAxesModels: categoryAxesModels\n            };\n        },\n\n        geo: function (data, seriesModel, ecModel) {\n            // TODO Region\n            // 多个散点图系列在同一个地区的时候\n            return {\n                dimensions: completeDimensions([\n                    {name: 'lng'},\n                    {name: 'lat'}\n                ], data, ['lng', 'lat', 'value'])\n            };\n        }\n    };\n\n    function createNameList(result, data) {\n        var nameList = [];\n\n        var categoryDim = result && result.dimensions[result.categoryIndex];\n        var categoryAxisModel;\n        if (categoryDim) {\n            categoryAxisModel = result.categoryAxesModels[categoryDim.name];\n        }\n\n        if (categoryAxisModel) {\n            // FIXME Two category axis\n            var categories = categoryAxisModel.getCategories();\n            if (categories) {\n                var dataLen = data.length;\n                // Ordered data is given explicitly like\n                // [[3, 0.2], [1, 0.3], [2, 0.15]]\n                // or given scatter data,\n                // pick the category\n                if (zrUtil.isArray(data[0]) && data[0].length > 1) {\n                    nameList = [];\n                    for (var i = 0; i < dataLen; i++) {\n                        nameList[i] = categories[data[i][result.categoryIndex || 0]];\n                    }\n                }\n                else {\n                    nameList = categories.slice(0);\n                }\n            }\n        }\n\n        return nameList;\n    }\n\n    module.exports = createListFromArray;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/createListFromArray.js\n// module id = 529\n// module chunks = 16","'use strict';\n// FIXME step not support polar\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var SymbolDraw = require('../helper/SymbolDraw');\n    var Symbol = require('../helper/Symbol');\n    var lineAnimationDiff = require('./lineAnimationDiff');\n    var graphic = require('../../util/graphic');\n    var modelUtil = require('../../util/model');\n\n    var polyHelper = require('./poly');\n\n    var ChartView = require('../../view/Chart');\n\n    function isPointsSame(points1, points2) {\n        if (points1.length !== points2.length) {\n            return;\n        }\n        for (var i = 0; i < points1.length; i++) {\n            var p1 = points1[i];\n            var p2 = points2[i];\n            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {\n                return;\n            }\n        }\n        return true;\n    }\n\n    function getSmooth(smooth) {\n        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);\n    }\n\n    function getAxisExtentWithGap(axis) {\n        var extent = axis.getGlobalExtent();\n        if (axis.onBand) {\n            // Remove extra 1px to avoid line miter in clipped edge\n            var halfBandWidth = axis.getBandWidth() / 2 - 1;\n            var dir = extent[1] > extent[0] ? 1 : -1;\n            extent[0] += dir * halfBandWidth;\n            extent[1] -= dir * halfBandWidth;\n        }\n        return extent;\n    }\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n    /**\n     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys\n     * @param {module:echarts/data/List} data\n     * @param {Array.<Array.<number>>} points\n     * @private\n     */\n    function getStackedOnPoints(coordSys, data) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        return data.mapArray([valueDim], function (val, idx) {\n            var stackedOnSameSign;\n            var stackedOn = data.stackedOn;\n            // Find first stacked value with same sign\n            while (stackedOn &&\n                sign(stackedOn.get(valueDim, idx)) === sign(val)\n            ) {\n                stackedOnSameSign = stackedOn;\n                break;\n            }\n            var stackedData = [];\n            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n            stackedData[1 - baseDataOffset] = stackedOnSameSign\n                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n            return coordSys.dataToPoint(stackedData);\n        }, true);\n    }\n\n    function createGridClipShape(cartesian, hasAnimation, seriesModel) {\n        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));\n        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));\n        var isHorizontal = cartesian.getBaseAxis().isHorizontal();\n\n        var x = Math.min(xExtent[0], xExtent[1]);\n        var y = Math.min(yExtent[0], yExtent[1]);\n        var width = Math.max(xExtent[0], xExtent[1]) - x;\n        var height = Math.max(yExtent[0], yExtent[1]) - y;\n        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;\n        // Expand clip shape to avoid clipping when line value exceeds axis\n        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);\n        if (isHorizontal) {\n            y -= expandSize;\n            height += expandSize * 2;\n        }\n        else {\n            x -= expandSize;\n            width += expandSize * 2;\n        }\n\n        var clipPath = new graphic.Rect({\n            shape: {\n                x: x,\n                y: y,\n                width: width,\n                height: height\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;\n            graphic.initProps(clipPath, {\n                shape: {\n                    width: width,\n                    height: height\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createPolarClipShape(polar, hasAnimation, seriesModel) {\n        var angleAxis = polar.getAngleAxis();\n        var radiusAxis = polar.getRadiusAxis();\n\n        var radiusExtent = radiusAxis.getExtent();\n        var angleExtent = angleAxis.getExtent();\n\n        var RADIAN = Math.PI / 180;\n\n        var clipPath = new graphic.Sector({\n            shape: {\n                cx: polar.cx,\n                cy: polar.cy,\n                r0: radiusExtent[0],\n                r: radiusExtent[1],\n                startAngle: -angleExtent[0] * RADIAN,\n                endAngle: -angleExtent[1] * RADIAN,\n                clockwise: angleAxis.inverse\n            }\n        });\n\n        if (hasAnimation) {\n            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;\n            graphic.initProps(clipPath, {\n                shape: {\n                    endAngle: -angleExtent[1] * RADIAN\n                }\n            }, seriesModel);\n        }\n\n        return clipPath;\n    }\n\n    function createClipShape(coordSys, hasAnimation, seriesModel) {\n        return coordSys.type === 'polar'\n            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)\n            : createGridClipShape(coordSys, hasAnimation, seriesModel);\n    }\n\n    function turnPointsIntoStep(points, coordSys, stepTurnAt) {\n        var baseAxis = coordSys.getBaseAxis();\n        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n        var stepPoints = [];\n        for (var i = 0; i < points.length - 1; i++) {\n            var nextPt = points[i + 1];\n            var pt = points[i];\n            stepPoints.push(pt);\n\n            var stepPt = [];\n            switch (stepTurnAt) {\n                case 'end':\n                    stepPt[baseIndex] = nextPt[baseIndex];\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n                    break;\n                case 'middle':\n                    // default is start\n                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;\n                    var stepPt2 = [];\n                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;\n                    stepPt[1 - baseIndex] = pt[1 - baseIndex];\n                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];\n                    stepPoints.push(stepPt);\n                    stepPoints.push(stepPt2);\n                    break;\n                default:\n                    stepPt[baseIndex] = pt[baseIndex];\n                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];\n                    // default is start\n                    stepPoints.push(stepPt);\n            }\n        }\n        // Last points\n        points[i] && stepPoints.push(points[i]);\n        return stepPoints;\n    }\n\n    function clamp(number, extent) {\n        return Math.max(Math.min(number, extent[1]), extent[0]);\n    }\n\n    function getVisualGradient(data, coordSys) {\n        var visualMetaList = data.getVisual('visualMeta');\n        if (!visualMetaList || !visualMetaList.length || !data.count()) {\n            // When data.count() is 0, gradient range can not be calculated.\n            return;\n        }\n\n        var visualMeta;\n        for (var i = visualMetaList.length - 1; i >= 0; i--) {\n            // Can only be x or y\n            if (visualMetaList[i].dimension < 2) {\n                visualMeta = visualMetaList[i];\n                break;\n            }\n        }\n        if (!visualMeta || coordSys.type !== 'cartesian2d') {\n            if (__DEV__) {\n                console.warn('Visual map on line style only support x or y dimension.');\n            }\n            return;\n        }\n\n        var dimension = visualMeta.dimension;\n        var dimName = data.dimensions[dimension];\n        var dataExtent = data.getDataExtent(dimName);\n\n        var stops = visualMeta.stops;\n\n        var colorStops = [];\n        if (stops[0].interval) {\n            stops.sort(function (a, b) {\n                return a.interval[0] - b.interval[0];\n            });\n        }\n\n        var firstStop = stops[0];\n        var lastStop = stops[stops.length - 1];\n        // Interval can be infinity in piecewise case\n        var min = firstStop.interval ? clamp(firstStop.interval[0], dataExtent) : firstStop.value;\n        var max = lastStop.interval ? clamp(lastStop.interval[1], dataExtent) : lastStop.value;\n        var stopsSpan = max - min;\n\n        // In the piecewise case data out of visual range\n        // ----dataMin----dataMax-----visualMin----visualMax\n        if (stopsSpan === 0) {\n            return data.getItemVisual(0, 'color');\n        }\n        for (var i = 0; i < stops.length; i++) {\n            // Piecewise\n            if (stops[i].interval) {\n                if (stops[i].interval[1] === stops[i].interval[0]) {\n                    continue;\n                }\n                colorStops.push({\n                    // Make sure offset is between 0 and 1\n                    offset: (clamp(stops[i].interval[0], dataExtent) - min) / stopsSpan,\n                    color: stops[i].color\n                }, {\n                    offset: (clamp(stops[i].interval[1], dataExtent) - min) / stopsSpan,\n                    color: stops[i].color\n                });\n            }\n            // Continous\n            else {\n                // if (i > 0 && stops[i].value === stops[i - 1].value) {\n                //     continue;\n                // }\n                colorStops.push({\n                    offset: (stops[i].value - min) / stopsSpan,\n                    color: stops[i].color\n                });\n            }\n        }\n\n        var gradient = new graphic.LinearGradient(\n            0, 0, 0, 0, colorStops, true\n        );\n        var axis = coordSys.getAxis(dimName);\n\n        var start = axis.toGlobalCoord(axis.dataToCoord(min));\n        var end = axis.toGlobalCoord(axis.dataToCoord(max));\n        // zrUtil.each(colorStops, function (colorStop) {\n        //     // Make sure each offset has rounded px to avoid not sharp edge\n        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);\n        // });\n\n        gradient[dimName] = start;\n        gradient[dimName + '2'] = end;\n\n        return gradient;\n    }\n\n    module.exports = ChartView.extend({\n\n        type: 'line',\n\n        init: function () {\n            var lineGroup = new graphic.Group();\n\n            var symbolDraw = new SymbolDraw();\n            this.group.add(symbolDraw.group);\n\n            this._symbolDraw = symbolDraw;\n            this._lineGroup = lineGroup;\n        },\n\n        render: function (seriesModel, ecModel, api) {\n            var coordSys = seriesModel.coordinateSystem;\n            var group = this.group;\n            var data = seriesModel.getData();\n            var lineStyleModel = seriesModel.getModel('lineStyle.normal');\n            var areaStyleModel = seriesModel.getModel('areaStyle.normal');\n\n            var points = data.mapArray(data.getItemLayout, true);\n\n            var isCoordSysPolar = coordSys.type === 'polar';\n            var prevCoordSys = this._coordSys;\n\n            var symbolDraw = this._symbolDraw;\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n\n            var lineGroup = this._lineGroup;\n\n            var hasAnimation = seriesModel.get('animation');\n\n            var isAreaChart = !areaStyleModel.isEmpty();\n            var stackedOnPoints = getStackedOnPoints(coordSys, data);\n\n            var showSymbol = seriesModel.get('showSymbol');\n\n            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')\n                && this._getSymbolIgnoreFunc(data, coordSys);\n\n            // Remove temporary symbols\n            var oldData = this._data;\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            // Remove previous created symbols if showSymbol changed to false\n            if (!showSymbol) {\n                symbolDraw.remove();\n            }\n\n            group.add(lineGroup);\n\n            // FIXME step not support polar\n            var step = !isCoordSysPolar && seriesModel.get('step');\n            // Initialization animation or coordinate system changed\n            if (\n                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)\n            ) {\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                if (step) {\n                    // TODO If stacked series is not step\n                    points = turnPointsIntoStep(points, coordSys, step);\n                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                }\n\n                polyline = this._newPolyline(points, coordSys, hasAnimation);\n                if (isAreaChart) {\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));\n            }\n            else {\n                if (isAreaChart && !polygon) {\n                    // If areaStyle is added\n                    polygon = this._newPolygon(\n                        points, stackedOnPoints,\n                        coordSys, hasAnimation\n                    );\n                }\n                else if (polygon && !isAreaChart) {\n                    // If areaStyle is removed\n                    lineGroup.remove(polygon);\n                    polygon = this._polygon = null;\n                }\n\n                // Update clipPath\n                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));\n\n                // Always update, or it is wrong in the case turning on legend\n                // because points are not changed\n                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);\n\n                // Stop symbol animation and sync with line points\n                // FIXME performance?\n                data.eachItemGraphicEl(function (el) {\n                    el.stopAnimation(true);\n                });\n\n                // In the case data zoom triggerred refreshing frequently\n                // Data may not change if line has a category axis. So it should animate nothing\n                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)\n                    || !isPointsSame(this._points, points)\n                ) {\n                    if (hasAnimation) {\n                        this._updateAnimation(\n                            data, stackedOnPoints, coordSys, api, step\n                        );\n                    }\n                    else {\n                        // Not do it in update with animation\n                        if (step) {\n                            // TODO If stacked series is not step\n                            points = turnPointsIntoStep(points, coordSys, step);\n                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);\n                        }\n\n                        polyline.setShape({\n                            points: points\n                        });\n                        polygon && polygon.setShape({\n                            points: points,\n                            stackedOnPoints: stackedOnPoints\n                        });\n                    }\n                }\n            }\n\n            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');\n\n            polyline.useStyle(zrUtil.defaults(\n                // Use color in lineStyle first\n                lineStyleModel.getLineStyle(),\n                {\n                    fill: 'none',\n                    stroke: visualColor,\n                    lineJoin: 'bevel'\n                }\n            ));\n\n            var smooth = seriesModel.get('smooth');\n            smooth = getSmooth(seriesModel.get('smooth'));\n            polyline.setShape({\n                smooth: smooth,\n                smoothMonotone: seriesModel.get('smoothMonotone'),\n                connectNulls: seriesModel.get('connectNulls')\n            });\n\n            if (polygon) {\n                var stackedOn = data.stackedOn;\n                var stackedOnSmooth = 0;\n\n                polygon.useStyle(zrUtil.defaults(\n                    areaStyleModel.getAreaStyle(),\n                    {\n                        fill: visualColor,\n                        opacity: 0.7,\n                        lineJoin: 'bevel'\n                    }\n                ));\n\n                if (stackedOn) {\n                    var stackedOnSeries = stackedOn.hostModel;\n                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));\n                }\n\n                polygon.setShape({\n                    smooth: smooth,\n                    stackedOnSmooth: stackedOnSmooth,\n                    smoothMonotone: seriesModel.get('smoothMonotone'),\n                    connectNulls: seriesModel.get('connectNulls')\n                });\n            }\n\n            this._data = data;\n            // Save the coordinate system for transition animation when data changed\n            this._coordSys = coordSys;\n            this._stackedOnPoints = stackedOnPoints;\n            this._points = points;\n            this._step = step;\n        },\n\n        dispose: function () {},\n\n        highlight: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n\n            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (!symbol) {\n                    // Create a temporary symbol if it is not exists\n                    var pt = data.getItemLayout(dataIndex);\n                    symbol = new Symbol(data, dataIndex);\n                    symbol.position = pt;\n                    symbol.setZ(\n                        seriesModel.get('zlevel'),\n                        seriesModel.get('z')\n                    );\n                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);\n                    symbol.__temp = true;\n                    data.setItemGraphicEl(dataIndex, symbol);\n\n                    // Stop scale animation\n                    symbol.stopSymbolAnimation(true);\n\n                    this.group.add(symbol);\n                }\n                symbol.highlight();\n            }\n            else {\n                // Highlight whole series\n                ChartView.prototype.highlight.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        downplay: function (seriesModel, ecModel, api, payload) {\n            var data = seriesModel.getData();\n            var dataIndex = modelUtil.queryDataIndex(data, payload);\n            if (dataIndex != null && dataIndex >= 0) {\n                var symbol = data.getItemGraphicEl(dataIndex);\n                if (symbol) {\n                    if (symbol.__temp) {\n                        data.setItemGraphicEl(dataIndex, null);\n                        this.group.remove(symbol);\n                    }\n                    else {\n                        symbol.downplay();\n                    }\n                }\n            }\n            else {\n                // Downplay whole series\n                ChartView.prototype.downplay.call(\n                    this, seriesModel, ecModel, api, payload\n                );\n            }\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolyline: function (points) {\n            var polyline = this._polyline;\n            // Remove previous created polyline\n            if (polyline) {\n                this._lineGroup.remove(polyline);\n            }\n\n            polyline = new polyHelper.Polyline({\n                shape: {\n                    points: points\n                },\n                silent: true,\n                z2: 10\n            });\n\n            this._lineGroup.add(polyline);\n\n            this._polyline = polyline;\n\n            return polyline;\n        },\n\n        /**\n         * @param {module:zrender/container/Group} group\n         * @param {Array.<Array.<number>>} stackedOnPoints\n         * @param {Array.<Array.<number>>} points\n         * @private\n         */\n        _newPolygon: function (points, stackedOnPoints) {\n            var polygon = this._polygon;\n            // Remove previous created polygon\n            if (polygon) {\n                this._lineGroup.remove(polygon);\n            }\n\n            polygon = new polyHelper.Polygon({\n                shape: {\n                    points: points,\n                    stackedOnPoints: stackedOnPoints\n                },\n                silent: true\n            });\n\n            this._lineGroup.add(polygon);\n\n            this._polygon = polygon;\n            return polygon;\n        },\n        /**\n         * @private\n         */\n        _getSymbolIgnoreFunc: function (data, coordSys) {\n            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];\n            // `getLabelInterval` is provided by echarts/component/axis\n            if (categoryAxis && categoryAxis.isLabelIgnored) {\n                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);\n            }\n        },\n\n        /**\n         * @private\n         */\n        // FIXME Two value axis\n        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {\n            var polyline = this._polyline;\n            var polygon = this._polygon;\n            var seriesModel = data.hostModel;\n\n            var diff = lineAnimationDiff(\n                this._data, data,\n                this._stackedOnPoints, stackedOnPoints,\n                this._coordSys, coordSys\n            );\n\n            var current = diff.current;\n            var stackedOnCurrent = diff.stackedOnCurrent;\n            var next = diff.next;\n            var stackedOnNext = diff.stackedOnNext;\n            if (step) {\n                // TODO If stacked series is not step\n                current = turnPointsIntoStep(diff.current, coordSys, step);\n                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);\n                next = turnPointsIntoStep(diff.next, coordSys, step);\n                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);\n            }\n            // `diff.current` is subset of `current` (which should be ensured by\n            // turnPointsIntoStep), so points in `__points` can be updated when\n            // points in `current` are update during animation.\n            polyline.shape.__points = diff.current;\n            polyline.shape.points = current;\n\n            graphic.updateProps(polyline, {\n                shape: {\n                    points: next\n                }\n            }, seriesModel);\n\n            if (polygon) {\n                polygon.setShape({\n                    points: current,\n                    stackedOnPoints: stackedOnCurrent\n                });\n                graphic.updateProps(polygon, {\n                    shape: {\n                        points: next,\n                        stackedOnPoints: stackedOnNext\n                    }\n                }, seriesModel);\n            }\n\n            var updatedDataInfo = [];\n            var diffStatus = diff.status;\n\n            for (var i = 0; i < diffStatus.length; i++) {\n                var cmd = diffStatus[i].cmd;\n                if (cmd === '=') {\n                    var el = data.getItemGraphicEl(diffStatus[i].idx1);\n                    if (el) {\n                        updatedDataInfo.push({\n                            el: el,\n                            ptIdx: i    // Index of points\n                        });\n                    }\n                }\n            }\n\n            if (polyline.animators && polyline.animators.length) {\n                polyline.animators[0].during(function () {\n                    for (var i = 0; i < updatedDataInfo.length; i++) {\n                        var el = updatedDataInfo[i].el;\n                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);\n                    }\n                });\n            }\n        },\n\n        remove: function (ecModel) {\n            var group = this.group;\n            var oldData = this._data;\n            this._lineGroup.removeAll();\n            this._symbolDraw.remove(true);\n            // Remove temporary created elements when highlighting\n            oldData && oldData.eachItemGraphicEl(function (el, idx) {\n                if (el.__temp) {\n                    group.remove(el);\n                    oldData.setItemGraphicEl(idx, null);\n                }\n            });\n\n            this._polyline =\n            this._polygon =\n            this._coordSys =\n            this._points =\n            this._stackedOnPoints =\n            this._data = null;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/LineView.js\n// module id = 530\n// module chunks = 16","/**\n * @module echarts/chart/helper/SymbolDraw\n */\n\n\n    var graphic = require('../../util/graphic');\n    var Symbol = require('./Symbol');\n\n    /**\n     * @constructor\n     * @alias module:echarts/chart/helper/SymbolDraw\n     * @param {module:zrender/graphic/Group} [symbolCtor]\n     */\n    function SymbolDraw(symbolCtor) {\n        this.group = new graphic.Group();\n\n        this._symbolCtor = symbolCtor || Symbol;\n    }\n\n    var symbolDrawProto = SymbolDraw.prototype;\n\n    function symbolNeedsDraw(data, idx, isIgnore) {\n        var point = data.getItemLayout(idx);\n        // Is an object\n        // if (point && point.hasOwnProperty('point')) {\n        //     point = point.point;\n        // }\n        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))\n                    && data.getItemVisual(idx, 'symbol') !== 'none';\n    }\n    /**\n     * Update symbols draw by new data\n     * @param {module:echarts/data/List} data\n     * @param {Array.<boolean>} [isIgnore]\n     */\n    symbolDrawProto.updateData = function (data, isIgnore) {\n        var group = this.group;\n        var seriesModel = data.hostModel;\n        var oldData = this._data;\n\n        var SymbolCtor = this._symbolCtor;\n\n        var seriesScope = {\n            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),\n            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),\n            symbolRotate: seriesModel.get('symbolRotate'),\n            symbolOffset: seriesModel.get('symbolOffset'),\n            hoverAnimation: seriesModel.get('hoverAnimation'),\n\n            labelModel: seriesModel.getModel('label.normal'),\n            hoverLabelModel: seriesModel.getModel('label.emphasis')\n        };\n\n        data.diff(oldData)\n            .add(function (newIdx) {\n                var point = data.getItemLayout(newIdx);\n                if (symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);\n                    symbolEl.attr('position', point);\n                    data.setItemGraphicEl(newIdx, symbolEl);\n                    group.add(symbolEl);\n                }\n            })\n            .update(function (newIdx, oldIdx) {\n                var symbolEl = oldData.getItemGraphicEl(oldIdx);\n                var point = data.getItemLayout(newIdx);\n                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {\n                    group.remove(symbolEl);\n                    return;\n                }\n                if (!symbolEl) {\n                    symbolEl = new SymbolCtor(data, newIdx);\n                    symbolEl.attr('position', point);\n                }\n                else {\n                    symbolEl.updateData(data, newIdx, seriesScope);\n                    graphic.updateProps(symbolEl, {\n                        position: point\n                    }, seriesModel);\n                }\n\n                // Add back\n                group.add(symbolEl);\n\n                data.setItemGraphicEl(newIdx, symbolEl);\n            })\n            .remove(function (oldIdx) {\n                var el = oldData.getItemGraphicEl(oldIdx);\n                el && el.fadeOut(function () {\n                    group.remove(el);\n                });\n            })\n            .execute();\n\n        this._data = data;\n    };\n\n    symbolDrawProto.updateLayout = function () {\n        var data = this._data;\n        if (data) {\n            // Not use animation\n            data.eachItemGraphicEl(function (el, idx) {\n                var point = data.getItemLayout(idx);\n                el.attr('position', point);\n            });\n        }\n    };\n\n    symbolDrawProto.remove = function (enableAnimation) {\n        var group = this.group;\n        var data = this._data;\n        if (data) {\n            if (enableAnimation) {\n                data.eachItemGraphicEl(function (el) {\n                    el.fadeOut(function () {\n                        group.remove(el);\n                    });\n                });\n            }\n            else {\n                group.removeAll();\n            }\n        }\n    };\n\n    module.exports = SymbolDraw;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/SymbolDraw.js\n// module id = 531\n// module chunks = 16","/**\n * @module echarts/chart/helper/Symbol\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolUtil = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var numberUtil = require('../../util/number');\n\n    function normalizeSymbolSize(symbolSize) {\n        symbolSize = symbolSize instanceof Array\n            ? symbolSize.slice()\n            : [+symbolSize, +symbolSize];\n        symbolSize[0] /= 2;\n        symbolSize[1] /= 2;\n        return symbolSize;\n    }\n\n    /**\n     * @constructor\n     * @alias {module:echarts/chart/helper/Symbol}\n     * @param {module:echarts/data/List} data\n     * @param {number} idx\n     * @extends {module:zrender/graphic/Group}\n     */\n    function Symbol(data, idx, seriesScope) {\n        graphic.Group.call(this);\n\n        this.updateData(data, idx, seriesScope);\n    }\n\n    var symbolProto = Symbol.prototype;\n\n    function driftSymbol(dx, dy) {\n        this.parent.drift(dx, dy);\n    }\n\n    symbolProto._createSymbol = function (symbolType, data, idx) {\n        // Remove paths created before\n        this.removeAll();\n\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // var symbolPath = symbolUtil.createSymbol(\n        //     symbolType, -0.5, -0.5, 1, 1, color\n        // );\n        // If width/height are set too small (e.g., set to 1) on ios10\n        // and macOS Sierra, a circle stroke become a rect, no matter what\n        // the scale is set. So we set width/height as 2. See #4150.\n        var symbolPath = symbolUtil.createSymbol(\n            symbolType, -1, -1, 2, 2, color\n        );\n\n        symbolPath.attr({\n            z2: 100,\n            culling: true,\n            scale: [0, 0]\n        });\n        // Rewrite drift method\n        symbolPath.drift = driftSymbol;\n\n        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\n        graphic.initProps(symbolPath, {\n            scale: size\n        }, seriesModel, idx);\n        this._symbolType = symbolType;\n\n        this.add(symbolPath);\n    };\n\n    /**\n     * Stop animation\n     * @param {boolean} toLastFrame\n     */\n    symbolProto.stopSymbolAnimation = function (toLastFrame) {\n        this.childAt(0).stopAnimation(toLastFrame);\n    };\n\n    /**\n     * Get symbol path element\n     */\n    symbolProto.getSymbolPath = function () {\n        return this.childAt(0);\n    };\n\n    /**\n     * Get scale(aka, current symbol size).\n     * Including the change caused by animation\n     */\n    symbolProto.getScale = function () {\n        return this.childAt(0).scale;\n    };\n\n    /**\n     * Highlight symbol\n     */\n    symbolProto.highlight = function () {\n        this.childAt(0).trigger('emphasis');\n    };\n\n    /**\n     * Downplay symbol\n     */\n    symbolProto.downplay = function () {\n        this.childAt(0).trigger('normal');\n    };\n\n    /**\n     * @param {number} zlevel\n     * @param {number} z\n     */\n    symbolProto.setZ = function (zlevel, z) {\n        var symbolPath = this.childAt(0);\n        symbolPath.zlevel = zlevel;\n        symbolPath.z = z;\n    };\n\n    symbolProto.setDraggable = function (draggable) {\n        var symbolPath = this.childAt(0);\n        symbolPath.draggable = draggable;\n        symbolPath.cursor = draggable ? 'move' : 'pointer';\n    };\n\n    /**\n     * Update symbol properties\n     * @param  {module:echarts/data/List} data\n     * @param  {number} idx\n     */\n    symbolProto.updateData = function (data, idx, seriesScope) {\n        this.silent = false;\n\n        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';\n        var seriesModel = data.hostModel;\n        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n        if (symbolType !== this._symbolType) {\n            this._createSymbol(symbolType, data, idx);\n        }\n        else {\n            var symbolPath = this.childAt(0);\n            graphic.updateProps(symbolPath, {\n                scale: symbolSize\n            }, seriesModel, idx);\n        }\n        this._updateCommon(data, idx, symbolSize, seriesScope);\n        this._seriesModel = seriesModel;\n    };\n\n    // Update common properties\n    var normalStyleAccessPath = ['itemStyle', 'normal'];\n    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];\n    var normalLabelAccessPath = ['label', 'normal'];\n    var emphasisLabelAccessPath = ['label', 'emphasis'];\n\n    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {\n        var symbolPath = this.childAt(0);\n        var seriesModel = data.hostModel;\n        var color = data.getItemVisual(idx, 'color');\n\n        // Reset style\n        if (symbolPath.type !== 'image') {\n            symbolPath.useStyle({\n                strokeNoScale: true\n            });\n        }\n\n        seriesScope = seriesScope || null;\n\n        var itemStyle = seriesScope && seriesScope.itemStyle;\n        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;\n        var symbolRotate = seriesScope && seriesScope.symbolRotate;\n        var symbolOffset = seriesScope && seriesScope.symbolOffset;\n        var labelModel = seriesScope && seriesScope.labelModel;\n        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;\n        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;\n\n        if (!seriesScope || data.hasItemOption) {\n            var itemModel = data.getItemModel(idx);\n\n            // Color must be excluded.\n            // Because symbol provide setColor individually to set fill and stroke\n            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);\n            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();\n\n            symbolRotate = itemModel.getShallow('symbolRotate');\n            symbolOffset = itemModel.getShallow('symbolOffset');\n\n            labelModel = itemModel.getModel(normalLabelAccessPath);\n            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);\n            hoverAnimation = itemModel.getShallow('hoverAnimation');\n        }\n        else {\n            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);\n        }\n\n        var elStyle = symbolPath.style;\n\n        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);\n\n        if (symbolOffset) {\n            symbolPath.attr('position', [\n                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),\n                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])\n            ]);\n        }\n\n        // PENDING setColor before setStyle!!!\n        symbolPath.setColor(color);\n\n        symbolPath.setStyle(itemStyle);\n\n        var opacity = data.getItemVisual(idx, 'opacity');\n        if (opacity != null) {\n            elStyle.opacity = opacity;\n        }\n\n        // Get last value dim\n        var dimensions = data.dimensions.slice();\n        var valueDim;\n        var dataType;\n        while (dimensions.length && (\n            valueDim = dimensions.pop(),\n            dataType = data.getDimensionInfo(valueDim).type,\n            dataType === 'ordinal' || dataType === 'time'\n        )) {} // jshint ignore:line\n\n        if (valueDim != null && labelModel.getShallow('show')) {\n            graphic.setText(elStyle, labelModel, color);\n            elStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'normal'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            elStyle.text = '';\n        }\n\n        if (valueDim != null && hoverLabelModel.getShallow('show')) {\n            graphic.setText(hoverItemStyle, hoverLabelModel, color);\n            hoverItemStyle.text = zrUtil.retrieve(\n                seriesModel.getFormattedLabel(idx, 'emphasis'),\n                data.get(valueDim, idx)\n            );\n        }\n        else {\n            hoverItemStyle.text = '';\n        }\n\n        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));\n\n        symbolPath.off('mouseover')\n            .off('mouseout')\n            .off('emphasis')\n            .off('normal');\n\n        symbolPath.hoverStyle = hoverItemStyle;\n\n        graphic.setHoverStyle(symbolPath);\n\n        if (hoverAnimation && seriesModel.ifEnableAnimation()) {\n            var onEmphasis = function() {\n                var ratio = size[1] / size[0];\n                this.animateTo({\n                    scale: [\n                        Math.max(size[0] * 1.1, size[0] + 3),\n                        Math.max(size[1] * 1.1, size[1] + 3 * ratio)\n                    ]\n                }, 400, 'elasticOut');\n            };\n            var onNormal = function() {\n                this.animateTo({\n                    scale: size\n                }, 400, 'elasticOut');\n            };\n            symbolPath.on('mouseover', onEmphasis)\n                .on('mouseout', onNormal)\n                .on('emphasis', onEmphasis)\n                .on('normal', onNormal);\n        }\n    };\n\n    symbolProto.fadeOut = function (cb) {\n        var symbolPath = this.childAt(0);\n        // Avoid mistaken hover when fading out\n        this.silent = true;\n        // Not show text when animating\n        symbolPath.style.text = '';\n        graphic.updateProps(symbolPath, {\n            scale: [0, 0]\n        }, this._seriesModel, this.dataIndex, cb);\n    };\n\n    zrUtil.inherits(Symbol, graphic.Group);\n\n    module.exports = Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/helper/Symbol.js\n// module id = 532\n// module chunks = 16","'use strict';\n// Symbol factory\n\n\n    var graphic = require('./graphic');\n    var BoundingRect = require('zrender/lib/core/BoundingRect');\n\n    /**\n     * Triangle shape\n     * @inner\n     */\n    var Triangle = graphic.extendShape({\n        type: 'triangle',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy + height);\n            path.lineTo(cx - width, cy + height);\n            path.closePath();\n        }\n    });\n    /**\n     * Diamond shape\n     * @inner\n     */\n    var Diamond = graphic.extendShape({\n        type: 'diamond',\n        shape: {\n            cx: 0,\n            cy: 0,\n            width: 0,\n            height: 0\n        },\n        buildPath: function (path, shape) {\n            var cx = shape.cx;\n            var cy = shape.cy;\n            var width = shape.width / 2;\n            var height = shape.height / 2;\n            path.moveTo(cx, cy - height);\n            path.lineTo(cx + width, cy);\n            path.lineTo(cx, cy + height);\n            path.lineTo(cx - width, cy);\n            path.closePath();\n        }\n    });\n\n    /**\n     * Pin shape\n     * @inner\n     */\n    var Pin = graphic.extendShape({\n        type: 'pin',\n        shape: {\n            // x, y on the cusp\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (path, shape) {\n            var x = shape.x;\n            var y = shape.y;\n            var w = shape.width / 5 * 3;\n            // Height must be larger than width\n            var h = Math.max(w, shape.height);\n            var r = w / 2;\n\n            // Dist on y with tangent point and circle center\n            var dy = r * r / (h - r);\n            var cy = y - h + r + dy;\n            var angle = Math.asin(dy / r);\n            // Dist on x with tangent point and circle center\n            var dx = Math.cos(angle) * r;\n\n            var tanX = Math.sin(angle);\n            var tanY = Math.cos(angle);\n\n            path.arc(\n                x, cy, r,\n                Math.PI - angle,\n                Math.PI * 2 + angle\n            );\n\n            var cpLen = r * 0.6;\n            var cpLen2 = r * 0.7;\n            path.bezierCurveTo(\n                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,\n                x, y - cpLen2,\n                x, y\n            );\n            path.bezierCurveTo(\n                x, y - cpLen2,\n                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,\n                x - dx, cy + dy\n            );\n            path.closePath();\n        }\n    });\n\n    /**\n     * Arrow shape\n     * @inner\n     */\n    var Arrow = graphic.extendShape({\n\n        type: 'arrow',\n\n        shape: {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        buildPath: function (ctx, shape) {\n            var height = shape.height;\n            var width = shape.width;\n            var x = shape.x;\n            var y = shape.y;\n            var dx = width / 3 * 2;\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + dx, y + height);\n            ctx.lineTo(x, y + height / 4 * 3);\n            ctx.lineTo(x - dx, y + height);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n    });\n\n    /**\n     * Map of path contructors\n     * @type {Object.<string, module:zrender/graphic/Path>}\n     */\n    var symbolCtors = {\n        line: graphic.Line,\n\n        rect: graphic.Rect,\n\n        roundRect: graphic.Rect,\n\n        square: graphic.Rect,\n\n        circle: graphic.Circle,\n\n        diamond: Diamond,\n\n        pin: Pin,\n\n        arrow: Arrow,\n\n        triangle: Triangle\n    };\n\n    var symbolShapeMakers = {\n\n        line: function (x, y, w, h, shape) {\n            // FIXME\n            shape.x1 = x;\n            shape.y1 = y + h / 2;\n            shape.x2 = x + w;\n            shape.y2 = y + h / 2;\n        },\n\n        rect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        roundRect: function (x, y, w, h, shape) {\n            shape.x = x;\n            shape.y = y;\n            shape.width = w;\n            shape.height = h;\n            shape.r = Math.min(w, h) / 4;\n        },\n\n        square: function (x, y, w, h, shape) {\n            var size = Math.min(w, h);\n            shape.x = x;\n            shape.y = y;\n            shape.width = size;\n            shape.height = size;\n        },\n\n        circle: function (x, y, w, h, shape) {\n            // Put circle in the center of square\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.r = Math.min(w, h) / 2;\n        },\n\n        diamond: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        pin: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        arrow: function (x, y, w, h, shape) {\n            shape.x = x + w / 2;\n            shape.y = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        },\n\n        triangle: function (x, y, w, h, shape) {\n            shape.cx = x + w / 2;\n            shape.cy = y + h / 2;\n            shape.width = w;\n            shape.height = h;\n        }\n    };\n\n    var symbolBuildProxies = {};\n    for (var name in symbolCtors) {\n        if (symbolCtors.hasOwnProperty(name)) {\n            symbolBuildProxies[name] = new symbolCtors[name]();\n        }\n    }\n\n    var Symbol = graphic.extendShape({\n\n        type: 'symbol',\n\n        shape: {\n            symbolType: '',\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0\n        },\n\n        beforeBrush: function () {\n            var style = this.style;\n            var shape = this.shape;\n            // FIXME\n            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {\n                style.textPosition = ['50%', '40%'];\n                style.textAlign = 'center';\n                style.textVerticalAlign = 'middle';\n            }\n        },\n\n        buildPath: function (ctx, shape, inBundle) {\n            var symbolType = shape.symbolType;\n            var proxySymbol = symbolBuildProxies[symbolType];\n            if (shape.symbolType !== 'none') {\n                if (!proxySymbol) {\n                    // Default rect\n                    symbolType = 'rect';\n                    proxySymbol = symbolBuildProxies[symbolType];\n                }\n                symbolShapeMakers[symbolType](\n                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape\n                );\n                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);\n            }\n        }\n    });\n\n    // Provide setColor helper method to avoid determine if set the fill or stroke outside\n    var symbolPathSetColor = function (color) {\n        if (this.type !== 'image') {\n            var symbolStyle = this.style;\n            var symbolShape = this.shape;\n            if (symbolShape && symbolShape.symbolType === 'line') {\n                symbolStyle.stroke = color;\n            }\n            else if (this.__isEmptyBrush) {\n                symbolStyle.stroke = color;\n                symbolStyle.fill = '#fff';\n            }\n            else {\n                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?\n                symbolStyle.fill && (symbolStyle.fill = color);\n                symbolStyle.stroke && (symbolStyle.stroke = color);\n            }\n            this.dirty(false);\n        }\n    };\n\n    var symbolUtil = {\n        /**\n         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color\n         * @param {string} symbolType\n         * @param {number} x\n         * @param {number} y\n         * @param {number} w\n         * @param {number} h\n         * @param {string} color\n         */\n        createSymbol: function (symbolType, x, y, w, h, color) {\n            var isEmpty = symbolType.indexOf('empty') === 0;\n            if (isEmpty) {\n                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);\n            }\n            var symbolPath;\n\n            if (symbolType.indexOf('image://') === 0) {\n                symbolPath = new graphic.Image({\n                    style: {\n                        image: symbolType.slice(8),\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n            else if (symbolType.indexOf('path://') === 0) {\n                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));\n            }\n            else {\n                symbolPath = new Symbol({\n                    shape: {\n                        symbolType: symbolType,\n                        x: x,\n                        y: y,\n                        width: w,\n                        height: h\n                    }\n                });\n            }\n\n            symbolPath.__isEmptyBrush = isEmpty;\n\n            symbolPath.setColor = symbolPathSetColor;\n\n            symbolPath.setColor(color);\n\n            return symbolPath;\n        }\n    };\n\n    module.exports = symbolUtil;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/util/symbol.js\n// module id = 533\n// module chunks = 16","\n\n    // var arrayDiff = require('zrender/lib/core/arrayDiff');\n    // 'zrender/core/arrayDiff' has been used before, but it did\n    // not do well in performance when roam with fixed dataZoom window.\n\n    function sign(val) {\n        return val >= 0 ? 1 : -1;\n    }\n\n    function getStackedOnPoint(coordSys, data, idx) {\n        var baseAxis = coordSys.getBaseAxis();\n        var valueAxis = coordSys.getOtherAxis(baseAxis);\n        var valueStart = baseAxis.onZero\n            ? 0 : valueAxis.scale.getExtent()[0];\n\n        var valueDim = valueAxis.dim;\n        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;\n\n        var stackedOnSameSign;\n        var stackedOn = data.stackedOn;\n        var val = data.get(valueDim, idx);\n        // Find first stacked value with same sign\n        while (stackedOn &&\n            sign(stackedOn.get(valueDim, idx)) === sign(val)\n        ) {\n            stackedOnSameSign = stackedOn;\n            break;\n        }\n        var stackedData = [];\n        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);\n        stackedData[1 - baseDataOffset] = stackedOnSameSign\n            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;\n\n        return coordSys.dataToPoint(stackedData);\n    }\n\n    // function convertToIntId(newIdList, oldIdList) {\n    //     // Generate int id instead of string id.\n    //     // Compare string maybe slow in score function of arrDiff\n\n    //     // Assume id in idList are all unique\n    //     var idIndicesMap = {};\n    //     var idx = 0;\n    //     for (var i = 0; i < newIdList.length; i++) {\n    //         idIndicesMap[newIdList[i]] = idx;\n    //         newIdList[i] = idx++;\n    //     }\n    //     for (var i = 0; i < oldIdList.length; i++) {\n    //         var oldId = oldIdList[i];\n    //         // Same with newIdList\n    //         if (idIndicesMap[oldId]) {\n    //             oldIdList[i] = idIndicesMap[oldId];\n    //         }\n    //         else {\n    //             oldIdList[i] = idx++;\n    //         }\n    //     }\n    // }\n\n    function diffData(oldData, newData) {\n        var diffResult = [];\n\n        newData.diff(oldData)\n            .add(function (idx) {\n                diffResult.push({cmd: '+', idx: idx});\n            })\n            .update(function (newIdx, oldIdx) {\n                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});\n            })\n            .remove(function (idx) {\n                diffResult.push({cmd: '-', idx: idx});\n            })\n            .execute();\n\n        return diffResult;\n    }\n\n    module.exports = function (\n        oldData, newData,\n        oldStackedOnPoints, newStackedOnPoints,\n        oldCoordSys, newCoordSys\n    ) {\n        var diff = diffData(oldData, newData);\n\n        // var newIdList = newData.mapArray(newData.getId);\n        // var oldIdList = oldData.mapArray(oldData.getId);\n\n        // convertToIntId(newIdList, oldIdList);\n\n        // // FIXME One data ?\n        // diff = arrayDiff(oldIdList, newIdList);\n\n        var currPoints = [];\n        var nextPoints = [];\n        // Points for stacking base line\n        var currStackedPoints = [];\n        var nextStackedPoints = [];\n\n        var status = [];\n        var sortedIndices = [];\n        var rawIndices = [];\n        var dims = newCoordSys.dimensions;\n        for (var i = 0; i < diff.length; i++) {\n            var diffItem = diff[i];\n            var pointAdded = true;\n\n            // FIXME, animation is not so perfect when dataZoom window moves fast\n            // Which is in case remvoing or add more than one data in the tail or head\n            switch (diffItem.cmd) {\n                case '=':\n                    var currentPt = oldData.getItemLayout(diffItem.idx);\n                    var nextPt = newData.getItemLayout(diffItem.idx1);\n                    // If previous data is NaN, use next point directly\n                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n                        currentPt = nextPt.slice();\n                    }\n                    currPoints.push(currentPt);\n                    nextPoints.push(nextPt);\n\n                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n\n                    rawIndices.push(newData.getRawIndex(diffItem.idx1));\n                    break;\n                case '+':\n                    var idx = diffItem.idx;\n                    currPoints.push(\n                        oldCoordSys.dataToPoint([\n                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)\n                        ])\n                    );\n\n                    nextPoints.push(newData.getItemLayout(idx).slice());\n\n                    currStackedPoints.push(\n                        getStackedOnPoint(oldCoordSys, newData, idx)\n                    );\n                    nextStackedPoints.push(newStackedOnPoints[idx]);\n\n                    rawIndices.push(newData.getRawIndex(idx));\n                    break;\n                case '-':\n                    var idx = diffItem.idx;\n                    var rawIndex = oldData.getRawIndex(idx);\n                    // Data is replaced. In the case of dynamic data queue\n                    // FIXME FIXME FIXME\n                    if (rawIndex !== idx) {\n                        currPoints.push(oldData.getItemLayout(idx));\n                        nextPoints.push(newCoordSys.dataToPoint([\n                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)\n                        ]));\n\n                        currStackedPoints.push(oldStackedOnPoints[idx]);\n                        nextStackedPoints.push(\n                            getStackedOnPoint(\n                                newCoordSys, oldData, idx\n                            )\n                        );\n\n                        rawIndices.push(rawIndex);\n                    }\n                    else {\n                        pointAdded = false;\n                    }\n            }\n\n            // Original indices\n            if (pointAdded) {\n                status.push(diffItem);\n                sortedIndices.push(sortedIndices.length);\n            }\n        }\n\n        // Diff result may be crossed if all items are changed\n        // Sort by data index\n        sortedIndices.sort(function (a, b) {\n            return rawIndices[a] - rawIndices[b];\n        });\n\n        var sortedCurrPoints = [];\n        var sortedNextPoints = [];\n\n        var sortedCurrStackedPoints = [];\n        var sortedNextStackedPoints = [];\n\n        var sortedStatus = [];\n        for (var i = 0; i < sortedIndices.length; i++) {\n            var idx = sortedIndices[i];\n            sortedCurrPoints[i] = currPoints[idx];\n            sortedNextPoints[i] = nextPoints[idx];\n\n            sortedCurrStackedPoints[i] = currStackedPoints[idx];\n            sortedNextStackedPoints[i] = nextStackedPoints[idx];\n\n            sortedStatus[i] = status[idx];\n        }\n\n        return {\n            current: sortedCurrPoints,\n            next: sortedNextPoints,\n\n            stackedOnCurrent: sortedCurrStackedPoints,\n            stackedOnNext: sortedNextStackedPoints,\n\n            status: sortedStatus\n        };\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/lineAnimationDiff.js\n// module id = 534\n// module chunks = 16","// Poly path support NaN point\n\n\n    var Path = require('zrender/lib/graphic/Path');\n    var vec2 = require('zrender/lib/core/vector');\n\n    var vec2Min = vec2.min;\n    var vec2Max = vec2.max;\n\n    var scaleAndAdd = vec2.scaleAndAdd;\n    var v2Copy = vec2.copy;\n\n    // Temporary variable\n    var v = [];\n    var cp0 = [];\n    var cp1 = [];\n\n    function isPointNull(p) {\n        return isNaN(p[0]) || isNaN(p[1]);\n    }\n\n    function drawSegment(\n        ctx, points, start, segLen, allLen,\n        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls\n    ) {\n        var prevIdx = 0;\n        var idx = start;\n        for (var k = 0; k < segLen; k++) {\n            var p = points[idx];\n            if (idx >= allLen || idx < 0) {\n                break;\n            }\n            if (isPointNull(p)) {\n                if (connectNulls) {\n                    idx += dir;\n                    continue;\n                }\n                break;\n            }\n\n            if (idx === start) {\n                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n                v2Copy(cp0, p);\n            }\n            else {\n                if (smooth > 0) {\n                    var nextIdx = idx + dir;\n                    var nextP = points[nextIdx];\n                    if (connectNulls) {\n                        // Find next point not null\n                        while (nextP && isPointNull(points[nextIdx])) {\n                            nextIdx += dir;\n                            nextP = points[nextIdx];\n                        }\n                    }\n\n                    var ratioNextSeg = 0.5;\n                    var prevP = points[prevIdx];\n                    var nextP = points[nextIdx];\n                    // Last point\n                    if (!nextP || isPointNull(nextP)) {\n                        v2Copy(cp1, p);\n                    }\n                    else {\n                        // If next data is null in not connect case\n                        if (isPointNull(nextP) && !connectNulls) {\n                            nextP = p;\n                        }\n\n                        vec2.sub(v, nextP, prevP);\n\n                        var lenPrevSeg;\n                        var lenNextSeg;\n                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n                            var dim = smoothMonotone === 'x' ? 0 : 1;\n                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n                        }\n                        else {\n                            lenPrevSeg = vec2.dist(p, prevP);\n                            lenNextSeg = vec2.dist(p, nextP);\n                        }\n\n                        // Use ratio of seg length\n                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n\n                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n                    }\n                    // Smooth constraint\n                    vec2Min(cp0, cp0, smoothMax);\n                    vec2Max(cp0, cp0, smoothMin);\n                    vec2Min(cp1, cp1, smoothMax);\n                    vec2Max(cp1, cp1, smoothMin);\n\n                    ctx.bezierCurveTo(\n                        cp0[0], cp0[1],\n                        cp1[0], cp1[1],\n                        p[0], p[1]\n                    );\n                    // cp0 of next segment\n                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n                }\n                else {\n                    ctx.lineTo(p[0], p[1]);\n                }\n            }\n\n            prevIdx = idx;\n            idx += dir;\n        }\n\n        return k;\n    }\n\n    function getBoundingBox(points, smoothConstraint) {\n        var ptMin = [Infinity, Infinity];\n        var ptMax = [-Infinity, -Infinity];\n        if (smoothConstraint) {\n            for (var i = 0; i < points.length; i++) {\n                var pt = points[i];\n                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }\n                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }\n                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }\n                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }\n            }\n        }\n        return {\n            min: smoothConstraint ? ptMin : ptMax,\n            max: smoothConstraint ? ptMax : ptMin\n        };\n    }\n\n    module.exports = {\n\n        Polyline: Path.extend({\n\n            type: 'ec-polyline',\n\n            shape: {\n                points: [],\n\n                smooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            style: {\n                fill: null,\n\n                stroke: '#000'\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n\n                var i = 0;\n                var len = points.length;\n\n                var result = getBoundingBox(points, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    i += drawSegment(\n                        ctx, points, i, len, len,\n                        1, result.min, result.max, shape.smooth,\n                        shape.smoothMonotone, shape.connectNulls\n                    ) + 1;\n                }\n            }\n        }),\n\n        Polygon: Path.extend({\n\n            type: 'ec-polygon',\n\n            shape: {\n                points: [],\n\n                // Offset between stacked base points and points\n                stackedOnPoints: [],\n\n                smooth: 0,\n\n                stackedOnSmooth: 0,\n\n                smoothConstraint: true,\n\n                smoothMonotone: null,\n\n                connectNulls: false\n            },\n\n            buildPath: function (ctx, shape) {\n                var points = shape.points;\n                var stackedOnPoints = shape.stackedOnPoints;\n\n                var i = 0;\n                var len = points.length;\n                var smoothMonotone = shape.smoothMonotone;\n                var bbox = getBoundingBox(points, shape.smoothConstraint);\n                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n                if (shape.connectNulls) {\n                    // Must remove first and last null values avoid draw error in polygon\n                    for (; len > 0; len--) {\n                        if (!isPointNull(points[len - 1])) {\n                            break;\n                        }\n                    }\n                    for (; i < len; i++) {\n                        if (!isPointNull(points[i])) {\n                            break;\n                        }\n                    }\n                }\n                while (i < len) {\n                    var k = drawSegment(\n                        ctx, points, i, len, len,\n                        1, bbox.min, bbox.max, shape.smooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    drawSegment(\n                        ctx, stackedOnPoints, i + k - 1, k, len,\n                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,\n                        smoothMonotone, shape.connectNulls\n                    );\n                    i += k + 1;\n\n                    ctx.closePath();\n                }\n            }\n        })\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/line/poly.js\n// module id = 535\n// module chunks = 16","\n\n    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {\n\n        // Encoding visual for all series include which is filtered for legend drawing\n        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n\n            var symbolType = seriesModel.get('symbol') || defaultSymbolType;\n            var symbolSize = seriesModel.get('symbolSize');\n\n            data.setVisual({\n                legendSymbol: legendSymbol || symbolType,\n                symbol: symbolType,\n                symbolSize: symbolSize\n            });\n\n            // Only visible series has each data be visual encoded\n            if (!ecModel.isSeriesFiltered(seriesModel)) {\n                if (typeof symbolSize === 'function') {\n                    data.each(function (idx) {\n                        var rawValue = seriesModel.getRawValue(idx);\n                        // FIXME\n                        var params = seriesModel.getDataParams(idx);\n                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));\n                    });\n                }\n                data.each(function (idx) {\n                    var itemModel = data.getItemModel(idx);\n                    var itemSymbolType = itemModel.getShallow('symbol', true);\n                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);\n                    // If has item symbol\n                    if (itemSymbolType != null) {\n                        data.setItemVisual(idx, 'symbol', itemSymbolType);\n                    }\n                    if (itemSymbolSize != null) {\n                        // PENDING Transform symbolSize ?\n                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);\n                    }\n                });\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/visual/symbol.js\n// module id = 536\n// module chunks = 16","\n\n    module.exports = function (seriesType, ecModel) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var coordSys = seriesModel.coordinateSystem;\n\n            if (coordSys) {\n                var dims = coordSys.dimensions;\n\n                if (coordSys.type === 'singleAxis') {\n                    data.each(dims[0], function (x, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));\n                    });\n                }\n                else {\n                    data.each(dims, function (x, y, idx) {\n                        // Also {Array.<number>}, not undefined to avoid if...else... statement\n                        data.setItemLayout(\n                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])\n                        );\n                    }, true);\n                }\n            }\n        });\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/points.js\n// module id = 537\n// module chunks = 16","\n    var samplers = {\n        average: function (frame) {\n            var sum = 0;\n            var count = 0;\n            for (var i = 0; i < frame.length; i++) {\n                if (!isNaN(frame[i])) {\n                    sum += frame[i];\n                    count++;\n                }\n            }\n            // Return NaN if count is 0\n            return count === 0 ? NaN : sum / count;\n        },\n        sum: function (frame) {\n            var sum = 0;\n            for (var i = 0; i < frame.length; i++) {\n                // Ignore NaN\n                sum += frame[i] || 0;\n            }\n            return sum;\n        },\n        max: function (frame) {\n            var max = -Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] > max && (max = frame[i]);\n            }\n            return max;\n        },\n        min: function (frame) {\n            var min = Infinity;\n            for (var i = 0; i < frame.length; i++) {\n                frame[i] < min && (min = frame[i]);\n            }\n            return min;\n        },\n        // TODO\n        // Median\n        nearest: function (frame) {\n            return frame[0];\n        }\n    };\n\n    var indexSampler = function (frame, value) {\n        return Math.round(frame.length / 2);\n    };\n    module.exports = function (seriesType, ecModel, api) {\n        ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n            var data = seriesModel.getData();\n            var sampling = seriesModel.get('sampling');\n            var coordSys = seriesModel.coordinateSystem;\n            // Only cartesian2d support down sampling\n            if (coordSys.type === 'cartesian2d' && sampling) {\n                var baseAxis = coordSys.getBaseAxis();\n                var valueAxis = coordSys.getOtherAxis(baseAxis);\n                var extent = baseAxis.getExtent();\n                // Coordinste system has been resized\n                var size = extent[1] - extent[0];\n                var rate = Math.round(data.count() / size);\n                if (rate > 1) {\n                    var sampler;\n                    if (typeof sampling === 'string') {\n                        sampler = samplers[sampling];\n                    }\n                    else if (typeof sampling === 'function') {\n                        sampler = sampling;\n                    }\n                    if (sampler) {\n                        data = data.downSample(\n                            valueAxis.dim, 1 / rate, sampler, indexSampler\n                        );\n                        seriesModel.setData(data);\n                    }\n                }\n            }\n        }, this);\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/processor/dataSample.js\n// module id = 538\n// module chunks = 16","'use strict';\n\n\n    var graphic = require('../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var echarts = require('../echarts');\n\n    require('../coord/cartesian/Grid');\n\n    require('./axis');\n\n    // Grid view\n    echarts.extendComponentView({\n\n        type: 'grid',\n\n        render: function (gridModel, ecModel) {\n            this.group.removeAll();\n            if (gridModel.get('show')) {\n                this.group.add(new graphic.Rect({\n                    shape: gridModel.coordinateSystem.getRect(),\n                    style: zrUtil.defaults({\n                        fill: gridModel.get('backgroundColor')\n                    }, gridModel.getItemStyle()),\n                    silent: true,\n                    z2: -1\n                }));\n            }\n        }\n\n    });\n\n    echarts.registerPreprocessor(function (option) {\n        // Only create grid when need\n        if (option.xAxis && option.yAxis && !option.grid) {\n            option.grid = {};\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/grid.js\n// module id = 539\n// module chunks = 16","/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\nvar factory = exports;\n\n    var layout = require('../../util/layout');\n    var axisHelper = require('../../coord/axisHelper');\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian2D = require('./Cartesian2D');\n    var Axis2D = require('./Axis2D');\n\n    var each = zrUtil.each;\n\n    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;\n    var niceScaleExtent = axisHelper.niceScaleExtent;\n\n    // 依赖 GridModel, AxisModel 做预处理\n    require('./GridModel');\n\n    /**\n     * Check if the axis is used in the specified grid\n     * @inner\n     */\n    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n        return axisModel.findGridModel() === gridModel;\n    }\n\n    function getLabelUnionRect(axis) {\n        var axisModel = axis.model;\n        var labels = axisModel.getFormattedLabels();\n        var rect;\n        var step = 1;\n        var labelCount = labels.length;\n        if (labelCount > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.ceil(labelCount / 40);\n        }\n        for (var i = 0; i < labelCount; i += step) {\n            if (!axis.isLabelIgnored(i)) {\n                var singleRect = axisModel.getTextRect(labels[i]);\n                // FIXME consider label rotate\n                rect ? rect.union(singleRect) : (rect = singleRect);\n            }\n        }\n        return rect;\n    }\n\n    function Grid(gridModel, ecModel, api) {\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n         * @private\n         */\n        this._coordsMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n         * @private\n         */\n        this._coordsList = [];\n\n        /**\n         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesMap = {};\n\n        /**\n         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n         * @private\n         */\n        this._axesList = [];\n\n        this._initCartesian(gridModel, ecModel, api);\n\n        this._model = gridModel;\n    }\n\n    var gridProto = Grid.prototype;\n\n    gridProto.type = 'grid';\n\n    gridProto.getRect = function () {\n        return this._rect;\n    };\n\n    gridProto.update = function (ecModel, api) {\n\n        var axesMap = this._axesMap;\n\n        this._updateScale(ecModel, this._model);\n\n        function ifAxisCanNotOnZero(otherAxisDim) {\n            var axes = axesMap[otherAxisDim];\n            for (var idx in axes) {\n                if (axes.hasOwnProperty(idx)) {\n                    var axis = axes[idx];\n                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        each(axesMap.x, function (xAxis) {\n            niceScaleExtent(xAxis, xAxis.model);\n        });\n        each(axesMap.y, function (yAxis) {\n            niceScaleExtent(yAxis, yAxis.model);\n        });\n        // Fix configuration\n        each(axesMap.x, function (xAxis) {\n            // onZero can not be enabled in these two situations\n            // 1. When any other axis is a category axis\n            // 2. When any other axis not across 0 point\n            if (ifAxisCanNotOnZero('y')) {\n                xAxis.onZero = false;\n            }\n        });\n        each(axesMap.y, function (yAxis) {\n            if (ifAxisCanNotOnZero('x')) {\n                yAxis.onZero = false;\n            }\n        });\n\n        // Resize again if containLabel is enabled\n        // FIXME It may cause getting wrong grid size in data processing stage\n        this.resize(this._model, api);\n    };\n\n    /**\n     * Resize the grid\n     * @param {module:echarts/coord/cartesian/GridModel} gridModel\n     * @param {module:echarts/ExtensionAPI} api\n     */\n    gridProto.resize = function (gridModel, api) {\n\n        var gridRect = layout.getLayoutRect(\n            gridModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            });\n\n        this._rect = gridRect;\n\n        var axesList = this._axesList;\n\n        adjustAxes();\n\n        // Minus label size\n        if (gridModel.get('containLabel')) {\n            each(axesList, function (axis) {\n                if (!axis.model.get('axisLabel.inside')) {\n                    var labelUnionRect = getLabelUnionRect(axis);\n                    if (labelUnionRect) {\n                        var dim = axis.isHorizontal() ? 'height' : 'width';\n                        var margin = axis.model.get('axisLabel.margin');\n                        gridRect[dim] -= labelUnionRect[dim] + margin;\n                        if (axis.position === 'top') {\n                            gridRect.y += labelUnionRect.height + margin;\n                        }\n                        else if (axis.position === 'left')  {\n                            gridRect.x += labelUnionRect.width + margin;\n                        }\n                    }\n                }\n            });\n\n            adjustAxes();\n        }\n\n        function adjustAxes() {\n            each(axesList, function (axis) {\n                var isHorizontal = axis.isHorizontal();\n                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n                var idx = axis.inverse ? 1 : 0;\n                axis.setExtent(extent[idx], extent[1 - idx]);\n                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n            });\n        }\n    };\n\n    /**\n     * @param {string} axisType\n     * @param {ndumber} [axisIndex]\n     */\n    gridProto.getAxis = function (axisType, axisIndex) {\n        var axesMapOnDim = this._axesMap[axisType];\n        if (axesMapOnDim != null) {\n            if (axisIndex == null) {\n                // Find first axis\n                for (var name in axesMapOnDim) {\n                    if (axesMapOnDim.hasOwnProperty(name)) {\n                        return axesMapOnDim[name];\n                    }\n                }\n            }\n            return axesMapOnDim[axisIndex];\n        }\n    };\n\n    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n        if (xAxisIndex != null && yAxisIndex != null) {\n            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n            return this._coordsMap[key];\n        }\n        else {\n            // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n                if (coordList[i].getAxis('x').index === xAxisIndex\n                    || coordList[i].getAxis('y').index === yAxisIndex\n                ) {\n                    return coordList[i];\n                }\n            }\n        }\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertToPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.dataToPoint(value)\n            : target.axis\n            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))\n            : null;\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.convertFromPixel = function (ecModel, finder, value) {\n        var target = this._findConvertTarget(ecModel, finder);\n\n        return target.cartesian\n            ? target.cartesian.pointToData(value)\n            : target.axis\n            ? target.axis.coordToData(target.axis.toLocalCoord(value))\n            : null;\n    };\n\n    /**\n     * @inner\n     */\n    gridProto._findConvertTarget = function (ecModel, finder) {\n        var seriesModel = finder.seriesModel;\n        var xAxisModel = finder.xAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);\n        var yAxisModel = finder.yAxisModel\n            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);\n        var gridModel = finder.gridModel;\n        var coordsList = this._coordsList;\n        var cartesian;\n        var axis;\n\n        if (seriesModel) {\n            cartesian = seriesModel.coordinateSystem;\n            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n        }\n        else if (xAxisModel && yAxisModel) {\n            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n        }\n        else if (xAxisModel) {\n            axis = this.getAxis('x', xAxisModel.componentIndex);\n        }\n        else if (yAxisModel) {\n            axis = this.getAxis('y', yAxisModel.componentIndex);\n        }\n        // Lowest priority.\n        else if (gridModel) {\n            var grid = gridModel.coordinateSystem;\n            if (grid === this) {\n                cartesian = this._coordsList[0];\n            }\n        }\n\n        return {cartesian: cartesian, axis: axis};\n    };\n\n    /**\n     * @implements\n     * see {module:echarts/CoodinateSystem}\n     */\n    gridProto.containPoint = function (point) {\n        var coord = this._coordsList[0];\n        if (coord) {\n            return coord.containPoint(point);\n        }\n    };\n\n    /**\n     * Initialize cartesian coordinate systems\n     * @private\n     */\n    gridProto._initCartesian = function (gridModel, ecModel, api) {\n        var axisPositionUsed = {\n            left: false,\n            right: false,\n            top: false,\n            bottom: false\n        };\n\n        var axesMap = {\n            x: {},\n            y: {}\n        };\n        var axesCount = {\n            x: 0,\n            y: 0\n        };\n\n        /// Create axis\n        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n        if (!axesCount.x || !axesCount.y) {\n            // Roll back when there no either x or y axis\n            this._axesMap = {};\n            this._axesList = [];\n            return;\n        }\n\n        this._axesMap = axesMap;\n\n        /// Create cartesian2d\n        each(axesMap.x, function (xAxis, xAxisIndex) {\n            each(axesMap.y, function (yAxis, yAxisIndex) {\n                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n                var cartesian = new Cartesian2D(key);\n\n                cartesian.grid = this;\n\n                this._coordsMap[key] = cartesian;\n                this._coordsList.push(cartesian);\n\n                cartesian.addAxis(xAxis);\n                cartesian.addAxis(yAxis);\n            }, this);\n        }, this);\n\n        function createAxisCreator(axisType) {\n            return function (axisModel, idx) {\n                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n                    return;\n                }\n\n                var axisPosition = axisModel.get('position');\n                if (axisType === 'x') {\n                    // Fix position\n                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n                        // Default bottom of X\n                        axisPosition = 'bottom';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n                        }\n                    }\n                }\n                else {\n                    // Fix position\n                    if (axisPosition !== 'left' && axisPosition !== 'right') {\n                        // Default left of Y\n                        axisPosition = 'left';\n                        if (axisPositionUsed[axisPosition]) {\n                            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n                        }\n                    }\n                }\n                axisPositionUsed[axisPosition] = true;\n\n                var axis = new Axis2D(\n                    axisType, axisHelper.createScaleByModel(axisModel),\n                    [0, 0],\n                    axisModel.get('type'),\n                    axisPosition\n                );\n\n                var isCategory = axis.type === 'category';\n                axis.onBand = isCategory && axisModel.get('boundaryGap');\n                axis.inverse = axisModel.get('inverse');\n\n                axis.onZero = axisModel.get('axisLine.onZero');\n\n                // Inject axis into axisModel\n                axisModel.axis = axis;\n\n                // Inject axisModel into axis\n                axis.model = axisModel;\n\n                // Inject grid info axis\n                axis.grid = this;\n\n                // Index of axis, can be used as key\n                axis.index = idx;\n\n                this._axesList.push(axis);\n\n                axesMap[axisType][idx] = axis;\n                axesCount[axisType]++;\n            };\n        }\n    };\n\n    /**\n     * Update cartesian properties from series\n     * @param  {module:echarts/model/Option} option\n     * @private\n     */\n    gridProto._updateScale = function (ecModel, gridModel) {\n        // Reset scale\n        zrUtil.each(this._axesList, function (axis) {\n            axis.scale.setExtent(Infinity, -Infinity);\n        });\n        ecModel.eachSeries(function (seriesModel) {\n            if (isCartesian2D(seriesModel)) {\n                var axesModels = findAxesModels(seriesModel, ecModel);\n                var xAxisModel = axesModels[0];\n                var yAxisModel = axesModels[1];\n\n                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)\n                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)\n                 ) {\n                    return;\n                }\n\n                var cartesian = this.getCartesian(\n                    xAxisModel.componentIndex, yAxisModel.componentIndex\n                );\n                var data = seriesModel.getData();\n                var xAxis = cartesian.getAxis('x');\n                var yAxis = cartesian.getAxis('y');\n\n                if (data.type === 'list') {\n                    unionExtent(data, xAxis, seriesModel);\n                    unionExtent(data, yAxis, seriesModel);\n                }\n            }\n        }, this);\n\n        function unionExtent(data, axis, seriesModel) {\n            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n                axis.scale.unionExtent(data.getDataExtent(\n                    dim, axis.scale.type !== 'ordinal'\n                ));\n            });\n        }\n    };\n\n    /**\n     * @inner\n     */\n    function updateAxisTransfrom(axis, coordBase) {\n        var axisExtent = axis.getExtent();\n        var axisExtentSum = axisExtent[0] + axisExtent[1];\n\n        // Fast transform\n        axis.toGlobalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord + coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n        axis.toLocalCoord = axis.dim === 'x'\n            ? function (coord) {\n                return coord - coordBase;\n            }\n            : function (coord) {\n                return axisExtentSum - coord + coordBase;\n            };\n    }\n\n    var axesTypes = ['xAxis', 'yAxis'];\n    /**\n     * @inner\n     */\n    function findAxesModels(seriesModel, ecModel) {\n        return zrUtil.map(axesTypes, function (axisType) {\n            var axisModel = seriesModel.getReferringComponents(axisType)[0];\n\n            if (__DEV__) {\n                if (!axisModel) {\n                    throw new Error(axisType + ' \"' + zrUtil.retrieve(\n                        seriesModel.get(axisType + 'Index'),\n                        seriesModel.get(axisType + 'Id'),\n                        0\n                    ) + '\" not found');\n                }\n            }\n            return axisModel;\n        });\n    }\n\n    /**\n     * @inner\n     */\n    function isCartesian2D(seriesModel) {\n        return seriesModel.get('coordinateSystem') === 'cartesian2d';\n    }\n\n    Grid.create = function (ecModel, api) {\n        var grids = [];\n        ecModel.eachComponent('grid', function (gridModel, idx) {\n            var grid = new Grid(gridModel, ecModel, api);\n            grid.name = 'grid_' + idx;\n            grid.resize(gridModel, api);\n\n            gridModel.coordinateSystem = grid;\n\n            grids.push(grid);\n        });\n\n        // Inject the coordinateSystems into seriesModel\n        ecModel.eachSeries(function (seriesModel) {\n            if (!isCartesian2D(seriesModel)) {\n                return;\n            }\n\n            var axesModels = findAxesModels(seriesModel, ecModel);\n            var xAxisModel = axesModels[0];\n            var yAxisModel = axesModels[1];\n\n            var gridModel = xAxisModel.findGridModel();\n\n            if (__DEV__) {\n                if (!gridModel) {\n                    throw new Error(\n                        'Grid \"' + zrUtil.retrieve(\n                            xAxisModel.get('gridIndex'),\n                            xAxisModel.get('gridId'),\n                            0\n                        ) + '\" not found'\n                    );\n                }\n                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {\n                    throw new Error('xAxis and yAxis must use the same grid');\n                }\n            }\n\n            var grid = gridModel.coordinateSystem;\n\n            seriesModel.coordinateSystem = grid.getCartesian(\n                xAxisModel.componentIndex, yAxisModel.componentIndex\n            );\n        });\n\n        return grids;\n    };\n\n    // For deciding which dimensions to use when creating list data\n    Grid.dimensions = Cartesian2D.prototype.dimensions;\n\n    require('../../CoordinateSystem').register('cartesian2d', Grid);\n\n    module.exports = Grid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Grid.js\n// module id = 540\n// module chunks = 16","\n\n    var OrdinalScale = require('../scale/Ordinal');\n    var IntervalScale = require('../scale/Interval');\n    require('../scale/Time');\n    require('../scale/Log');\n    var Scale = require('../scale/Scale');\n\n    var numberUtil = require('../util/number');\n    var zrUtil = require('zrender/lib/core/util');\n    var textContain = require('zrender/lib/contain/text');\n    var axisHelper = {};\n\n    /**\n     * Get axis scale extent before niced.\n     */\n    axisHelper.getScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var originalExtent = scale.getExtent();\n        var span = originalExtent[1] - originalExtent[0];\n        if (scale.type === 'ordinal') {\n            // If series has no data, scale extent may be wrong\n            if (!isFinite(span)) {\n                return [0, 0];\n            }\n            else {\n                return originalExtent;\n            }\n        }\n        var min = model.getMin ? model.getMin() : model.get('min');\n        var max = model.getMax ? model.getMax() : model.get('max');\n        var crossZero = model.getNeedCrossZero\n            ? model.getNeedCrossZero() : !model.get('scale');\n        var boundaryGap = model.get('boundaryGap');\n        if (!zrUtil.isArray(boundaryGap)) {\n            boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n        }\n        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n        var fixMin = true;\n        var fixMax = true;\n        // Add boundary gap\n        if (min == null) {\n            min = originalExtent[0] - boundaryGap[0] * span;\n            fixMin = false;\n        }\n        if (max == null) {\n            max = originalExtent[1] + boundaryGap[1] * span;\n            fixMax = false;\n        }\n        if (min === 'dataMin') {\n            min = originalExtent[0];\n        }\n        if (max === 'dataMax') {\n            max = originalExtent[1];\n        }\n        // Evaluate if axis needs cross zero\n        if (crossZero) {\n            // Axis is over zero and min is not set\n            if (min > 0 && max > 0 && !fixMin) {\n                min = 0;\n            }\n            // Axis is under zero and max is not set\n            if (min < 0 && max < 0 && !fixMax) {\n                max = 0;\n            }\n        }\n        return [min, max];\n    };\n\n    axisHelper.niceScaleExtent = function (axis, model) {\n        var scale = axis.scale;\n        var extent = axisHelper.getScaleExtent(axis, model);\n        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;\n        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;\n        var splitNumber = model.get('splitNumber');\n\n        if (scale.type === 'log') {\n            scale.base = model.get('logBase');\n        }\n\n        scale.setExtent(extent[0], extent[1]);\n        scale.niceExtent(splitNumber, fixMin, fixMax);\n\n        // Use minInterval to constraint the calculated interval.\n        // If calculated interval is less than minInterval. increase the interval quantity until\n        // it is larger than minInterval.\n        // For example:\n        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get\n        //  an integer axis.\n        var minInterval = model.get('minInterval');\n        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {\n            var interval = scale.getInterval();\n            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;\n            // while (interval < minInterval) {\n            //     var quantity = numberUtil.quantity(interval);\n            //     interval = quantity * 10;\n            //     scaleQuantity *= 10;\n            // }\n            extent = scale.getExtent();\n            var origin = (extent[1] + extent[0]) / 2;\n            scale.setExtent(\n                intervalScale * (extent[0] - origin) + origin,\n                intervalScale * (extent[1] - origin) + origin\n            );\n            scale.niceExtent(splitNumber);\n        }\n\n        // If some one specified the min, max. And the default calculated interval\n        // is not good enough. He can specify the interval. It is often appeared\n        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n        // to be 60.\n        // FIXME\n        var interval = model.get('interval');\n        if (interval != null) {\n            scale.setInterval && scale.setInterval(interval);\n        }\n    };\n\n    /**\n     * @param {module:echarts/model/Model} model\n     * @param {string} [axisType] Default retrieve from model.type\n     * @return {module:echarts/scale/*}\n     */\n    axisHelper.createScaleByModel = function(model, axisType) {\n        axisType = axisType || model.get('type');\n        if (axisType) {\n            switch (axisType) {\n                // Buildin scale\n                case 'category':\n                    return new OrdinalScale(\n                        model.getCategories(), [Infinity, -Infinity]\n                    );\n                case 'value':\n                    return new IntervalScale();\n                // Extended scale, like time and log\n                default:\n                    return (Scale.getClass(axisType) || IntervalScale).create(model);\n            }\n        }\n    };\n\n    /**\n     * Check if the axis corss 0\n     */\n    axisHelper.ifAxisCrossZero = function (axis) {\n        var dataExtent = axis.scale.getExtent();\n        var min = dataExtent[0];\n        var max = dataExtent[1];\n        return !((min > 0 && max > 0) || (min < 0 && max < 0));\n    };\n\n    /**\n     * @param {Array.<number>} tickCoords In axis self coordinate.\n     * @param {Array.<string>} labels\n     * @param {string} font\n     * @param {boolean} isAxisHorizontal\n     * @return {number}\n     */\n    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {\n        // FIXME\n        // 不同角的axis和label，不只是horizontal和vertical.\n\n        var textSpaceTakenRect;\n        var autoLabelInterval = 0;\n        var accumulatedLabelInterval = 0;\n\n        var step = 1;\n        if (labels.length > 40) {\n            // Simple optimization for large amount of labels\n            step = Math.floor(labels.length / 40);\n        }\n\n        for (var i = 0; i < tickCoords.length; i += step) {\n            var tickCoord = tickCoords[i];\n            var rect = textContain.getBoundingRect(\n                labels[i], font, 'center', 'top'\n            );\n            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;\n            // FIXME Magic number 1.5\n            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;\n            if (!textSpaceTakenRect) {\n                textSpaceTakenRect = rect.clone();\n            }\n            // There is no space for current label;\n            else if (textSpaceTakenRect.intersect(rect)) {\n                accumulatedLabelInterval++;\n                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);\n            }\n            else {\n                textSpaceTakenRect.union(rect);\n                // Reset\n                accumulatedLabelInterval = 0;\n            }\n        }\n        if (autoLabelInterval === 0 && step > 1) {\n            return step;\n        }\n        return (autoLabelInterval + 1) * step - 1;\n    };\n\n    /**\n     * @param {Object} axis\n     * @param {Function} labelFormatter\n     * @return {Array.<string>}\n     */\n    axisHelper.getFormattedLabels = function (axis, labelFormatter) {\n        var scale = axis.scale;\n        var labels = scale.getTicksLabels();\n        var ticks = scale.getTicks();\n        if (typeof labelFormatter === 'string') {\n            labelFormatter = (function (tpl) {\n                return function (val) {\n                    return tpl.replace('{value}', val);\n                };\n            })(labelFormatter);\n            return zrUtil.map(labels, labelFormatter);\n        }\n        else if (typeof labelFormatter === 'function') {\n            return zrUtil.map(ticks, function (tick, idx) {\n                return labelFormatter(\n                    axis.type === 'category' ? scale.getLabel(tick) : tick,\n                    idx\n                );\n            }, this);\n        }\n        else {\n            return labels;\n        }\n    };\n\n    module.exports = axisHelper;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisHelper.js\n// module id = 541\n// module chunks = 16","/**\n * Linear continuous scale\n * @module echarts/coord/scale/Ordinal\n *\n * http://en.wikipedia.org/wiki/Level_of_measurement\n */\n\n// FIXME only one data\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n\n    var scaleProto = Scale.prototype;\n\n    var OrdinalScale = Scale.extend({\n\n        type: 'ordinal',\n\n        init: function (data, extent) {\n            this._data = data;\n            this._extent = extent || [0, data.length - 1];\n        },\n\n        parse: function (val) {\n            return typeof val === 'string'\n                ? zrUtil.indexOf(this._data, val)\n                // val might be float.\n                : Math.round(val);\n        },\n\n        contain: function (rank) {\n            rank = this.parse(rank);\n            return scaleProto.contain.call(this, rank)\n                && this._data[rank] != null;\n        },\n\n        /**\n         * Normalize given rank or name to linear [0, 1]\n         * @param {number|string} [val]\n         * @return {number}\n         */\n        normalize: function (val) {\n            return scaleProto.normalize.call(this, this.parse(val));\n        },\n\n        scale: function (val) {\n            return Math.round(scaleProto.scale.call(this, val));\n        },\n\n        /**\n         * @return {Array}\n         */\n        getTicks: function () {\n            var ticks = [];\n            var extent = this._extent;\n            var rank = extent[0];\n\n            while (rank <= extent[1]) {\n                ticks.push(rank);\n                rank++;\n            }\n\n            return ticks;\n        },\n\n        /**\n         * Get item on rank n\n         * @param {number} n\n         * @return {string}\n         */\n        getLabel: function (n) {\n            return this._data[n];\n        },\n\n        /**\n         * @return {number}\n         */\n        count: function () {\n            return this._extent[1] - this._extent[0] + 1;\n        },\n\n        niceTicks: zrUtil.noop,\n        niceExtent: zrUtil.noop\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    OrdinalScale.create = function () {\n        return new OrdinalScale();\n    };\n\n    module.exports = OrdinalScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Ordinal.js\n// module id = 542\n// module chunks = 16","/**\n * // Scale class management\n * @module echarts/scale/Scale\n */\n\n\n    var clazzUtil = require('../util/clazz');\n\n    function Scale() {\n        /**\n         * Extent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._extent = [Infinity, -Infinity];\n\n        /**\n         * Step is calculated in adjustExtent\n         * @type {Array.<number>}\n         * @protected\n         */\n        this._interval = 0;\n\n        this.init && this.init.apply(this, arguments);\n    }\n\n    var scaleProto = Scale.prototype;\n\n    /**\n     * Parse input val to valid inner number.\n     * @param {*} val\n     * @return {number}\n     */\n    scaleProto.parse = function (val) {\n        // Notice: This would be a trap here, If the implementation\n        // of this method depends on extent, and this method is used\n        // before extent set (like in dataZoom), it would be wrong.\n        // Nevertheless, parse does not depend on extent generally.\n        return val;\n    };\n\n    scaleProto.contain = function (val) {\n        var extent = this._extent;\n        return val >= extent[0] && val <= extent[1];\n    };\n\n    /**\n     * Normalize value to linear [0, 1], return 0.5 if extent span is 0\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.normalize = function (val) {\n        var extent = this._extent;\n        if (extent[1] === extent[0]) {\n            return 0.5;\n        }\n        return (val - extent[0]) / (extent[1] - extent[0]);\n    };\n\n    /**\n     * Scale normalized value\n     * @param {number} val\n     * @return {number}\n     */\n    scaleProto.scale = function (val) {\n        var extent = this._extent;\n        return val * (extent[1] - extent[0]) + extent[0];\n    };\n\n    /**\n     * Set extent from data\n     * @param {Array.<number>} other\n     */\n    scaleProto.unionExtent = function (other) {\n        var extent = this._extent;\n        other[0] < extent[0] && (extent[0] = other[0]);\n        other[1] > extent[1] && (extent[1] = other[1]);\n        // not setExtent because in log axis it may transformed to power\n        // this.setExtent(extent[0], extent[1]);\n    };\n\n    /**\n     * Get extent\n     * @return {Array.<number>}\n     */\n    scaleProto.getExtent = function () {\n        return this._extent.slice();\n    };\n\n    /**\n     * Set extent\n     * @param {number} start\n     * @param {number} end\n     */\n    scaleProto.setExtent = function (start, end) {\n        var thisExtent = this._extent;\n        if (!isNaN(start)) {\n            thisExtent[0] = start;\n        }\n        if (!isNaN(end)) {\n            thisExtent[1] = end;\n        }\n    };\n\n    /**\n     * @return {Array.<string>}\n     */\n    scaleProto.getTicksLabels = function () {\n        var labels = [];\n        var ticks = this.getTicks();\n        for (var i = 0; i < ticks.length; i++) {\n            labels.push(this.getLabel(ticks[i]));\n        }\n        return labels;\n    };\n\n    clazzUtil.enableClassExtend(Scale);\n    clazzUtil.enableClassManagement(Scale, {\n        registerWhenExtend: true\n    });\n\n    module.exports = Scale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Scale.js\n// module id = 543\n// module chunks = 16","/**\n * Interval scale\n * @module echarts/scale/Interval\n */\n\n\n\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n    var Scale = require('./Scale');\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n    /**\n     * @alias module:echarts/coord/scale/Interval\n     * @constructor\n     */\n    var IntervalScale = Scale.extend({\n\n        type: 'interval',\n\n        _interval: 0,\n\n        setExtent: function (start, end) {\n            var thisExtent = this._extent;\n            //start,end may be a Number like '25',so...\n            if (!isNaN(start)) {\n                thisExtent[0] = parseFloat(start);\n            }\n            if (!isNaN(end)) {\n                thisExtent[1] = parseFloat(end);\n            }\n        },\n\n        unionExtent: function (other) {\n            var extent = this._extent;\n            other[0] < extent[0] && (extent[0] = other[0]);\n            other[1] > extent[1] && (extent[1] = other[1]);\n\n            // unionExtent may called by it's sub classes\n            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);\n        },\n        /**\n         * Get interval\n         */\n        getInterval: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            return this._interval;\n        },\n\n        /**\n         * Set interval\n         */\n        setInterval: function (interval) {\n            this._interval = interval;\n            // Dropped auto calculated niceExtent and use user setted extent\n            // We assume user wan't to set both interval, min, max to get a better result\n            this._niceExtent = this._extent.slice();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            if (!this._interval) {\n                this.niceTicks();\n            }\n            var interval = this._interval;\n            var extent = this._extent;\n            var ticks = [];\n\n            // Consider this case: using dataZoom toolbox, zoom and zoom.\n            var safeLimit = 10000;\n\n            if (interval) {\n                var niceExtent = this._niceExtent;\n                var precision = getPrecisionSafe(interval) + 2;\n\n                if (extent[0] < niceExtent[0]) {\n                    ticks.push(extent[0]);\n                }\n                var tick = niceExtent[0];\n\n                while (tick <= niceExtent[1]) {\n                    ticks.push(tick);\n                    // Avoid rounding error\n                    tick = roundingErrorFix(tick + interval, precision);\n                    if (ticks.length > safeLimit) {\n                        return [];\n                    }\n                }\n                // Consider this case: the last item of ticks is smaller\n                // than niceExtent[1] and niceExtent[1] === extent[1].\n                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {\n                    ticks.push(extent[1]);\n                }\n            }\n\n            return ticks;\n        },\n\n        /**\n         * @return {Array.<string>}\n         */\n        getTicksLabels: function () {\n            var labels = [];\n            var ticks = this.getTicks();\n            for (var i = 0; i < ticks.length; i++) {\n                labels.push(this.getLabel(ticks[i]));\n            }\n            return labels;\n        },\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        getLabel: function (data) {\n            return formatUtil.addCommas(data);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         *\n         * @param {number} [splitNumber = 5] Desired number of ticks\n         */\n        niceTicks: function (splitNumber) {\n            splitNumber = splitNumber || 5;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (!isFinite(span)) {\n                return;\n            }\n            // User may set axis min 0 and data are all negative\n            // FIXME If it needs to reverse ?\n            if (span < 0) {\n                span = -span;\n                extent.reverse();\n            }\n\n            // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n            // var niceSpan = numberUtil.nice(span, false);\n            var step = roundingErrorFix(\n                numberUtil.nice(span / splitNumber, true),\n                Math.max(\n                    getPrecisionSafe(extent[0]),\n                    getPrecisionSafe(extent[1])\n                // extent may be [0, 1], and step should have 1 more digits.\n                // To make it safe we add 2 more digits\n                ) + 2\n            );\n\n            var precision = getPrecisionSafe(step) + 2;\n            // Niced extent inside original extent\n            var niceExtent = [\n                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),\n                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)\n            ];\n\n            this._interval = step;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [splitNumber = 5] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                if (extent[0] !== 0) {\n                    // Expand extent\n                    var expandSize = extent[0];\n                    // In the fowllowing case\n                    //      Axis has been fixed max 100\n                    //      Plus data are all 100 and axis extent are [100, 100].\n                    // Extend to the both side will cause expanded max is larger than fixed max.\n                    // So only expand to the smaller side.\n                    if (!fixMax) {\n                        extent[1] += expandSize / 2;\n                        extent[0] -= expandSize / 2;\n                    }\n                    else {\n                        extent[0] -= expandSize / 2;\n                    }\n                }\n                else {\n                    extent[1] = 1;\n                }\n            }\n            var span = extent[1] - extent[0];\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (!isFinite(span)) {\n                extent[0] = 0;\n                extent[1] = 1;\n            }\n\n            this.niceTicks(splitNumber);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);\n            }\n        }\n    });\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    IntervalScale.create = function () {\n        return new IntervalScale();\n    };\n\n    module.exports = IntervalScale;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Interval.js\n// module id = 544\n// module chunks = 16","/**\n * Interval scale\n * @module echarts/coord/scale/Time\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var numberUtil = require('../util/number');\n    var formatUtil = require('../util/format');\n\n    var IntervalScale = require('./Interval');\n\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var mathCeil = Math.ceil;\n    var mathFloor = Math.floor;\n    var ONE_SECOND = 1000;\n    var ONE_MINUTE = ONE_SECOND * 60;\n    var ONE_HOUR = ONE_MINUTE * 60;\n    var ONE_DAY = ONE_HOUR * 24;\n\n    // FIXME 公用？\n    var bisect = function (a, x, lo, hi) {\n        while (lo < hi) {\n            var mid = lo + hi >>> 1;\n            if (a[mid][2] < x) {\n                lo = mid + 1;\n            }\n            else {\n                hi  = mid;\n            }\n        }\n        return lo;\n    };\n\n    /**\n     * @alias module:echarts/coord/scale/Time\n     * @constructor\n     */\n    var TimeScale = IntervalScale.extend({\n        type: 'time',\n\n        // Overwrite\n        getLabel: function (val) {\n            var stepLvl = this._stepLvl;\n\n            var date = new Date(val);\n\n            return formatUtil.formatTime(stepLvl[0], date);\n        },\n\n        // Overwrite\n        niceExtent: function (approxTickNum, fixMin, fixMax) {\n            var extent = this._extent;\n            // If extent start and end are same, expand them\n            if (extent[0] === extent[1]) {\n                // Expand extent\n                extent[0] -= ONE_DAY;\n                extent[1] += ONE_DAY;\n            }\n            // If there are no data and extent are [Infinity, -Infinity]\n            if (extent[1] === -Infinity && extent[0] === Infinity) {\n                var d = new Date();\n                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n                extent[0] = extent[1] - ONE_DAY;\n            }\n\n            this.niceTicks(approxTickNum);\n\n            // var extent = this._extent;\n            var interval = this._interval;\n\n            if (!fixMin) {\n                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);\n            }\n            if (!fixMax) {\n                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);\n            }\n        },\n\n        // Overwrite\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            var approxInterval = span / approxTickNum;\n            var scaleLevelsLen = scaleLevels.length;\n            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);\n\n            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];\n            var interval = level[2];\n            // Same with interval scale if span is much larger than 1 year\n            if (level[0] === 'year') {\n                var yearSpan = span / interval;\n\n                // From \"Nice Numbers for Graph Labels\" of Graphic Gems\n                // var niceYearSpan = numberUtil.nice(yearSpan, false);\n                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);\n\n                interval *= yearStep;\n            }\n\n            var niceExtent = [\n                mathCeil(extent[0] / interval) * interval,\n                mathFloor(extent[1] / interval) * interval\n            ];\n\n            this._stepLvl = level;\n            // Interval will be used in getTicks\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        parse: function (val) {\n            // val might be float.\n            return +numberUtil.parseDate(val);\n        }\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        TimeScale.prototype[methodName] = function (val) {\n            return intervalScaleProto[methodName].call(this, this.parse(val));\n        };\n    });\n\n    // Steps from d3\n    var scaleLevels = [\n        // Format       step    interval\n        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s\n        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s\n        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s\n        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s\n        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s\n        ['hh:mm\\nMM-dd',1,      ONE_MINUTE],          // 1m\n        ['hh:mm\\nMM-dd',5,      ONE_MINUTE * 5],      // 5m\n        ['hh:mm\\nMM-dd',10,     ONE_MINUTE * 10],     // 10m\n        ['hh:mm\\nMM-dd',15,     ONE_MINUTE * 15],     // 15m\n        ['hh:mm\\nMM-dd',30,     ONE_MINUTE * 30],     // 30m\n        ['hh:mm\\nMM-dd',1,      ONE_HOUR],        // 1h\n        ['hh:mm\\nMM-dd',2,      ONE_HOUR * 2],    // 2h\n        ['hh:mm\\nMM-dd',6,      ONE_HOUR * 6],    // 6h\n        ['hh:mm\\nMM-dd',12,     ONE_HOUR * 12],   // 12h\n        ['MM-dd\\nyyyy', 1,      ONE_DAY],   // 1d\n        ['week',        7,      ONE_DAY * 7],        // 7d\n        ['month',       1,      ONE_DAY * 31],       // 1M\n        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M\n        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M\n        ['year',        1,      ONE_DAY * 380]       // 1Y\n    ];\n\n    /**\n     * @return {module:echarts/scale/Time}\n     */\n    TimeScale.create = function () {\n        return new TimeScale();\n    };\n\n    module.exports = TimeScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Time.js\n// module id = 545\n// module chunks = 16","/**\n * Log scale\n * @module echarts/scale/Log\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Scale = require('./Scale');\n    var numberUtil = require('../util/number');\n\n    // Use some method of IntervalScale\n    var IntervalScale = require('./Interval');\n\n    var scaleProto = Scale.prototype;\n    var intervalScaleProto = IntervalScale.prototype;\n\n    var getPrecisionSafe = numberUtil.getPrecisionSafe;\n    var roundingErrorFix = numberUtil.round;\n\n    var mathFloor = Math.floor;\n    var mathCeil = Math.ceil;\n    var mathPow = Math.pow;\n\n    var mathLog = Math.log;\n\n    var LogScale = Scale.extend({\n\n        type: 'log',\n\n        base: 10,\n\n        $constructor: function () {\n            Scale.apply(this, arguments);\n            this._originalScale = new IntervalScale();\n        },\n\n        /**\n         * @return {Array.<number>}\n         */\n        getTicks: function () {\n            var originalScale = this._originalScale;\n            var extent = this._extent;\n            var originalExtent = originalScale.getExtent();\n\n            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {\n                var powVal = numberUtil.round(mathPow(this.base, val));\n\n                // Fix #4158\n                powVal = (val === extent[0] && originalScale.__fixMin)\n                    ? fixRoundingError(powVal, originalExtent[0])\n                    : powVal;\n                powVal = (val === extent[1] && originalScale.__fixMax)\n                    ? fixRoundingError(powVal, originalExtent[1])\n                    : powVal;\n\n                return powVal;\n            }, this);\n        },\n\n        /**\n         * @param {number} val\n         * @return {string}\n         */\n        getLabel: intervalScaleProto.getLabel,\n\n        /**\n         * @param  {number} val\n         * @return {number}\n         */\n        scale: function (val) {\n            val = scaleProto.scale.call(this, val);\n            return mathPow(this.base, val);\n        },\n\n        /**\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var base = this.base;\n            start = mathLog(start) / mathLog(base);\n            end = mathLog(end) / mathLog(base);\n            intervalScaleProto.setExtent.call(this, start, end);\n        },\n\n        /**\n         * @return {number} end\n         */\n        getExtent: function () {\n            var base = this.base;\n            var extent = scaleProto.getExtent.call(this);\n            extent[0] = mathPow(base, extent[0]);\n            extent[1] = mathPow(base, extent[1]);\n\n            // Fix #4158\n            var originalScale = this._originalScale;\n            var originalExtent = originalScale.getExtent();\n            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));\n            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));\n\n            return extent;\n        },\n\n        /**\n         * @param  {Array.<number>} extent\n         */\n        unionExtent: function (extent) {\n            this._originalScale.unionExtent(extent);\n\n            var base = this.base;\n            extent[0] = mathLog(extent[0]) / mathLog(base);\n            extent[1] = mathLog(extent[1]) / mathLog(base);\n            scaleProto.unionExtent.call(this, extent);\n        },\n\n        /**\n         * Update interval and extent of intervals for nice ticks\n         * @param  {number} [approxTickNum = 10] Given approx tick number\n         */\n        niceTicks: function (approxTickNum) {\n            approxTickNum = approxTickNum || 10;\n            var extent = this._extent;\n            var span = extent[1] - extent[0];\n            if (span === Infinity || span <= 0) {\n                return;\n            }\n\n            var interval = numberUtil.quantity(span);\n            var err = approxTickNum / span * interval;\n\n            // Filter ticks to get closer to the desired count.\n            if (err <= 0.5) {\n                interval *= 10;\n            }\n\n            // Interval should be integer\n            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {\n                interval *= 10;\n            }\n\n            var niceExtent = [\n                numberUtil.round(mathCeil(extent[0] / interval) * interval),\n                numberUtil.round(mathFloor(extent[1] / interval) * interval)\n            ];\n\n            this._interval = interval;\n            this._niceExtent = niceExtent;\n        },\n\n        /**\n         * Nice extent.\n         * @param {number} [approxTickNum = 10] Given approx tick number\n         * @param {boolean} [fixMin=false]\n         * @param {boolean} [fixMax=false]\n         */\n        niceExtent: function (splitNumber, fixMin, fixMax) {\n            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);\n\n            var originalScale = this._originalScale;\n            originalScale.__fixMin = fixMin;\n            originalScale.__fixMax = fixMax;\n        }\n\n    });\n\n    zrUtil.each(['contain', 'normalize'], function (methodName) {\n        LogScale.prototype[methodName] = function (val) {\n            val = mathLog(val) / mathLog(this.base);\n            return scaleProto[methodName].call(this, val);\n        };\n    });\n\n    LogScale.create = function () {\n        return new LogScale();\n    };\n\n    function fixRoundingError(val, originalVal) {\n        return roundingErrorFix(val, getPrecisionSafe(originalVal));\n    }\n\n    module.exports = LogScale;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/scale/Log.js\n// module id = 546\n// module chunks = 16","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Cartesian = require('./Cartesian');\n\n    function Cartesian2D(name) {\n\n        Cartesian.call(this, name);\n    }\n\n    Cartesian2D.prototype = {\n\n        constructor: Cartesian2D,\n\n        type: 'cartesian2d',\n\n        /**\n         * @type {Array.<string>}\n         * @readOnly\n         */\n        dimensions: ['x', 'y'],\n\n        /**\n         * Base axis will be used on stacking.\n         *\n         * @return {module:echarts/coord/cartesian/Axis2D}\n         */\n        getBaseAxis: function () {\n            return this.getAxesByScale('ordinal')[0]\n                || this.getAxesByScale('time')[0]\n                || this.getAxis('x');\n        },\n\n        /**\n         * If contain point\n         * @param {Array.<number>} point\n         * @return {boolean}\n         */\n        containPoint: function (point) {\n            var axisX = this.getAxis('x');\n            var axisY = this.getAxis('y');\n            return axisX.contain(axisX.toLocalCoord(point[0]))\n                && axisY.contain(axisY.toLocalCoord(point[1]));\n        },\n\n        /**\n         * If contain data\n         * @param {Array.<number>} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.getAxis('x').containData(data[0])\n                && this.getAxis('y').containData(data[1]);\n        },\n\n        /**\n         * Convert series data to an array of points\n         * @param {module:echarts/data/List} data\n         * @param {boolean} stack\n         * @return {Array}\n         *  Return array of points. For example:\n         *  `[[10, 10], [20, 20], [30, 30]]`\n         */\n        dataToPoints: function (data, stack) {\n            return data.mapArray(['x', 'y'], function (x, y) {\n                return this.dataToPoint([x, y]);\n            }, stack, this);\n        },\n\n        /**\n         * @param {Array.<number>} data\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        dataToPoint: function (data, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),\n                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))\n            ];\n        },\n\n        /**\n         * @param {Array.<number>} point\n         * @param {boolean} [clamp=false]\n         * @return {Array.<number>}\n         */\n        pointToData: function (point, clamp) {\n            var xAxis = this.getAxis('x');\n            var yAxis = this.getAxis('y');\n            return [\n                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),\n                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)\n            ];\n        },\n\n        /**\n         * Get other axis\n         * @param {module:echarts/coord/cartesian/Axis2D} axis\n         */\n        getOtherAxis: function (axis) {\n            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n        }\n    };\n\n    zrUtil.inherits(Cartesian2D, Cartesian);\n\n    module.exports = Cartesian2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 547\n// module chunks = 16","'use strict';\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    function dimAxisMapper(dim) {\n        return this._axes[dim];\n    }\n\n    /**\n     * @alias module:echarts/coord/Cartesian\n     * @constructor\n     */\n    var Cartesian = function (name) {\n        this._axes = {};\n\n        this._dimList = [];\n\n        /**\n         * @type {string}\n         */\n        this.name = name || '';\n    };\n\n    Cartesian.prototype = {\n\n        constructor: Cartesian,\n\n        type: 'cartesian',\n\n        /**\n         * Get axis\n         * @param  {number|string} dim\n         * @return {module:echarts/coord/Cartesian~Axis}\n         */\n        getAxis: function (dim) {\n            return this._axes[dim];\n        },\n\n        /**\n         * Get axes list\n         * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n         */\n        getAxes: function () {\n            return zrUtil.map(this._dimList, dimAxisMapper, this);\n        },\n\n        /**\n         * Get axes list by given scale type\n         */\n        getAxesByScale: function (scaleType) {\n            scaleType = scaleType.toLowerCase();\n            return zrUtil.filter(\n                this.getAxes(),\n                function (axis) {\n                    return axis.scale.type === scaleType;\n                }\n            );\n        },\n\n        /**\n         * Add axis\n         * @param {module:echarts/coord/Cartesian.Axis}\n         */\n        addAxis: function (axis) {\n            var dim = axis.dim;\n\n            this._axes[dim] = axis;\n\n            this._dimList.push(dim);\n        },\n\n        /**\n         * Convert data to coord in nd space\n         * @param {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        dataToCoord: function (val) {\n            return this._dataCoordConvert(val, 'dataToCoord');\n        },\n\n        /**\n         * Convert coord in nd space to data\n         * @param  {Array.<number>|Object.<string, number>} val\n         * @return {Array.<number>|Object.<string, number>}\n         */\n        coordToData: function (val) {\n            return this._dataCoordConvert(val, 'coordToData');\n        },\n\n        _dataCoordConvert: function (input, method) {\n            var dimList = this._dimList;\n\n            var output = input instanceof Array ? [] : {};\n\n            for (var i = 0; i < dimList.length; i++) {\n                var dim = dimList[i];\n                var axis = this._axes[dim];\n\n                output[dim] = axis[method](input[dim]);\n            }\n\n            return output;\n        }\n    };\n\n    module.exports = Cartesian;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 548\n// module chunks = 16","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Axis = require('../Axis');\n    var axisLabelInterval = require('./axisLabelInterval');\n\n    /**\n     * Extend axis 2d\n     * @constructor module:echarts/coord/cartesian/Axis2D\n     * @extends {module:echarts/coord/cartesian/Axis}\n     * @param {string} dim\n     * @param {*} scale\n     * @param {Array.<number>} coordExtent\n     * @param {string} axisType\n     * @param {string} position\n     */\n    var Axis2D = function (dim, scale, coordExtent, axisType, position) {\n        Axis.call(this, dim, scale, coordExtent);\n        /**\n         * Axis type\n         *  - 'category'\n         *  - 'value'\n         *  - 'time'\n         *  - 'log'\n         * @type {string}\n         */\n        this.type = axisType || 'value';\n\n        /**\n         * Axis position\n         *  - 'top'\n         *  - 'bottom'\n         *  - 'left'\n         *  - 'right'\n         */\n        this.position = position || 'bottom';\n    };\n\n    Axis2D.prototype = {\n\n        constructor: Axis2D,\n\n        /**\n         * Index of axis, can be used as key\n         */\n        index: 0,\n        /**\n         * If axis is on the zero position of the other axis\n         * @type {boolean}\n         */\n        onZero: false,\n\n        /**\n         * Axis model\n         * @param {module:echarts/coord/cartesian/AxisModel}\n         */\n        model: null,\n\n        isHorizontal: function () {\n            var position = this.position;\n            return position === 'top' || position === 'bottom';\n        },\n\n        getGlobalExtent: function () {\n            var ret = this.getExtent();\n            ret[0] = this.toGlobalCoord(ret[0]);\n            ret[1] = this.toGlobalCoord(ret[1]);\n            return ret;\n        },\n\n        /**\n         * @return {number}\n         */\n        getLabelInterval: function () {\n            var labelInterval = this._labelInterval;\n            if (!labelInterval) {\n                labelInterval = this._labelInterval = axisLabelInterval(this);\n            }\n            return labelInterval;\n        },\n\n        /**\n         * If label is ignored.\n         * Automatically used when axis is category and label can not be all shown\n         * @param  {number}  idx\n         * @return {boolean}\n         */\n        isLabelIgnored: function (idx) {\n            if (this.type === 'category') {\n                var labelInterval = this.getLabelInterval();\n                return ((typeof labelInterval === 'function')\n                    && !labelInterval(idx, this.scale.getLabel(idx)))\n                    || idx % (labelInterval + 1);\n            }\n        },\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var localCoord = axis.toLocalCoord(80);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toLocalCoord: null,\n\n        /**\n         * Transform global coord to local coord,\n         * i.e. var globalCoord = axis.toLocalCoord(40);\n         * designate by module:echarts/coord/cartesian/Grid.\n         * @type {Function}\n         */\n        toGlobalCoord: null\n\n    };\n    zrUtil.inherits(Axis2D, Axis);\n\n    module.exports = Axis2D;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 549\n// module chunks = 16","\n\n    var numberUtil = require('../util/number');\n    var linearMap = numberUtil.linearMap;\n    var zrUtil = require('zrender/lib/core/util');\n\n    function fixExtentWithBands(extent, nTick) {\n        var size = extent[1] - extent[0];\n        var len = nTick;\n        var margin = size / len / 2;\n        extent[0] += margin;\n        extent[1] -= margin;\n    }\n\n    var normalizedExtent = [0, 1];\n    /**\n     * @name module:echarts/coord/CartesianAxis\n     * @constructor\n     */\n    var Axis = function (dim, scale, extent) {\n\n        /**\n         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'\n         * @type {string}\n         */\n        this.dim = dim;\n\n        /**\n         * Axis scale\n         * @type {module:echarts/coord/scale/*}\n         */\n        this.scale = scale;\n\n        /**\n         * @type {Array.<number>}\n         * @private\n         */\n        this._extent = extent || [0, 0];\n\n        /**\n         * @type {boolean}\n         */\n        this.inverse = false;\n\n        /**\n         * Usually true when axis has a ordinal scale\n         * @type {boolean}\n         */\n        this.onBand = false;\n    };\n\n    Axis.prototype = {\n\n        constructor: Axis,\n\n        /**\n         * If axis extent contain given coord\n         * @param {number} coord\n         * @return {boolean}\n         */\n        contain: function (coord) {\n            var extent = this._extent;\n            var min = Math.min(extent[0], extent[1]);\n            var max = Math.max(extent[0], extent[1]);\n            return coord >= min && coord <= max;\n        },\n\n        /**\n         * If axis extent contain given data\n         * @param {number} data\n         * @return {boolean}\n         */\n        containData: function (data) {\n            return this.contain(this.dataToCoord(data));\n        },\n\n        /**\n         * Get coord extent.\n         * @return {Array.<number>}\n         */\n        getExtent: function () {\n            var ret = this._extent.slice();\n            return ret;\n        },\n\n        /**\n         * Get precision used for formatting\n         * @param {Array.<number>} [dataExtent]\n         * @return {number}\n         */\n        getPixelPrecision: function (dataExtent) {\n            return numberUtil.getPixelPrecision(\n                dataExtent || this.scale.getExtent(),\n                this._extent\n            );\n        },\n\n        /**\n         * Set coord extent\n         * @param {number} start\n         * @param {number} end\n         */\n        setExtent: function (start, end) {\n            var extent = this._extent;\n            extent[0] = start;\n            extent[1] = end;\n        },\n\n        /**\n         * Convert data to coord. Data is the rank if it has a ordinal scale\n         * @param {number} data\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        dataToCoord: function (data, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n            data = scale.normalize(data);\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            return linearMap(data, normalizedExtent, extent, clamp);\n        },\n\n        /**\n         * Convert coord to data. Data is the rank if it has a ordinal scale\n         * @param {number} coord\n         * @param  {boolean} clamp\n         * @return {number}\n         */\n        coordToData: function (coord, clamp) {\n            var extent = this._extent;\n            var scale = this.scale;\n\n            if (this.onBand && scale.type === 'ordinal') {\n                extent = extent.slice();\n                fixExtentWithBands(extent, scale.count());\n            }\n\n            var t = linearMap(coord, extent, normalizedExtent, clamp);\n\n            return this.scale.scale(t);\n        },\n        /**\n         * @return {Array.<number>}\n         */\n        getTicksCoords: function (alignWithLabel) {\n            if (this.onBand && !alignWithLabel) {\n                var bands = this.getBands();\n                var coords = [];\n                for (var i = 0; i < bands.length; i++) {\n                    coords.push(bands[i][0]);\n                }\n                if (bands[i - 1]) {\n                    coords.push(bands[i - 1][1]);\n                }\n                return coords;\n            }\n            else {\n                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n            }\n        },\n\n        /**\n         * Coords of labels are on the ticks or on the middle of bands\n         * @return {Array.<number>}\n         */\n        getLabelsCoords: function () {\n            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);\n        },\n\n        /**\n         * Get bands.\n         *\n         * If axis has labels [1, 2, 3, 4]. Bands on the axis are\n         * |---1---|---2---|---3---|---4---|.\n         *\n         * @return {Array}\n         */\n         // FIXME Situation when labels is on ticks\n        getBands: function () {\n            var extent = this.getExtent();\n            var bands = [];\n            var len = this.scale.count();\n            var start = extent[0];\n            var end = extent[1];\n            var span = end - start;\n\n            for (var i = 0; i < len; i++) {\n                bands.push([\n                    span * i / len + start,\n                    span * (i + 1) / len + start\n                ]);\n            }\n            return bands;\n        },\n\n        /**\n         * Get width of band\n         * @return {number}\n         */\n        getBandWidth: function () {\n            var axisExtent = this._extent;\n            var dataExtent = this.scale.getExtent();\n\n            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);\n            // Fix #2728, avoid NaN when only one data.\n            len === 0 && (len = 1);\n\n            var size = Math.abs(axisExtent[1] - axisExtent[0]);\n\n            return Math.abs(size) / len;\n        }\n    };\n\n    module.exports = Axis;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/Axis.js\n// module id = 550\n// module chunks = 16","'use strict';\n/**\n * Helper function for axisLabelInterval calculation\n */\n\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('../axisHelper');\n\n    module.exports = function (axis) {\n        var axisModel = axis.model;\n        var labelModel = axisModel.getModel('axisLabel');\n        var labelInterval = labelModel.get('interval');\n        if (!(axis.type === 'category' && labelInterval === 'auto')) {\n            return labelInterval === 'auto' ? 0 : labelInterval;\n        }\n\n        return axisHelper.getAxisLabelInterval(\n            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),\n            axisModel.getFormattedLabels(),\n            labelModel.getModel('textStyle').getFont(),\n            axis.isHorizontal()\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/axisLabelInterval.js\n// module id = 551\n// module chunks = 16","'use strict';\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\n\n\n    require('./AxisModel');\n    var ComponentModel = require('../../model/Component');\n\n    module.exports = ComponentModel.extend({\n\n        type: 'grid',\n\n        dependencies: ['xAxis', 'yAxis'],\n\n        layoutMode: 'box',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Grid}\n         */\n        coordinateSystem: null,\n\n        defaultOption: {\n            show: false,\n            zlevel: 0,\n            z: 0,\n            left: '10%',\n            top: 60,\n            right: '10%',\n            bottom: 60,\n            // If grid size contain label\n            containLabel: false,\n            // width: {totalWidth} - left - right,\n            // height: {totalHeight} - top - bottom,\n            backgroundColor: 'rgba(0,0,0,0)',\n            borderWidth: 1,\n            borderColor: '#ccc'\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/GridModel.js\n// module id = 552\n// module chunks = 16","'use strict';\n\n\n    var ComponentModel = require('../../model/Component');\n    var zrUtil = require('zrender/lib/core/util');\n    var axisModelCreator = require('../axisModelCreator');\n\n    var AxisModel = ComponentModel.extend({\n\n        type: 'cartesian2dAxis',\n\n        /**\n         * @type {module:echarts/coord/cartesian/Axis2D}\n         */\n        axis: null,\n\n        /**\n         * @override\n         */\n        init: function () {\n            AxisModel.superApply(this, 'init', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        mergeOption: function () {\n            AxisModel.superApply(this, 'mergeOption', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @override\n         */\n        restoreData: function () {\n            AxisModel.superApply(this, 'restoreData', arguments);\n            this.resetRange();\n        },\n\n        /**\n         * @return {module:echarts/model/Model}\n         */\n        findGridModel: function () {\n            return this.ecModel.queryComponents({\n                mainType: 'grid',\n                index: this.get('gridIndex'),\n                id: this.get('gridId')\n            })[0];\n        }\n\n    });\n\n    function getAxisType(axisDim, option) {\n        // Default axis with data is category axis\n        return option.type || (option.data ? 'category' : 'value');\n    }\n\n    zrUtil.merge(AxisModel.prototype, require('../axisModelCommonMixin'));\n    zrUtil.merge(AxisModel.prototype, require('../axisModelZoomMixin'));\n\n    var extraOption = {\n        // gridIndex: 0,\n        // gridId: '',\n\n        // Offset is for multiple axis on the same position\n        offset: 0\n    };\n\n    axisModelCreator('x', AxisModel, getAxisType, extraOption);\n    axisModelCreator('y', AxisModel, getAxisType, extraOption);\n\n    module.exports = AxisModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 553\n// module chunks = 16","\n\n    var axisDefault = require('./axisDefault');\n    var zrUtil = require('zrender/lib/core/util');\n    var ComponentModel = require('../model/Component');\n    var layout = require('../util/layout');\n\n    // FIXME axisType is fixed ?\n    var AXIS_TYPES = ['value', 'category', 'time', 'log'];\n\n    /**\n     * Generate sub axis model class\n     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n     * @param {module:echarts/model/Component} BaseAxisModelClass\n     * @param {Function} axisTypeDefaulter\n     * @param {Object} [extraDefaultOption]\n     */\n    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n\n        zrUtil.each(AXIS_TYPES, function (axisType) {\n\n            BaseAxisModelClass.extend({\n\n                type: axisName + 'Axis.' + axisType,\n\n                mergeDefaultAndTheme: function (option, ecModel) {\n                    var layoutMode = this.layoutMode;\n                    var inputPositionParams = layoutMode\n                        ? layout.getLayoutParams(option) : {};\n\n                    var themeModel = ecModel.getTheme();\n                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n                    zrUtil.merge(option, this.getDefaultOption());\n\n                    option.type = axisTypeDefaulter(axisName, option);\n\n                    if (layoutMode) {\n                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);\n                    }\n                },\n\n                defaultOption: zrUtil.mergeAll(\n                    [\n                        {},\n                        axisDefault[axisType + 'Axis'],\n                        extraDefaultOption\n                    ],\n                    true\n                )\n            });\n        });\n\n        ComponentModel.registerSubTypeDefaulter(\n            axisName + 'Axis',\n            zrUtil.curry(axisTypeDefaulter, axisName)\n        );\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCreator.js\n// module id = 554\n// module chunks = 16","\n\n    var zrUtil = require('zrender/lib/core/util');\n\n    var defaultOption = {\n        show: true,\n        zlevel: 0,                  // 一级层叠\n        z: 0,                       // 二级层叠\n        // 反向坐标轴\n        inverse: false,\n\n        // 坐标轴名字，默认为空\n        name: '',\n        // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n        nameLocation: 'end',\n        // 坐标轴名字旋转，degree。\n        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.\n        nameTruncate: {\n            maxWidth: null,\n            ellipsis: '...',\n            placeholder: '.'\n        },\n        // 坐标轴文字样式，默认取全局样式\n        nameTextStyle: {},\n        // 文字与轴线距离\n        nameGap: 15,\n\n        silent: false, // Default false to support tooltip.\n        triggerEvent: false, // Default false to avoid legacy user event listener fail.\n\n        tooltip: {\n            show: false\n        },\n\n        // 坐标轴线\n        axisLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            onZero: true,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                color: '#333',\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // 属性show控制显示与否，默认显示\n            show: true,\n            // 控制小标记是否在grid里\n            inside: false,\n            // 属性length控制线长\n            length: 5,\n            // 属性lineStyle控制线条样式\n            lineStyle: {\n                width: 1\n            }\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            show: true,\n            // 控制文本标签是否在grid里\n            inside: false,\n            rotate: 0,\n            margin: 8,\n            // formatter: null,\n            // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n            textStyle: {\n                fontSize: 12\n            }\n        },\n        // 分隔线\n        splitLine: {\n            // 默认显示，属性show控制显示与否\n            show: true,\n            // 属性lineStyle（详见lineStyle）控制线条样式\n            lineStyle: {\n                color: ['#ccc'],\n                width: 1,\n                type: 'solid'\n            }\n        },\n        // 分隔区域\n        splitArea: {\n            // 默认不显示，属性show控制显示与否\n            show: false,\n            // 属性areaStyle（详见areaStyle）控制区域样式\n            areaStyle: {\n                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']\n            }\n        }\n    };\n\n    var categoryAxis = zrUtil.merge({\n        // 类目起始和结束两端空白策略\n        boundaryGap: true,\n        // splitArea: {\n            // show: false\n        // },\n        splitLine: {\n            show: false\n        },\n        // 坐标轴小标记\n        axisTick: {\n            // If tick is align with label when boundaryGap is true\n            // Default with axisTick\n            alignWithLabel: false,\n            interval: 'auto'\n        },\n        // 坐标轴文本标签，详见axis.axisLabel\n        axisLabel: {\n            interval: 'auto'\n        }\n    }, defaultOption);\n\n    var valueAxis = zrUtil.merge({\n        // 数值起始和结束两端空白策略\n        boundaryGap: [0, 0],\n        // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n        // min: null,\n        // 最大值，设置成 'dataMax' 则从数据中计算最大值\n        // max: null,\n        // Readonly prop, specifies start value of the range when using data zoom.\n        // rangeStart: null\n        // Readonly prop, specifies end value of the range when using data zoom.\n        // rangeEnd: null\n        // 脱离0值比例，放大聚焦到最终_min，_max区间\n        // scale: false,\n        // 分割段数，默认为5\n        splitNumber: 5\n        // Minimum interval\n        // minInterval: null\n    }, defaultOption);\n\n    // FIXME\n    var timeAxis = zrUtil.defaults({\n        scale: true,\n        min: 'dataMin',\n        max: 'dataMax'\n    }, valueAxis);\n    var logAxis = zrUtil.defaults({\n        logBase: 10\n    }, valueAxis);\n    logAxis.scale = true;\n\n    module.exports = {\n        categoryAxis: categoryAxis,\n        valueAxis: valueAxis,\n        timeAxis: timeAxis,\n        logAxis: logAxis\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 555\n// module chunks = 16","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var axisHelper = require('./axisHelper');\n\n    function getName(obj) {\n        if (zrUtil.isObject(obj) && obj.value != null) {\n            return obj.value;\n        }\n        else {\n            return obj;\n        }\n    }\n    /**\n     * Get categories\n     */\n    function getCategories() {\n        return this.get('type') === 'category'\n            && zrUtil.map(this.get('data'), getName);\n    }\n\n    /**\n     * Format labels\n     * @return {Array.<string>}\n     */\n    function getFormattedLabels() {\n        return axisHelper.getFormattedLabels(\n            this.axis,\n            this.get('axisLabel.formatter')\n        );\n    }\n\n    module.exports = {\n\n        getFormattedLabels: getFormattedLabels,\n\n        getCategories: getCategories\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCommonMixin.js\n// module id = 556\n// module chunks = 16","\n\n    module.exports = {\n\n        /**\n         * @public\n         * @return {Array.<number|string|Date>}\n         */\n        getMin: function () {\n            var option = this.option;\n            var min = option.rangeStart != null ? option.rangeStart : option.min;\n            // In case of axis.type === 'time', Date should be converted to timestamp.\n            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n            if (min instanceof Date) {\n                min = +min;\n            }\n            return min;\n        },\n\n        /**\n         * @public\n         * @return {Array.<number|string|Date>}\n         */\n        getMax: function () {\n            var option = this.option;\n            var max = option.rangeEnd != null ? option.rangeEnd : option.max;\n            // In case of axis.type === 'time', Date should be converted to timestamp.\n            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.\n            if (max instanceof Date) {\n                max = +max;\n            }\n            return max;\n        },\n\n        /**\n         * @public\n         * @return {boolean}\n         */\n        getNeedCrossZero: function () {\n            var option = this.option;\n            return (option.rangeStart != null || option.rangeEnd != null)\n                ? false : !option.scale;\n        },\n\n        /**\n         * @public\n         * @param {number} rangeStart\n         * @param {number} rangeEnd\n         */\n        setRange: function (rangeStart, rangeEnd) {\n            this.option.rangeStart = rangeStart;\n            this.option.rangeEnd = rangeEnd;\n        },\n\n        /**\n         * @public\n         */\n        resetRange: function () {\n            // rangeStart and rangeEnd is readonly.\n            this.option.rangeStart = this.option.rangeEnd = null;\n        }\n    };\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelZoomMixin.js\n// module id = 557\n// module chunks = 16","'use strict';\n// TODO boundaryGap\n\n\n    require('../coord/cartesian/AxisModel');\n\n    require('./axis/AxisView');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis.js\n// module id = 558\n// module chunks = 16","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var graphic = require('../../util/graphic');\n    var AxisBuilder = require('./AxisBuilder');\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\n    var getInterval = AxisBuilder.getInterval;\n\n    var axisBuilderAttrs = [\n        'axisLine', 'axisLabel', 'axisTick', 'axisName'\n    ];\n    var selfBuilderAttrs = [\n        'splitArea', 'splitLine'\n    ];\n\n    // function getAlignWithLabel(model, axisModel) {\n    //     var alignWithLabel = model.get('alignWithLabel');\n    //     if (alignWithLabel === 'auto') {\n    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n    //     }\n    //     return alignWithLabel;\n    // }\n\n    var AxisView = require('../../echarts').extendComponentView({\n\n        type: 'axis',\n\n        render: function (axisModel, ecModel) {\n\n            this.group.removeAll();\n\n            var oldAxisGroup = this._axisGroup;\n            this._axisGroup = new graphic.Group();\n\n            this.group.add(this._axisGroup);\n\n            if (!axisModel.get('show')) {\n                return;\n            }\n\n            var gridModel = axisModel.findGridModel();\n\n            var layout = layoutAxis(gridModel, axisModel);\n\n            var axisBuilder = new AxisBuilder(axisModel, layout);\n\n            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n            this._axisGroup.add(axisBuilder.getGroup());\n\n            zrUtil.each(selfBuilderAttrs, function (name) {\n                if (axisModel.get(name + '.show')) {\n                    this['_' + name](axisModel, gridModel, layout.labelInterval);\n                }\n            }, this);\n\n            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitLine: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            var splitLineModel = axisModel.getModel('splitLine');\n            var lineStyleModel = splitLineModel.getModel('lineStyle');\n            var lineColors = lineStyleModel.get('color');\n\n            var lineInterval = getInterval(splitLineModel, labelInterval);\n\n            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n            var isHorizontal = axis.isHorizontal();\n\n            var lineCount = 0;\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitLineModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var p1 = [];\n            var p2 = [];\n            // Simple optimization\n            // Batching the lines if color are the same\n            var lineStyle = lineStyleModel.getLineStyle();\n            for (var i = 0; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, lineInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                if (isHorizontal) {\n                    p1[0] = tickCoord;\n                    p1[1] = gridRect.y;\n                    p2[0] = tickCoord;\n                    p2[1] = gridRect.y + gridRect.height;\n                }\n                else {\n                    p1[0] = gridRect.x;\n                    p1[1] = tickCoord;\n                    p2[0] = gridRect.x + gridRect.width;\n                    p2[1] = tickCoord;\n                }\n\n                var colorIndex = (lineCount++) % lineColors.length;\n                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n                    anid: 'line_' + ticks[i],\n\n                    shape: {\n                        x1: p1[0],\n                        y1: p1[1],\n                        x2: p2[0],\n                        y2: p2[1]\n                    },\n                    style: zrUtil.defaults({\n                        stroke: lineColors[colorIndex]\n                    }, lineStyle),\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @param {number|Function} labelInterval\n         * @private\n         */\n        _splitArea: function (axisModel, gridModel, labelInterval) {\n            var axis = axisModel.axis;\n\n            var splitAreaModel = axisModel.getModel('splitArea');\n            var areaStyleModel = splitAreaModel.getModel('areaStyle');\n            var areaColors = areaStyleModel.get('color');\n\n            var gridRect = gridModel.coordinateSystem.getRect();\n\n            var ticksCoords = axis.getTicksCoords(\n                // splitAreaModel.get('alignWithLabel')\n            );\n            var ticks = axis.scale.getTicks();\n\n            var prevX = axis.toGlobalCoord(ticksCoords[0]);\n            var prevY = axis.toGlobalCoord(ticksCoords[0]);\n\n            var count = 0;\n\n            var areaInterval = getInterval(splitAreaModel, labelInterval);\n\n            var areaStyle = areaStyleModel.getAreaStyle();\n            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n            for (var i = 1; i < ticksCoords.length; i++) {\n                if (ifIgnoreOnTick(axis, i, areaInterval)) {\n                    continue;\n                }\n\n                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n                var x;\n                var y;\n                var width;\n                var height;\n                if (axis.isHorizontal()) {\n                    x = prevX;\n                    y = gridRect.y;\n                    width = tickCoord - x;\n                    height = gridRect.height;\n                }\n                else {\n                    x = gridRect.x;\n                    y = prevY;\n                    width = gridRect.width;\n                    height = tickCoord - y;\n                }\n\n                var colorIndex = (count++) % areaColors.length;\n                this._axisGroup.add(new graphic.Rect({\n                    anid: 'area_' + ticks[i],\n\n                    shape: {\n                        x: x,\n                        y: y,\n                        width: width,\n                        height: height\n                    },\n                    style: zrUtil.defaults({\n                        fill: areaColors[colorIndex]\n                    }, areaStyle),\n                    silent: true\n                }));\n\n                prevX = x + width;\n                prevY = y + height;\n            }\n        }\n    });\n\n    AxisView.extend({\n        type: 'xAxis'\n    });\n    AxisView.extend({\n        type: 'yAxis'\n    });\n\n    /**\n     * @inner\n     */\n    function layoutAxis(gridModel, axisModel) {\n        var grid = gridModel.coordinateSystem;\n        var axis = axisModel.axis;\n        var layout = {};\n\n        var rawAxisPosition = axis.position;\n        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;\n        var axisDim = axis.dim;\n\n        // [left, right, top, bottom]\n        var rect = grid.getRect();\n        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];\n\n        var axisOffset = axisModel.get('offset') || 0;\n\n        var posMap = {\n            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },\n            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }\n        };\n\n        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);\n        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);\n\n        function getZero(dim, val) {\n            var theAxis = grid.getAxis(dim);\n            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));\n        }\n\n        // Axis position\n        layout.position = [\n            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],\n            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]\n        ];\n\n        // Axis rotation\n        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);\n\n        // Tick and label direction, x y is axisDim\n        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};\n\n        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];\n        if (axis.onZero) {\n            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;\n        }\n\n        if (axisModel.getModel('axisTick').get('inside')) {\n            layout.tickDirection = -layout.tickDirection;\n        }\n        if (axisModel.getModel('axisLabel').get('inside')) {\n            layout.labelDirection = -layout.labelDirection;\n        }\n\n        // Special label rotation\n        var labelRotation = axisModel.getModel('axisLabel').get('rotate');\n        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;\n\n        // label interval when auto mode.\n        layout.labelInterval = axis.getLabelInterval();\n\n        // Over splitLine and splitArea\n        layout.z2 = 1;\n\n        return layout;\n    }\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisView.js\n// module id = 559\n// module chunks = 16","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n    var Model = require('../../model/Model');\n    var numberUtil = require('../../util/number');\n    var remRadian = numberUtil.remRadian;\n    var isRadianAroundZero = numberUtil.isRadianAroundZero;\n    var vec2 = require('zrender/lib/core/vector');\n    var v2ApplyTransform = vec2.applyTransform;\n    var retrieve = zrUtil.retrieve;\n\n    var PI = Math.PI;\n\n    function makeAxisEventDataBase(axisModel) {\n        var eventData = {\n            componentType: axisModel.mainType\n        };\n        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n        return eventData;\n    }\n\n    /**\n     * A final axis is translated and rotated from a \"standard axis\".\n     * So opt.position and opt.rotation is required.\n     *\n     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n     * for example: (0, 0) ------------> (0, 50)\n     *\n     * nameDirection or tickDirection or labelDirection is 1 means tick\n     * or label is below the standard axis, whereas is -1 means above\n     * the standard axis. labelOffset means offset between label and axis,\n     * which is useful when 'onZero', where axisLabel is in the grid and\n     * label in outside grid.\n     *\n     * Tips: like always,\n     * positive rotation represents anticlockwise, and negative rotation\n     * represents clockwise.\n     * The direction of position coordinate is the same as the direction\n     * of screen coordinate.\n     *\n     * Do not need to consider axis 'inverse', which is auto processed by\n     * axis extent.\n     *\n     * @param {module:zrender/container/Group} group\n     * @param {Object} axisModel\n     * @param {Object} opt Standard axis parameters.\n     * @param {Array.<number>} opt.position [x, y]\n     * @param {number} opt.rotation by radian\n     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.\n     * @param {number} [opt.tickDirection=1] 1 or -1\n     * @param {number} [opt.labelDirection=1] 1 or -1\n     * @param {number} [opt.labelOffset=0] Usefull when onZero.\n     * @param {string} [opt.axisLabelShow] default get from axisModel.\n     * @param {string} [opt.axisName] default get from axisModel.\n     * @param {number} [opt.axisNameAvailableWidth]\n     * @param {number} [opt.labelRotation] by degree, default get from axisModel.\n     * @param {number} [opt.labelInterval] Default label interval when label\n     *                                     interval from model is null or 'auto'.\n     * @param {number} [opt.strokeContainThreshold] Default label interval when label\n     */\n    var AxisBuilder = function (axisModel, opt) {\n\n        /**\n         * @readOnly\n         */\n        this.opt = opt;\n\n        /**\n         * @readOnly\n         */\n        this.axisModel = axisModel;\n\n        // Default value\n        zrUtil.defaults(\n            opt,\n            {\n                labelOffset: 0,\n                nameDirection: 1,\n                tickDirection: 1,\n                labelDirection: 1,\n                silent: true\n            }\n        );\n\n        /**\n         * @readOnly\n         */\n        this.group = new graphic.Group();\n\n        // FIXME Not use a seperate text group?\n        var dumbGroup = new graphic.Group({\n            position: opt.position.slice(),\n            rotation: opt.rotation\n        });\n\n        // this.group.add(dumbGroup);\n        // this._dumbGroup = dumbGroup;\n\n        dumbGroup.updateTransform();\n        this._transform = dumbGroup.transform;\n\n        this._dumbGroup = dumbGroup;\n    };\n\n    AxisBuilder.prototype = {\n\n        constructor: AxisBuilder,\n\n        hasBuilder: function (name) {\n            return !!builders[name];\n        },\n\n        add: function (name) {\n            builders[name].call(this);\n        },\n\n        getGroup: function () {\n            return this.group;\n        }\n\n    };\n\n    var builders = {\n\n        /**\n         * @private\n         */\n        axisLine: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisLine.show')) {\n                return;\n            }\n\n            var extent = this.axisModel.axis.getExtent();\n\n            var matrix = this._transform;\n            var pt1 = [extent[0], 0];\n            var pt2 = [extent[1], 0];\n            if (matrix) {\n                v2ApplyTransform(pt1, pt1, matrix);\n                v2ApplyTransform(pt2, pt2, matrix);\n            }\n\n            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                // Id for animation\n                anid: 'line',\n\n                shape: {\n                    x1: pt1[0],\n                    y1: pt1[1],\n                    x2: pt2[0],\n                    y2: pt2[1]\n                },\n                style: zrUtil.extend(\n                    {lineCap: 'round'},\n                    axisModel.getModel('axisLine.lineStyle').getLineStyle()\n                ),\n                strokeContainThreshold: opt.strokeContainThreshold || 5,\n                silent: true,\n                z2: 1\n            })));\n        },\n\n        /**\n         * @private\n         */\n        axisTick: function () {\n            var axisModel = this.axisModel;\n\n            if (!axisModel.get('axisTick.show')) {\n                return;\n            }\n\n            var axis = axisModel.axis;\n            var tickModel = axisModel.getModel('axisTick');\n            var opt = this.opt;\n\n            var lineStyleModel = tickModel.getModel('lineStyle');\n            var tickLen = tickModel.get('length');\n\n            var tickInterval = getInterval(tickModel, opt.labelInterval);\n            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));\n            var ticks = axis.scale.getTicks();\n\n            var pt1 = [];\n            var pt2 = [];\n            var matrix = this._transform;\n\n            for (var i = 0; i < ticksCoords.length; i++) {\n                // Only ordinal scale support tick interval\n                if (ifIgnoreOnTick(axis, i, tickInterval)) {\n                     continue;\n                }\n\n                var tickCoord = ticksCoords[i];\n\n                pt1[0] = tickCoord;\n                pt1[1] = 0;\n                pt2[0] = tickCoord;\n                pt2[1] = opt.tickDirection * tickLen;\n\n                if (matrix) {\n                    v2ApplyTransform(pt1, pt1, matrix);\n                    v2ApplyTransform(pt2, pt2, matrix);\n                }\n                // Tick line, Not use group transform to have better line draw\n                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({\n\n                    // Id for animation\n                    anid: 'tick_' + ticks[i],\n\n                    shape: {\n                        x1: pt1[0],\n                        y1: pt1[1],\n                        x2: pt2[0],\n                        y2: pt2[1]\n                    },\n                    style: zrUtil.defaults(\n                        lineStyleModel.getLineStyle(),\n                        {\n                            stroke: axisModel.get('axisLine.lineStyle.color')\n                        }\n                    ),\n                    z2: 2,\n                    silent: true\n                })));\n            }\n        },\n\n        /**\n         * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n         * @param {module:echarts/coord/cartesian/GridModel} gridModel\n         * @private\n         */\n        axisLabel: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n            if (!show) {\n                return;\n            }\n\n            var axis = axisModel.axis;\n            var labelModel = axisModel.getModel('axisLabel');\n            var textStyleModel = labelModel.getModel('textStyle');\n            var labelMargin = labelModel.get('margin');\n            var ticks = axis.scale.getTicks();\n            var labels = axisModel.getFormattedLabels();\n\n            // Special label rotate.\n            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;\n            // To radian.\n            labelRotation = labelRotation * PI / 180;\n\n            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);\n            var categoryData = axisModel.get('data');\n\n            var textEls = [];\n            var silent = isSilent(axisModel);\n            var triggerEvent = axisModel.get('triggerEvent');\n\n            for (var i = 0; i < ticks.length; i++) {\n                if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {\n                     continue;\n                }\n\n                var itemTextStyleModel = textStyleModel;\n                if (categoryData && categoryData[i] && categoryData[i].textStyle) {\n                    itemTextStyleModel = new Model(\n                        categoryData[i].textStyle, textStyleModel, axisModel.ecModel\n                    );\n                }\n                var textColor = itemTextStyleModel.getTextColor()\n                    || axisModel.get('axisLine.lineStyle.color');\n\n                var tickCoord = axis.dataToCoord(ticks[i]);\n                var pos = [\n                    tickCoord,\n                    opt.labelOffset + opt.labelDirection * labelMargin\n                ];\n                var labelBeforeFormat = axis.scale.getLabel(ticks[i]);\n\n                var textEl = new graphic.Text({\n\n                    // Id for animation\n                    anid: 'label_' + ticks[i],\n\n                    style: {\n                        text: labels[i],\n                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,\n                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,\n                        textFont: itemTextStyleModel.getFont(),\n                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor\n                    },\n                    position: pos,\n                    rotation: labelLayout.rotation,\n                    silent: silent,\n                    z2: 10\n                });\n\n                // Pack data for mouse event\n                if (triggerEvent) {\n                    textEl.eventData = makeAxisEventDataBase(axisModel);\n                    textEl.eventData.targetType = 'axisLabel';\n                    textEl.eventData.value = labelBeforeFormat;\n                }\n\n\n                // FIXME\n                this._dumbGroup.add(textEl);\n                textEl.updateTransform();\n\n                textEls.push(textEl);\n                this.group.add(textEl);\n\n                textEl.decomposeTransform();\n            }\n\n            function isTwoLabelOverlapped(current, next) {\n                var firstRect = current && current.getBoundingRect().clone();\n                var nextRect = next && next.getBoundingRect().clone();\n                if (firstRect && nextRect) {\n                    firstRect.applyTransform(current.getLocalTransform());\n                    nextRect.applyTransform(next.getLocalTransform());\n                    return firstRect.intersect(nextRect);\n                }\n            }\n            if (axis.type !== 'category') {\n                // If min or max are user set, we need to check\n                // If the tick on min(max) are overlap on their neighbour tick\n                // If they are overlapped, we need to hide the min(max) tick label\n                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {\n                    var firstLabel = textEls[0];\n                    var nextLabel = textEls[1];\n                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n                        firstLabel.ignore = true;\n                    }\n                }\n                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {\n                    var lastLabel = textEls[textEls.length - 1];\n                    var prevLabel = textEls[textEls.length - 2];\n                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n                        lastLabel.ignore = true;\n                    }\n                }\n            }\n        },\n\n        /**\n         * @private\n         */\n        axisName: function () {\n            var opt = this.opt;\n            var axisModel = this.axisModel;\n            var name = retrieve(opt.axisName, axisModel.get('name'));\n\n            if (!name) {\n                return;\n            }\n\n            var nameLocation = axisModel.get('nameLocation');\n            var nameDirection = opt.nameDirection;\n            var textStyleModel = axisModel.getModel('nameTextStyle');\n            var gap = axisModel.get('nameGap') || 0;\n\n            var extent = this.axisModel.axis.getExtent();\n            var gapSignal = extent[0] > extent[1] ? -1 : 1;\n            var pos = [\n                nameLocation === 'start'\n                    ? extent[0] - gapSignal * gap\n                    : nameLocation === 'end'\n                    ? extent[1] + gapSignal * gap\n                    : (extent[0] + extent[1]) / 2, // 'middle'\n                // Reuse labelOffset.\n                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0\n            ];\n\n            var labelLayout;\n\n            var nameRotation = axisModel.get('nameRotate');\n            if (nameRotation != null) {\n                nameRotation = nameRotation * PI / 180; // To radian.\n            }\n\n            var axisNameAvailableWidth;\n\n            if (nameLocation === 'middle') {\n                labelLayout = innerTextLayout(\n                    opt,\n                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n                    nameDirection\n                );\n            }\n            else {\n                labelLayout = endTextLayout(\n                    opt, nameLocation, nameRotation || 0, extent\n                );\n\n                axisNameAvailableWidth = opt.axisNameAvailableWidth;\n                if (axisNameAvailableWidth != null) {\n                    axisNameAvailableWidth = Math.abs(\n                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)\n                    );\n                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n                }\n            }\n\n            var textFont = textStyleModel.getFont();\n\n            var truncateOpt = axisModel.get('nameTruncate', true) || {};\n            var ellipsis = truncateOpt.ellipsis;\n            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);\n            var truncatedText = (ellipsis != null && maxWidth != null)\n                ? formatUtil.truncateText(\n                    name, maxWidth, textFont, ellipsis,\n                    {minChar: 2, placeholder: truncateOpt.placeholder}\n                )\n                : name;\n\n            var tooltipOpt = axisModel.get('tooltip', true);\n\n            var mainType = axisModel.mainType;\n            var formatterParams = {\n                componentType: mainType,\n                name: name,\n                $vars: ['name']\n            };\n            formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n\n            var textEl = new graphic.Text({\n\n                // Id for animation\n                anid: 'name',\n\n                __fullText: name,\n                __truncatedText: truncatedText,\n\n                style: {\n                    text: truncatedText,\n                    textFont: textFont,\n                    fill: textStyleModel.getTextColor()\n                        || axisModel.get('axisLine.lineStyle.color'),\n                    textAlign: labelLayout.textAlign,\n                    textVerticalAlign: labelLayout.verticalAlign\n                },\n                position: pos,\n                rotation: labelLayout.rotation,\n                silent: isSilent(axisModel),\n                z2: 1,\n                tooltip: (tooltipOpt && tooltipOpt.show)\n                    ? zrUtil.extend({\n                        content: name,\n                        formatter: function () {\n                            return name;\n                        },\n                        formatterParams: formatterParams\n                    }, tooltipOpt)\n                    : null\n            });\n\n            if (axisModel.get('triggerEvent')) {\n                textEl.eventData = makeAxisEventDataBase(axisModel);\n                textEl.eventData.targetType = 'axisName';\n                textEl.eventData.name = name;\n            }\n\n            // FIXME\n            this._dumbGroup.add(textEl);\n            textEl.updateTransform();\n\n            this.group.add(textEl);\n\n            textEl.decomposeTransform();\n        }\n\n    };\n\n    /**\n     * @inner\n     */\n    function innerTextLayout(opt, textRotation, direction) {\n        var rotationDiff = remRadian(textRotation - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n\n        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.\n            verticalAlign = direction > 0 ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.\n            verticalAlign = direction > 0 ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n\n            if (rotationDiff > 0 && rotationDiff < PI) {\n                textAlign = direction > 0 ? 'right' : 'left';\n            }\n            else {\n                textAlign = direction > 0 ? 'left' : 'right';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function endTextLayout(opt, textPosition, textRotate, extent) {\n        var rotationDiff = remRadian(textRotate - opt.rotation);\n        var textAlign;\n        var verticalAlign;\n        var inverse = extent[0] > extent[1];\n        var onLeft = (textPosition === 'start' && !inverse)\n            || (textPosition !== 'start' && inverse);\n\n        if (isRadianAroundZero(rotationDiff - PI / 2)) {\n            verticalAlign = onLeft ? 'bottom' : 'top';\n            textAlign = 'center';\n        }\n        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n            verticalAlign = onLeft ? 'top' : 'bottom';\n            textAlign = 'center';\n        }\n        else {\n            verticalAlign = 'middle';\n            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n                textAlign = onLeft ? 'left' : 'right';\n            }\n            else {\n                textAlign = onLeft ? 'right' : 'left';\n            }\n        }\n\n        return {\n            rotation: rotationDiff,\n            textAlign: textAlign,\n            verticalAlign: verticalAlign\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function isSilent(axisModel) {\n        var tooltipOpt = axisModel.get('tooltip');\n        return axisModel.get('silent')\n            // Consider mouse cursor, add these restrictions.\n            || !(\n                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)\n            );\n    }\n\n    /**\n     * @static\n     */\n    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {\n        var rawTick;\n        var scale = axis.scale;\n        return scale.type === 'ordinal'\n            && (\n                typeof interval === 'function'\n                    ? (\n                        rawTick = scale.getTicks()[i],\n                        !interval(rawTick, scale.getLabel(rawTick))\n                    )\n                    : i % (interval + 1)\n            );\n    };\n\n    /**\n     * @static\n     */\n    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {\n        var interval = model.get('interval');\n        if (interval == null || interval == 'auto') {\n            interval = labelInterval;\n        }\n        return interval;\n    };\n\n    module.exports = AxisBuilder;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/AxisBuilder.js\n// module id = 560\n// module chunks = 16","// FIXME Better way to pack data in graphic element\n\n\n    require('./tooltip/TooltipModel');\n\n    require('./tooltip/TooltipView');\n\n    // Show tip action\n    /**\n     * @action\n     * @property {string} type\n     * @property {number} seriesIndex\n     * @property {number} dataIndex\n     * @property {number} [x]\n     * @property {number} [y]\n     */\n    require('../echarts').registerAction(\n        {\n            type: 'showTip',\n            event: 'showTip',\n            update: 'none'\n        },\n        // noop\n        function () {}\n    );\n    // Hide tip action\n    require('../echarts').registerAction(\n        {\n            type: 'hideTip',\n            event: 'hideTip',\n            update: 'none'\n        },\n        // noop\n        function () {}\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip.js\n// module id = 561\n// module chunks = 16","\n\n    require('../../echarts').extendComponentModel({\n\n        type: 'tooltip',\n\n        defaultOption: {\n            zlevel: 0,\n\n            z: 8,\n\n            show: true,\n\n            // tooltip主体内容\n            showContent: true,\n\n            // 触发类型，默认数据触发，见下图，可选为：'item' ¦ 'axis'\n            trigger: 'item',\n\n            // 触发条件，支持 'click' | 'mousemove' | 'none'\n            triggerOn: 'mousemove',\n\n            // 是否永远显示 content\n            alwaysShowContent: false,\n\n            // 位置 {Array} | {Function}\n            // position: null\n\n            // 内容格式器：{string}（Template） ¦ {Function}\n            // formatter: null\n\n            showDelay: 0,\n\n            // 隐藏延迟，单位ms\n            hideDelay: 100,\n\n            // 动画变换时间，单位s\n            transitionDuration: 0.4,\n\n            enterable: false,\n\n            // 提示背景颜色，默认为透明度为0.7的黑色\n            backgroundColor: 'rgba(50,50,50,0.7)',\n\n            // 提示边框颜色\n            borderColor: '#333',\n\n            // 提示边框圆角，单位px，默认为4\n            borderRadius: 4,\n\n            // 提示边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 提示内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // Extra css text\n            extraCssText: '',\n\n            // 坐标轴指示器，坐标轴触发有效\n            axisPointer: {\n                // 默认为直线\n                // 可选为：'line' | 'shadow' | 'cross'\n                type: 'line',\n\n                // type 为 line 的时候有效，指定 tooltip line 所在的轴，可选\n                // 可选 'x' | 'y' | 'angle' | 'radius' | 'auto'\n                // 默认 'auto'，会选择类型为 cateogry 的轴，对于双数值轴，笛卡尔坐标系会默认选择 x 轴\n                // 极坐标系会默认选择 angle 轴\n                axis: 'auto',\n\n                animation: true,\n                animationDurationUpdate: 200,\n                animationEasingUpdate: 'exponentialOut',\n\n                // 直线指示器样式设置\n                lineStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'solid'\n                },\n\n                crossStyle: {\n                    color: '#555',\n                    width: 1,\n                    type: 'dashed',\n\n                    // TODO formatter\n                    textStyle: {}\n                },\n\n                // 阴影指示器样式设置\n                shadowStyle: {\n                    color: 'rgba(150,150,150,0.3)'\n                }\n            },\n            textStyle: {\n                color: '#fff',\n                fontSize: 14\n            }\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipModel.js\n// module id = 562\n// module chunks = 16","\n\n    var TooltipContent = require('./TooltipContent');\n    var graphic = require('../../util/graphic');\n    var zrUtil = require('zrender/lib/core/util');\n    var formatUtil = require('../../util/format');\n    var numberUtil = require('../../util/number');\n    var modelUtil = require('../../util/model');\n    var parsePercent = numberUtil.parsePercent;\n    var env = require('zrender/lib/core/env');\n    var Model = require('../../model/Model');\n\n    function dataEqual(a, b) {\n        if (!a || !b) {\n            return false;\n        }\n        var round = numberUtil.round;\n        return round(a[0]) === round(b[0])\n            && round(a[1]) === round(b[1]);\n    }\n    /**\n     * @inner\n     */\n    function makeLineShape(x1, y1, x2, y2) {\n        return {\n            x1: x1,\n            y1: y1,\n            x2: x2,\n            y2: y2\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeRectShape(x, y, width, height) {\n        return {\n            x: x,\n            y: y,\n            width: width,\n            height: height\n        };\n    }\n\n    /**\n     * @inner\n     */\n    function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {\n        return {\n            cx: cx,\n            cy: cy,\n            r0: r0,\n            r: r,\n            startAngle: startAngle,\n            endAngle: endAngle,\n            clockwise: true\n        };\n    }\n\n    function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {\n        var width = el.clientWidth;\n        var height = el.clientHeight;\n        var gap = 20;\n\n        if (x + width + gap > viewWidth) {\n            x -= width + gap;\n        }\n        else {\n            x += gap;\n        }\n        if (y + height + gap > viewHeight) {\n            y -= height + gap;\n        }\n        else {\n            y += gap;\n        }\n        return [x, y];\n    }\n\n    function calcTooltipPosition(position, rect, dom) {\n        var domWidth = dom.clientWidth;\n        var domHeight = dom.clientHeight;\n        var gap = 5;\n        var x = 0;\n        var y = 0;\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n        switch (position) {\n            case 'inside':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'top':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y - domHeight - gap;\n                break;\n            case 'bottom':\n                x = rect.x + rectWidth / 2 - domWidth / 2;\n                y = rect.y + rectHeight + gap;\n                break;\n            case 'left':\n                x = rect.x - domWidth - gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n                break;\n            case 'right':\n                x = rect.x + rectWidth + gap;\n                y = rect.y + rectHeight / 2 - domHeight / 2;\n        }\n        return [x, y];\n    }\n\n    /**\n     * @param  {string|Function|Array.<number>} positionExpr\n     * @param  {number} x Mouse x\n     * @param  {number} y Mouse y\n     * @param  {module:echarts/component/tooltip/TooltipContent} content\n     * @param  {Object|<Array.<Object>} params\n     * @param  {module:zrender/Element} el target element\n     * @param  {module:echarts/ExtensionAPI} api\n     * @return {Array.<number>}\n     */\n    function updatePosition(positionExpr, x, y, content, params, el, api) {\n        var viewWidth = api.getWidth();\n        var viewHeight = api.getHeight();\n\n        var rect = el && el.getBoundingRect().clone();\n        el && rect.applyTransform(el.transform);\n        if (typeof positionExpr === 'function') {\n            // Callback of position can be an array or a string specify the position\n            positionExpr = positionExpr([x, y], params, content.el, rect);\n        }\n\n        if (zrUtil.isArray(positionExpr)) {\n            x = parsePercent(positionExpr[0], viewWidth);\n            y = parsePercent(positionExpr[1], viewHeight);\n        }\n        // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n        else if (typeof positionExpr === 'string' && el) {\n            var pos = calcTooltipPosition(\n                positionExpr, rect, content.el\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n        else {\n            var pos = refixTooltipPosition(\n                x, y, content.el, viewWidth, viewHeight\n            );\n            x = pos[0];\n            y = pos[1];\n        }\n\n        content.moveTo(x, y);\n    }\n\n    function ifSeriesSupportAxisTrigger(seriesModel) {\n        var coordSys = seriesModel.coordinateSystem;\n        var trigger = seriesModel.get('tooltip.trigger', true);\n        // Ignore series use item tooltip trigger and series coordinate system is not cartesian or\n        return !(!coordSys\n            || (coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'singleAxis')\n            || trigger === 'item');\n    }\n\n    require('../../echarts').extendComponentView({\n\n        type: 'tooltip',\n\n        _axisPointers: {},\n\n        init: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var tooltipContent = new TooltipContent(api.getDom(), api);\n            this._tooltipContent = tooltipContent;\n\n            api.on('showTip', this._manuallyShowTip, this);\n            api.on('hideTip', this._manuallyHideTip, this);\n        },\n\n        render: function (tooltipModel, ecModel, api) {\n            if (env.node) {\n                return;\n            }\n\n            // Reset\n            this.group.removeAll();\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._axisPointers = {};\n\n            /**\n             * @private\n             * @type {module:echarts/component/tooltip/TooltipModel}\n             */\n            this._tooltipModel = tooltipModel;\n\n            /**\n             * @private\n             * @type {module:echarts/model/Global}\n             */\n            this._ecModel = ecModel;\n\n            /**\n             * @private\n             * @type {module:echarts/ExtensionAPI}\n             */\n            this._api = api;\n\n            /**\n             * @type {Object}\n             * @private\n             */\n            this._lastHover = {\n                // data\n                // payloadBatch\n            };\n\n            var tooltipContent = this._tooltipContent;\n            tooltipContent.update();\n            tooltipContent.enterable = tooltipModel.get('enterable');\n            this._alwaysShowContent = tooltipModel.get('alwaysShowContent');\n\n            /**\n             * @type {Object.<string, Array>}\n             */\n            this._seriesGroupByAxis = this._prepareAxisTriggerData(\n                tooltipModel, ecModel\n            );\n\n            var crossText = this._crossText;\n            if (crossText) {\n                this.group.add(crossText);\n            }\n\n            var triggerOn = tooltipModel.get('triggerOn');\n\n            // Try to keep the tooltip show when refreshing\n            if (this._lastX != null\n                && this._lastY != null\n                // When user is willing to control tooltip totally using API,\n                // self._manuallyShowTip({x, y}) might cause tooltip hide,\n                // which is not expected.\n                && triggerOn !== 'none'\n            ) {\n                var self = this;\n                clearTimeout(this._refreshUpdateTimeout);\n                this._refreshUpdateTimeout = setTimeout(function () {\n                    // Show tip next tick after other charts are rendered\n                    // In case highlight action has wrong result\n                    // FIXME\n                    self._manuallyShowTip({\n                        x: self._lastX,\n                        y: self._lastY\n                    });\n                });\n            }\n\n            var zr = this._api.getZr();\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            if (triggerOn === 'click') {\n                zr.on('click', this._tryShow, this);\n            }\n            else if (triggerOn === 'mousemove') {\n                zr.on('mousemove', this._mousemove, this);\n                zr.on('mouseout', this._hide, this);\n                zr.on('globalout', this._hide, this);\n            }\n            // else triggerOn is 'none', which enable user\n            // to control tooltip totally using API.\n        },\n\n        _mousemove: function (e) {\n            var showDelay = this._tooltipModel.get('showDelay');\n            var self = this;\n            clearTimeout(this._showTimeout);\n            if (showDelay > 0) {\n                this._showTimeout = setTimeout(function () {\n                    self._tryShow(e);\n                }, showDelay);\n            }\n            else {\n                this._tryShow(e);\n            }\n        },\n\n        /**\n         * Show tip manually by\n         * dispatchAction({\n         *     type: 'showTip',\n         *     x: 10,\n         *     y: 10\n         * });\n         * Or\n         * dispatchAction({\n         *      type: 'showTip',\n         *      seriesIndex: 0,\n         *      dataIndex or dataIndexInside or name\n         * });\n         *\n         *  TODO Batch\n         */\n        _manuallyShowTip: function (event) {\n            // From self\n            if (event.from === this.uid) {\n                return;\n            }\n\n            var ecModel = this._ecModel;\n            var seriesIndex = event.seriesIndex;\n            var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n            var api = this._api;\n\n            if (event.x == null || event.y == null) {\n                if (!seriesModel) {\n                    // Find the first series can use axis trigger\n                    ecModel.eachSeries(function (_series) {\n                        if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {\n                            seriesModel = _series;\n                        }\n                    });\n                }\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var dataIndex = modelUtil.queryDataIndex(data, event);\n\n                    if (dataIndex == null || zrUtil.isArray(dataIndex)) {\n                        return;\n                    }\n\n                    var el = data.getItemGraphicEl(dataIndex);\n                    var cx;\n                    var cy;\n                    // Try to get the point in coordinate system\n                    var coordSys = seriesModel.coordinateSystem;\n                    if (seriesModel.getTooltipPosition) {\n                        var point = seriesModel.getTooltipPosition(dataIndex) || [];\n                        cx = point[0];\n                        cy = point[1];\n                    }\n                    else if (coordSys && coordSys.dataToPoint) {\n                        var point = coordSys.dataToPoint(\n                            data.getValues(\n                                zrUtil.map(coordSys.dimensions, function (dim) {\n                                    return seriesModel.coordDimToDataDim(dim)[0];\n                                }), dataIndex, true\n                            )\n                        );\n                        cx = point && point[0];\n                        cy = point && point[1];\n                    }\n                    else if (el) {\n                        // Use graphic bounding rect\n                        var rect = el.getBoundingRect().clone();\n                        rect.applyTransform(el.transform);\n                        cx = rect.x + rect.width / 2;\n                        cy = rect.y + rect.height / 2;\n                    }\n\n                    if (cx != null && cy != null) {\n                        this._tryShow({\n                            offsetX: cx,\n                            offsetY: cy,\n                            position: event.position,\n                            target: el,\n                            event: {}\n                        });\n                    }\n                }\n            }\n            else {\n                var el = api.getZr().handler.findHover(event.x, event.y);\n                this._tryShow({\n                    offsetX: event.x,\n                    offsetY: event.y,\n                    position: event.position,\n                    target: el,\n                    event: {}\n                });\n            }\n        },\n\n        _manuallyHideTip: function (e) {\n            if (e.from === this.uid) {\n                return;\n            }\n\n            this._hide();\n        },\n\n        _prepareAxisTriggerData: function (tooltipModel, ecModel) {\n            // Prepare data for axis trigger\n            var seriesGroupByAxis = {};\n            ecModel.eachSeries(function (seriesModel) {\n                if (ifSeriesSupportAxisTrigger(seriesModel)) {\n                    var coordSys = seriesModel.coordinateSystem;\n                    var baseAxis;\n                    var key;\n\n                    // Only cartesian2d, polar and single support axis trigger\n                    if (coordSys.type === 'cartesian2d') {\n                        // FIXME `axisPointer.axis` is not baseAxis\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + baseAxis.index;\n                    }\n                    else if (coordSys.type === 'singleAxis') {\n                        baseAxis = coordSys.getAxis();\n                        key = baseAxis.dim + baseAxis.type;\n                    }\n                    else {\n                        baseAxis = coordSys.getBaseAxis();\n                        key = baseAxis.dim + coordSys.name;\n                    }\n\n                    seriesGroupByAxis[key] = seriesGroupByAxis[key] || {\n                        coordSys: [],\n                        series: []\n                    };\n                    seriesGroupByAxis[key].coordSys.push(coordSys);\n                    seriesGroupByAxis[key].series.push(seriesModel);\n                }\n            }, this);\n\n            return seriesGroupByAxis;\n        },\n\n        /**\n         * mousemove handler\n         * @param {Object} e\n         * @private\n         */\n        _tryShow: function (e) {\n            var el = e.target;\n            var tooltipModel = this._tooltipModel;\n            var globalTrigger = tooltipModel.get('trigger');\n            var ecModel = this._ecModel;\n            var api = this._api;\n\n            if (!tooltipModel) {\n                return;\n            }\n\n            // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n            this._lastX = e.offsetX;\n            this._lastY = e.offsetY;\n\n            // Always show item tooltip if mouse is on the element with dataIndex\n            if (el && el.dataIndex != null) {\n                // Use dataModel in element if possible\n                // Used when mouseover on a element like markPoint or edge\n                // In which case, the data is not main data in series.\n                var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);\n                var dataIndex = el.dataIndex;\n                var itemModel = dataModel.getData().getItemModel(dataIndex);\n                // Series or single data may use item trigger when global is axis trigger\n                if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n                else {\n                    // Reset ticket\n                    this._ticket = '';\n                    // If either single data or series use item trigger\n                    this._hideAxisPointer();\n                    // Reset last hover and dispatch downplay action\n                    this._resetLastHover();\n\n                    this._showItemTooltipContent(dataModel, dataIndex, el.dataType, e);\n                }\n\n                api.dispatchAction({\n                    type: 'showTip',\n                    from: this.uid,\n                    dataIndexInside: el.dataIndex,\n                    seriesIndex: el.seriesIndex\n                });\n            }\n            // Tooltip provided directly. Like legend\n            else if (el && el.tooltip) {\n                var tooltipOpt = el.tooltip;\n                if (typeof tooltipOpt === 'string') {\n                    var content = tooltipOpt;\n                    tooltipOpt = {\n                        content: content,\n                        // Fixed formatter\n                        formatter: content\n                    };\n                }\n                var subTooltipModel = new Model(tooltipOpt, tooltipModel);\n                var defaultHtml = subTooltipModel.get('content');\n                var asyncTicket = Math.random();\n                this._showTooltipContent(\n                    // TODO params\n                    subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {},\n                    asyncTicket, e.offsetX, e.offsetY, e.position, el, api\n                );\n            }\n            else {\n                if (globalTrigger === 'item') {\n                    this._hide();\n                }\n                else {\n                    // Try show axis tooltip\n                    this._showAxisTooltip(tooltipModel, ecModel, e);\n                }\n\n                // Action of cross pointer\n                // other pointer types will trigger action in _dispatchAndShowSeriesTooltipContent method\n                if (tooltipModel.get('axisPointer.type') === 'cross') {\n                    api.dispatchAction({\n                        type: 'showTip',\n                        from: this.uid,\n                        x: e.offsetX,\n                        y: e.offsetY\n                    });\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on axis\n         * @param {module:echarts/component/tooltip/TooltipModel} tooltipModel\n         * @param {module:echarts/model/Global} ecModel\n         * @param {Object} e\n         * @private\n         */\n        _showAxisTooltip: function (tooltipModel, ecModel, e) {\n            var axisPointerModel = tooltipModel.getModel('axisPointer');\n            var axisPointerType = axisPointerModel.get('type');\n\n            if (axisPointerType === 'cross') {\n                var el = e.target;\n                if (el && el.dataIndex != null) {\n                    var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);\n                    var dataIndex = el.dataIndex;\n                    this._showItemTooltipContent(seriesModel, dataIndex, el.dataType, e);\n                }\n            }\n\n            this._showAxisPointer();\n            var allNotShow = true;\n            zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {\n                // Try show the axis pointer\n                var allCoordSys = seriesCoordSysSameAxis.coordSys;\n                var coordSys = allCoordSys[0];\n\n                // If mouse position is not in the grid or polar\n                var point = [e.offsetX, e.offsetY];\n\n                if (!coordSys.containPoint(point)) {\n                    // Hide axis pointer\n                    this._hideAxisPointer(coordSys.name);\n                    return;\n                }\n\n                allNotShow = false;\n                // Make sure point is discrete on cateogry axis\n                var dimensions = coordSys.dimensions;\n                var value = coordSys.pointToData(point, true);\n                point = coordSys.dataToPoint(value);\n                var baseAxis = coordSys.getBaseAxis();\n                var axisType = axisPointerModel.get('axis');\n                if (axisType === 'auto') {\n                    axisType = baseAxis.dim;\n                }\n\n                var contentNotChange = false;\n                var lastHover = this._lastHover;\n                if (axisPointerType === 'cross') {\n                    // If hover data not changed\n                    // Possible when two axes are all category\n                    if (dataEqual(lastHover.data, value)) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value;\n                }\n                else {\n                    var valIndex = zrUtil.indexOf(dimensions, axisType);\n\n                    // If hover data not changed on the axis dimension\n                    if (lastHover.data === value[valIndex]) {\n                        contentNotChange = true;\n                    }\n                    lastHover.data = value[valIndex];\n                }\n\n                if (coordSys.type === 'cartesian2d' && !contentNotChange) {\n                    this._showCartesianPointer(\n                        axisPointerModel, coordSys, axisType, point\n                    );\n                }\n                else if (coordSys.type === 'polar' && !contentNotChange) {\n                    this._showPolarPointer(\n                        axisPointerModel, coordSys, axisType, point\n                    );\n                }\n                else if (coordSys.type === 'singleAxis' && !contentNotChange) {\n                    this._showSinglePointer(\n                        axisPointerModel, coordSys, axisType, point\n                    );\n                }\n\n                if (axisPointerType !== 'cross') {\n                    this._dispatchAndShowSeriesTooltipContent(\n                        coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange, e.position\n                    );\n                }\n            }, this);\n\n            if (!this._tooltipModel.get('show')) {\n                this._hideAxisPointer();\n            }\n\n            if (allNotShow) {\n                this._hide();\n            }\n        },\n\n        /**\n         * Show tooltip on axis of cartesian coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {module:echarts/coord/cartesian/Cartesian2D} cartesians\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         * @private\n         */\n        _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n            var baseAxis = cartesian.getBaseAxis();\n            var moveAnimation = axisPointerType !== 'cross'\n                && baseAxis.type === 'category'\n                && baseAxis.getBandWidth() > 20;\n\n            if (axisPointerType === 'cross') {\n                moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());\n                moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());\n\n                this._updateCrossText(cartesian, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');\n                var otherExtent = otherAxis.getGlobalExtent();\n\n                if (cartesian.type === 'cartesian2d') {\n                    (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(\n                        axisType, point, otherExtent\n                    );\n                }\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridLine(axisType, point, otherExtent) {\n                var targetShape = axisType === 'x'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                graphic.subPixelOptimizeLine({\n                    shape: targetShape,\n                    style: pointerEl.style\n                });\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function moveGridShadow(axisType, point, otherExtent) {\n                var axis = cartesian.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n                var span = otherExtent[1] - otherExtent[0];\n                var targetShape = axisType === 'x'\n                    ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span)\n                    : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);\n\n                var pointerEl = self._getPointerElement(\n                    cartesian, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _showSinglePointer: function (axisPointerModel, single, axisType, point) {\n            var self = this;\n            var axisPointerType = axisPointerModel.get('type');\n            var moveAnimation = axisPointerType !== 'cross' && single.getBaseAxis().type === 'category';\n            var rect = single.getRect();\n            var otherExtent = [rect.y, rect.y + rect.height];\n\n            moveSingleLine(axisType, point, otherExtent);\n\n            /**\n             * @inner\n             */\n            function moveSingleLine(axisType, point, otherExtent) {\n                var axis = single.getAxis();\n                var orient = axis.orient;\n\n                var targetShape = orient === 'horizontal'\n                    ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1])\n                    : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);\n\n                var pointerEl = self._getPointerElement(\n                    single, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n        },\n\n        /**\n         * Show tooltip on axis of polar coordinate\n         * @param {module:echarts/model/Model} axisPointerModel\n         * @param {Array.<module:echarts/coord/polar/Polar>} polar\n         * @param {string} axisType\n         * @param {Array.<number>} point\n         */\n        _showPolarPointer: function (axisPointerModel, polar, axisType, point) {\n            var self = this;\n\n            var axisPointerType = axisPointerModel.get('type');\n\n            var angleAxis = polar.getAngleAxis();\n            var radiusAxis = polar.getRadiusAxis();\n\n            var moveAnimation = axisPointerType !== 'cross'\n                && polar.getBaseAxis().type === 'category';\n\n            if (axisPointerType === 'cross') {\n                movePolarLine('angle', point, radiusAxis.getExtent());\n                movePolarLine('radius', point, angleAxis.getExtent());\n\n                this._updateCrossText(polar, point, axisPointerModel);\n            }\n            else {\n                var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');\n                var otherExtent = otherAxis.getExtent();\n\n                (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(\n                    axisType, point, otherExtent\n                );\n            }\n            /**\n             * @inner\n             */\n            function movePolarLine(axisType, point, otherExtent) {\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                if (axisType === 'angle') {\n                    var p1 = polar.coordToPoint([otherExtent[0], mouseCoord[1]]);\n                    var p2 = polar.coordToPoint([otherExtent[1], mouseCoord[1]]);\n                    targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);\n                }\n                else {\n                    targetShape = {\n                        cx: polar.cx,\n                        cy: polar.cy,\n                        r: mouseCoord[0]\n                    };\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n\n            /**\n             * @inner\n             */\n            function movePolarShadow(axisType, point, otherExtent) {\n                var axis = polar.getAxis(axisType);\n                var bandWidth = axis.getBandWidth();\n\n                var mouseCoord = polar.pointToCoord(point);\n\n                var targetShape;\n\n                var radian = Math.PI / 180;\n\n                if (axisType === 'angle') {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        otherExtent[0], otherExtent[1],\n                        // In ECharts y is negative if angle is positive\n                        (-mouseCoord[1] - bandWidth / 2) * radian,\n                        (-mouseCoord[1] + bandWidth / 2) * radian\n                    );\n                }\n                else {\n                    targetShape = makeSectorShape(\n                        polar.cx, polar.cy,\n                        mouseCoord[0] - bandWidth / 2,\n                        mouseCoord[0] + bandWidth / 2,\n                        0, Math.PI * 2\n                    );\n                }\n\n                var pointerEl = self._getPointerElement(\n                    polar, axisPointerModel, axisType, targetShape\n                );\n                moveAnimation\n                    ? graphic.updateProps(pointerEl, {\n                        shape: targetShape\n                    }, axisPointerModel)\n                    :  pointerEl.attr({\n                        shape: targetShape\n                    });\n            }\n        },\n\n        _updateCrossText: function (coordSys, point, axisPointerModel) {\n            var crossStyleModel = axisPointerModel.getModel('crossStyle');\n            var textStyleModel = crossStyleModel.getModel('textStyle');\n\n            var tooltipModel = this._tooltipModel;\n\n            var text = this._crossText;\n            if (!text) {\n                text = this._crossText = new graphic.Text({\n                    style: {\n                        textAlign: 'left',\n                        textVerticalAlign: 'bottom'\n                    }\n                });\n                this.group.add(text);\n            }\n\n            var value = coordSys.pointToData(point);\n\n            var dims = coordSys.dimensions;\n            value = zrUtil.map(value, function (val, idx) {\n                var axis = coordSys.getAxis(dims[idx]);\n                if (axis.type === 'category' || axis.type === 'time') {\n                    val = axis.scale.getLabel(val);\n                }\n                else {\n                    val = formatUtil.addCommas(\n                        val.toFixed(axis.getPixelPrecision())\n                    );\n                }\n                return val;\n            });\n\n            text.setStyle({\n                fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),\n                textFont: textStyleModel.getFont(),\n                text: value.join(', '),\n                x: point[0] + 5,\n                y: point[1] - 5\n            });\n            text.z = tooltipModel.get('z');\n            text.zlevel = tooltipModel.get('zlevel');\n        },\n\n        _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {\n            var tooltipModel = this._tooltipModel;\n            var z = tooltipModel.get('z');\n            var zlevel = tooltipModel.get('zlevel');\n            var axisPointers = this._axisPointers;\n            var coordSysName = coordSys.name;\n            axisPointers[coordSysName] = axisPointers[coordSysName] || {};\n            if (axisPointers[coordSysName][axisType]) {\n                return axisPointers[coordSysName][axisType];\n            }\n\n            // Create if not exists\n            var pointerType = pointerModel.get('type');\n            var styleModel = pointerModel.getModel(pointerType + 'Style');\n            var isShadow = pointerType === 'shadow';\n            var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();\n\n            var elementType = coordSys.type === 'polar'\n                ? (isShadow ? 'Sector' : (axisType === 'radius' ? 'Circle' : 'Line'))\n                : (isShadow ? 'Rect' : 'Line');\n\n            isShadow ? (style.stroke = null) : (style.fill = null);\n\n            var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({\n                style: style,\n                z: z,\n                zlevel: zlevel,\n                silent: true,\n                shape: initShape\n            });\n\n            this.group.add(el);\n            return el;\n        },\n\n        /**\n         * Dispatch actions and show tooltip on series\n         * @param {Array.<module:echarts/model/Series>} seriesList\n         * @param {Array.<number>} point\n         * @param {Array.<number>} value\n         * @param {boolean} contentNotChange\n         * @param {Array.<number>|string|Function} [positionExpr]\n         */\n        _dispatchAndShowSeriesTooltipContent: function (\n            coordSys, seriesList, point, value, contentNotChange, positionExpr\n        ) {\n\n            var rootTooltipModel = this._tooltipModel;\n\n            var baseAxis = coordSys.getBaseAxis();\n            var baseDimIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;\n\n            var payloadBatch = zrUtil.map(seriesList, function (series) {\n                return {\n                    seriesIndex: series.seriesIndex,\n                    dataIndexInside: series.getAxisTooltipDataIndex\n                        ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis)\n                        : series.getData().indexOfNearest(\n                            series.coordDimToDataDim(baseAxis.dim)[0],\n                            value[baseDimIndex],\n                            // Add a threshold to avoid find the wrong dataIndex when data length is not same\n                            false, baseAxis.type === 'category' ? 0.5 : null\n                        )\n                };\n            });\n\n            var lastHover = this._lastHover;\n            var api = this._api;\n            // Dispatch downplay action\n            if (lastHover.payloadBatch && !contentNotChange) {\n                api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Dispatch highlight action\n            if (!contentNotChange) {\n                api.dispatchAction({\n                    type: 'highlight',\n                    batch: payloadBatch\n                });\n                lastHover.payloadBatch = payloadBatch;\n            }\n            // Dispatch showTip action\n            api.dispatchAction({\n                type: 'showTip',\n                dataIndexInside: payloadBatch[0].dataIndexInside,\n                seriesIndex: payloadBatch[0].seriesIndex,\n                from: this.uid\n            });\n\n            if (baseAxis && rootTooltipModel.get('showContent') && rootTooltipModel.get('show')) {\n                var paramsList = zrUtil.map(seriesList, function (series, index) {\n                    return series.getDataParams(payloadBatch[index].dataIndexInside);\n                });\n\n                if (!contentNotChange) {\n                    // Update html content\n                    var firstDataIndex = payloadBatch[0].dataIndexInside;\n\n                    // Default tooltip content\n                    // FIXME\n                    // (1) shold be the first data which has name?\n                    // (2) themeRiver, firstDataIndex is array, and first line is unnecessary.\n                    var firstLine = baseAxis.type === 'time'\n                        ? baseAxis.scale.getLabel(value[baseDimIndex])\n                        : seriesList[0].getData().getName(firstDataIndex);\n                    var defaultHtml = (firstLine ? firstLine + '<br />' : '')\n                        + zrUtil.map(seriesList, function (series, index) {\n                            return series.formatTooltip(payloadBatch[index].dataIndexInside, true);\n                        }).join('<br />');\n\n                    var asyncTicket = 'axis_' + coordSys.name + '_' + firstDataIndex;\n\n                    this._showTooltipContent(\n                        rootTooltipModel, defaultHtml, paramsList, asyncTicket,\n                        point[0], point[1], positionExpr, null, api\n                    );\n                }\n                else {\n                    updatePosition(\n                        positionExpr || rootTooltipModel.get('position'), point[0], point[1],\n                        this._tooltipContent, paramsList, null, api\n                    );\n                }\n            }\n        },\n\n        /**\n         * Show tooltip on item\n         * @param {module:echarts/model/Series} seriesModel\n         * @param {number} dataIndex\n         * @param {string} dataType\n         * @param {Object} e\n         */\n        _showItemTooltipContent: function (seriesModel, dataIndex, dataType, e) {\n            // FIXME Graph data\n            var api = this._api;\n            var data = seriesModel.getData(dataType);\n            var itemModel = data.getItemModel(dataIndex);\n\n            var tooltipOpt = itemModel.get('tooltip', true);\n            if (typeof tooltipOpt === 'string') {\n                // In each data item tooltip can be simply write:\n                // {\n                //  value: 10,\n                //  tooltip: 'Something you need to know'\n                // }\n                var tooltipContent = tooltipOpt;\n                tooltipOpt = {\n                    formatter: tooltipContent\n                };\n            }\n            var rootTooltipModel = this._tooltipModel;\n            var seriesTooltipModel = seriesModel.getModel(\n                'tooltip', rootTooltipModel\n            );\n            var tooltipModel = new Model(tooltipOpt, seriesTooltipModel, seriesTooltipModel.ecModel);\n\n            var params = seriesModel.getDataParams(dataIndex, dataType);\n            var defaultHtml = seriesModel.formatTooltip(dataIndex, false, dataType);\n\n            var asyncTicket = 'item_' + seriesModel.name + '_' + dataIndex;\n\n            this._showTooltipContent(\n                tooltipModel, defaultHtml, params, asyncTicket,\n                e.offsetX, e.offsetY, e.position, e.target, api\n            );\n        },\n\n        _showTooltipContent: function (\n            tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, target, api\n        ) {\n            // Reset ticket\n            this._ticket = '';\n\n            if (tooltipModel.get('showContent') && tooltipModel.get('show')) {\n                var tooltipContent = this._tooltipContent;\n\n                var formatter = tooltipModel.get('formatter');\n                positionExpr = positionExpr || tooltipModel.get('position');\n                var html = defaultHtml;\n\n                if (formatter) {\n                    if (typeof formatter === 'string') {\n                        html = formatUtil.formatTpl(formatter, params);\n                    }\n                    else if (typeof formatter === 'function') {\n                        var self = this;\n                        var ticket = asyncTicket;\n                        var callback = function (cbTicket, html) {\n                            if (cbTicket === self._ticket) {\n                                tooltipContent.setContent(html);\n\n                                updatePosition(\n                                    positionExpr, x, y,\n                                    tooltipContent, params, target, api\n                                );\n                            }\n                        };\n                        self._ticket = ticket;\n                        html = formatter(params, ticket, callback);\n                    }\n                }\n\n                tooltipContent.show(tooltipModel);\n                tooltipContent.setContent(html);\n\n                updatePosition(\n                    positionExpr, x, y,\n                    tooltipContent, params, target, api\n                );\n            }\n        },\n\n        /**\n         * Show axis pointer\n         * @param {string} [coordSysName]\n         */\n        _showAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.show();\n                });\n            }\n            else {\n                this.group.eachChild(function (child) {\n                    child.show();\n                });\n                this.group.show();\n            }\n        },\n\n        _resetLastHover: function () {\n            var lastHover = this._lastHover;\n            if (lastHover.payloadBatch) {\n                this._api.dispatchAction({\n                    type: 'downplay',\n                    batch: lastHover.payloadBatch\n                });\n            }\n            // Reset lastHover\n            this._lastHover = {};\n        },\n        /**\n         * Hide axis pointer\n         * @param {string} [coordSysName]\n         */\n        _hideAxisPointer: function (coordSysName) {\n            if (coordSysName) {\n                var axisPointers = this._axisPointers[coordSysName];\n                axisPointers && zrUtil.each(axisPointers, function (el) {\n                    el.hide();\n                });\n            }\n            else {\n                if (this.group.children().length) {\n                    this.group.hide();\n                }\n            }\n        },\n\n        _hide: function () {\n            clearTimeout(this._showTimeout);\n\n            this._hideAxisPointer();\n            this._resetLastHover();\n            if (!this._alwaysShowContent) {\n                this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n            }\n\n            this._api.dispatchAction({\n                type: 'hideTip',\n                from: this.uid\n            });\n\n            this._lastX = this._lastY = null;\n        },\n\n        dispose: function (ecModel, api) {\n            if (env.node) {\n                return;\n            }\n            var zr = api.getZr();\n            this._tooltipContent.hide();\n\n            zr.off('click', this._tryShow);\n            zr.off('mousemove', this._mousemove);\n            zr.off('mouseout', this._hide);\n            zr.off('globalout', this._hide);\n\n            api.off('showTip', this._manuallyShowTip);\n            api.off('hideTip', this._manuallyHideTip);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipView.js\n// module id = 563\n// module chunks = 16","/**\n * @module echarts/component/tooltip/TooltipContent\n */\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var zrColor = require('zrender/lib/tool/color');\n    var eventUtil = require('zrender/lib/core/event');\n    var formatUtil = require('../../util/format');\n    var each = zrUtil.each;\n    var toCamelCase = formatUtil.toCamelCase;\n    var env = require('zrender/lib/core/env');\n\n    var vendors = ['', '-webkit-', '-moz-', '-o-'];\n\n    var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';\n\n    /**\n     * @param {number} duration\n     * @return {string}\n     * @inner\n     */\n    function assembleTransition(duration) {\n        var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';\n        var transitionText = 'left ' + duration + 's ' + transitionCurve + ','\n                            + 'top ' + duration + 's ' + transitionCurve;\n        return zrUtil.map(vendors, function (vendorPrefix) {\n            return vendorPrefix + 'transition:' + transitionText;\n        }).join(';');\n    }\n\n    /**\n     * @param {Object} textStyle\n     * @return {string}\n     * @inner\n     */\n    function assembleFont(textStyleModel) {\n        var cssText = [];\n\n        var fontSize = textStyleModel.get('fontSize');\n        var color = textStyleModel.getTextColor();\n\n        color && cssText.push('color:' + color);\n\n        cssText.push('font:' + textStyleModel.getFont());\n\n        fontSize &&\n            cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');\n\n        each(['decoration', 'align'], function (name) {\n            var val = textStyleModel.get(name);\n            val && cssText.push('text-' + name + ':' + val);\n        });\n\n        return cssText.join(';');\n    }\n\n    /**\n     * @param {Object} tooltipModel\n     * @return {string}\n     * @inner\n     */\n    function assembleCssText(tooltipModel) {\n\n        tooltipModel = tooltipModel;\n\n        var cssText = [];\n\n        var transitionDuration = tooltipModel.get('transitionDuration');\n        var backgroundColor = tooltipModel.get('backgroundColor');\n        var textStyleModel = tooltipModel.getModel('textStyle');\n        var padding = tooltipModel.get('padding');\n\n        // Animation transition\n        transitionDuration &&\n            cssText.push(assembleTransition(transitionDuration));\n\n        if (backgroundColor) {\n            if (env.canvasSupported) {\n                cssText.push('background-Color:' + backgroundColor);\n            }\n            else {\n                // for ie\n                cssText.push(\n                    'background-Color:#' + zrColor.toHex(backgroundColor)\n                );\n                cssText.push('filter:alpha(opacity=70)');\n            }\n        }\n\n        // Border style\n        each(['width', 'color', 'radius'], function (name) {\n            var borderName = 'border-' + name;\n            var camelCase = toCamelCase(borderName);\n            var val = tooltipModel.get(camelCase);\n            val != null &&\n                cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n        });\n\n        // Text style\n        cssText.push(assembleFont(textStyleModel));\n\n        // Padding\n        if (padding != null) {\n            cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');\n        }\n\n        return cssText.join(';') + ';';\n    }\n\n    /**\n     * @alias module:echarts/component/tooltip/TooltipContent\n     * @constructor\n     */\n    function TooltipContent(container, api) {\n        var el = document.createElement('div');\n        var zr = api.getZr();\n\n        this.el = el;\n\n        this._x = api.getWidth() / 2;\n        this._y = api.getHeight() / 2;\n\n        container.appendChild(el);\n\n        this._container = container;\n\n        this._show = false;\n\n        /**\n         * @private\n         */\n        this._hideTimeout;\n\n        var self = this;\n        el.onmouseenter = function () {\n            // clear the timeout in hideLater and keep showing tooltip\n            if (self.enterable) {\n                clearTimeout(self._hideTimeout);\n                self._show = true;\n            }\n            self._inContent = true;\n        };\n        el.onmousemove = function (e) {\n            e = e || window.event;\n            if (!self.enterable) {\n                // Try trigger zrender event to avoid mouse\n                // in and out shape too frequently\n                var handler = zr.handler;\n                eventUtil.normalizeEvent(container, e, true);\n                handler.dispatch('mousemove', e);\n            }\n        };\n        el.onmouseleave = function () {\n            if (self.enterable) {\n                if (self._show) {\n                    self.hideLater(self._hideDelay);\n                }\n            }\n            self._inContent = false;\n        };\n\n        compromiseMobile(el, container);\n    }\n\n    function compromiseMobile(tooltipContentEl, container) {\n        // Prevent default behavior on mobile. For example,\n        // default pinch gesture will cause browser zoom.\n        // We do not preventing event on tooltip content el,\n        // because user may need customization in tooltip el.\n        eventUtil.addEventListener(container, 'touchstart', preventDefault);\n        eventUtil.addEventListener(container, 'touchmove', preventDefault);\n        eventUtil.addEventListener(container, 'touchend', preventDefault);\n\n        function preventDefault(e) {\n            if (!contains(e.target)) {\n                e.preventDefault();\n            }\n        }\n\n        function contains(targetEl) {\n            while (targetEl && targetEl !== container) {\n                if (targetEl === tooltipContentEl) {\n                    return true;\n                }\n                targetEl = targetEl.parentNode;\n            }\n        }\n    }\n\n    TooltipContent.prototype = {\n\n        constructor: TooltipContent,\n\n        enterable: true,\n\n        /**\n         * Update when tooltip is rendered\n         */\n        update: function () {\n            var container = this._container;\n            var stl = container.currentStyle\n                || document.defaultView.getComputedStyle(container);\n            var domStyle = container.style;\n            if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {\n                domStyle.position = 'relative';\n            }\n            // Hide the tooltip\n            // PENDING\n            // this.hide();\n        },\n\n        show: function (tooltipModel) {\n            clearTimeout(this._hideTimeout);\n            var el = this.el;\n\n            el.style.cssText = gCssText + assembleCssText(tooltipModel)\n                // http://stackoverflow.com/questions/21125587/css3-transition-not-working-in-chrome-anymore\n                + ';left:' + this._x + 'px;top:' + this._y + 'px;'\n                + (tooltipModel.get('extraCssText') || '');\n\n            el.style.display = el.innerHTML ?  'block' : 'none';\n\n            this._show = true;\n        },\n\n        setContent: function (content) {\n            var el = this.el;\n            el.innerHTML = content;\n            el.style.display = content ? 'block' : 'none';\n        },\n\n        moveTo: function (x, y) {\n            var style = this.el.style;\n            style.left = x + 'px';\n            style.top = y + 'px';\n\n            this._x = x;\n            this._y = y;\n        },\n\n        hide: function () {\n            this.el.style.display = 'none';\n            this._show = false;\n        },\n\n        // showLater: function ()\n\n        hideLater: function (time) {\n            if (this._show && !(this._inContent && this.enterable)) {\n                if (time) {\n                    this._hideDelay = time;\n                    // Set show false to avoid invoke hideLater mutiple times\n                    this._show = false;\n                    this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);\n                }\n                else {\n                    this.hide();\n                }\n            }\n        },\n\n        isShow: function () {\n            return this._show;\n        }\n    };\n\n    module.exports = TooltipContent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/tooltip/TooltipContent.js\n// module id = 564\n// module chunks = 16","'use strict';\n\n\n    var echarts = require('../echarts');\n    var graphic = require('../util/graphic');\n    var layout = require('../util/layout');\n\n    // Model\n    echarts.extendComponentModel({\n\n        type: 'title',\n\n        layoutMode: {type: 'box', ignoreSize: true},\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 6,\n            show: true,\n\n            text: '',\n            // 超链接跳转\n            // link: null,\n            // 仅支持self | blank\n            target: 'blank',\n            subtext: '',\n\n            // 超链接跳转\n            // sublink: null,\n            // 仅支持self | blank\n            subtarget: 'blank',\n\n            // 'center' ¦ 'left' ¦ 'right'\n            // ¦ {number}（x坐标，单位px）\n            left: 0,\n            // 'top' ¦ 'bottom' ¦ 'center'\n            // ¦ {number}（y坐标，单位px）\n            top: 0,\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right' | 'center'\n            // 默认根据 left 的位置判断是左对齐还是右对齐\n            // textAlign: null\n            //\n            // 垂直对齐\n            // 'auto' | 'top' | 'bottom' | 'middle'\n            // 默认根据 top 位置判断是上对齐还是下对齐\n            // textBaseline: null\n\n            backgroundColor: 'rgba(0,0,0,0)',\n\n            // 标题边框颜色\n            borderColor: '#ccc',\n\n            // 标题边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n\n            // 标题内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n\n            // 主副标题纵向间隔，单位px，默认为10，\n            itemGap: 10,\n            textStyle: {\n                fontSize: 18,\n                fontWeight: 'bolder',\n                color: '#333'\n            },\n            subtextStyle: {\n                color: '#aaa'\n            }\n        }\n    });\n\n    // View\n    echarts.extendComponentView({\n\n        type: 'title',\n\n        render: function (titleModel, ecModel, api) {\n            this.group.removeAll();\n\n            if (!titleModel.get('show')) {\n                return;\n            }\n\n            var group = this.group;\n\n            var textStyleModel = titleModel.getModel('textStyle');\n            var subtextStyleModel = titleModel.getModel('subtextStyle');\n\n            var textAlign = titleModel.get('textAlign');\n            var textBaseline = titleModel.get('textBaseline');\n\n            var textEl = new graphic.Text({\n                style: {\n                    text: titleModel.get('text'),\n                    textFont: textStyleModel.getFont(),\n                    fill: textStyleModel.getTextColor()\n                },\n                z2: 10\n            });\n\n            var textRect = textEl.getBoundingRect();\n\n            var subText = titleModel.get('subtext');\n            var subTextEl = new graphic.Text({\n                style: {\n                    text: subText,\n                    textFont: subtextStyleModel.getFont(),\n                    fill: subtextStyleModel.getTextColor(),\n                    y: textRect.height + titleModel.get('itemGap'),\n                    textBaseline: 'top'\n                },\n                z2: 10\n            });\n\n            var link = titleModel.get('link');\n            var sublink = titleModel.get('sublink');\n\n            textEl.silent = !link;\n            subTextEl.silent = !sublink;\n\n            if (link) {\n                textEl.on('click', function () {\n                    window.open(link, '_' + titleModel.get('target'));\n                });\n            }\n            if (sublink) {\n                subTextEl.on('click', function () {\n                    window.open(sublink, '_' + titleModel.get('subtarget'));\n                });\n            }\n\n            group.add(textEl);\n            subText && group.add(subTextEl);\n            // If no subText, but add subTextEl, there will be an empty line.\n\n            var groupRect = group.getBoundingRect();\n            var layoutOption = titleModel.getBoxLayoutParams();\n            layoutOption.width = groupRect.width;\n            layoutOption.height = groupRect.height;\n            var layoutRect = layout.getLayoutRect(\n                layoutOption, {\n                    width: api.getWidth(),\n                    height: api.getHeight()\n                }, titleModel.get('padding')\n            );\n            // Adjust text align based on position\n            if (!textAlign) {\n                // Align left if title is on the left. center and right is same\n                textAlign = titleModel.get('left') || titleModel.get('right');\n                if (textAlign === 'middle') {\n                    textAlign = 'center';\n                }\n                // Adjust layout by text align\n                if (textAlign === 'right') {\n                    layoutRect.x += layoutRect.width;\n                }\n                else if (textAlign === 'center') {\n                    layoutRect.x += layoutRect.width / 2;\n                }\n            }\n            if (!textBaseline) {\n                textBaseline = titleModel.get('top') || titleModel.get('bottom');\n                if (textBaseline === 'center') {\n                    textBaseline = 'middle';\n                }\n                if (textBaseline === 'bottom') {\n                    layoutRect.y += layoutRect.height;\n                }\n                else if (textBaseline === 'middle') {\n                    layoutRect.y += layoutRect.height / 2;\n                }\n\n                textBaseline = textBaseline || 'top';\n            }\n\n            group.attr('position', [layoutRect.x, layoutRect.y]);\n            var alignStyle = {\n                textAlign: textAlign,\n                textVerticalAlign: textBaseline\n            };\n            textEl.setStyle(alignStyle);\n            subTextEl.setStyle(alignStyle);\n\n            // Render background\n            // Get groupRect again because textAlign has been changed\n            groupRect = group.getBoundingRect();\n            var padding = layoutRect.margin;\n            var style = titleModel.getItemStyle(['color', 'opacity']);\n            style.fill = titleModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: groupRect.x - padding[3],\n                    y: groupRect.y - padding[0],\n                    width: groupRect.width + padding[1] + padding[3],\n                    height: groupRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/title.js\n// module id = 565\n// module chunks = 16","/**\n * Legend component entry file8\n */\n\n\n    require('./legend/LegendModel');\n    require('./legend/legendAction');\n    require('./legend/LegendView');\n\n    var echarts = require('../echarts');\n    // Series Filter\n    echarts.registerProcessor(require('./legend/legendFilter'));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend.js\n// module id = 566\n// module chunks = 16","'use strict';\n\n\n    var zrUtil = require('zrender/lib/core/util');\n    var Model = require('../../model/Model');\n\n    var LegendModel = require('../../echarts').extendComponentModel({\n\n        type: 'legend',\n\n        dependencies: ['series'],\n\n        layoutMode: {\n            type: 'box',\n            ignoreSize: true\n        },\n\n        init: function (option, parentModel, ecModel) {\n            this.mergeDefaultAndTheme(option, ecModel);\n\n            option.selected = option.selected || {};\n        },\n\n        mergeOption: function (option) {\n            LegendModel.superCall(this, 'mergeOption', option);\n        },\n\n        optionUpdated: function () {\n            this._updateData(this.ecModel);\n\n            var legendData = this._data;\n\n            // If selectedMode is single, try to select one\n            if (legendData[0] && this.get('selectedMode') === 'single') {\n                var hasSelected = false;\n                // If has any selected in option.selected\n                for (var i = 0; i < legendData.length; i++) {\n                    var name = legendData[i].get('name');\n                    if (this.isSelected(name)) {\n                        // Force to unselect others\n                        this.select(name);\n                        hasSelected = true;\n                        break;\n                    }\n                }\n                // Try select the first if selectedMode is single\n                !hasSelected && this.select(legendData[0].get('name'));\n            }\n        },\n\n        _updateData: function (ecModel) {\n            var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {\n                // Can be string or number\n                if (typeof dataItem === 'string' || typeof dataItem === 'number') {\n                    dataItem = {\n                        name: dataItem\n                    };\n                }\n                return new Model(dataItem, this, this.ecModel);\n            }, this);\n            this._data = legendData;\n\n            var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {\n                return series.name;\n            });\n            ecModel.eachSeries(function (seriesModel) {\n                if (seriesModel.legendDataProvider) {\n                    var data = seriesModel.legendDataProvider();\n                    availableNames = availableNames.concat(data.mapArray(data.getName));\n                }\n            });\n            /**\n             * @type {Array.<string>}\n             * @private\n             */\n            this._availableNames = availableNames;\n        },\n\n        /**\n         * @return {Array.<module:echarts/model/Model>}\n         */\n        getData: function () {\n            return this._data;\n        },\n\n        /**\n         * @param {string} name\n         */\n        select: function (name) {\n            var selected = this.option.selected;\n            var selectedMode = this.get('selectedMode');\n            if (selectedMode === 'single') {\n                var data = this._data;\n                zrUtil.each(data, function (dataItem) {\n                    selected[dataItem.get('name')] = false;\n                });\n            }\n            selected[name] = true;\n        },\n\n        /**\n         * @param {string} name\n         */\n        unSelect: function (name) {\n            if (this.get('selectedMode') !== 'single') {\n                this.option.selected[name] = false;\n            }\n        },\n\n        /**\n         * @param {string} name\n         */\n        toggleSelected: function (name) {\n            var selected = this.option.selected;\n            // Default is true\n            if (!selected.hasOwnProperty(name)) {\n                selected[name] = true;\n            }\n            this[selected[name] ? 'unSelect' : 'select'](name);\n        },\n\n        /**\n         * @param {string} name\n         */\n        isSelected: function (name) {\n            var selected = this.option.selected;\n            return !(selected.hasOwnProperty(name) && !selected[name])\n                && zrUtil.indexOf(this._availableNames, name) >= 0;\n        },\n\n        defaultOption: {\n            // 一级层叠\n            zlevel: 0,\n            // 二级层叠\n            z: 4,\n            show: true,\n\n            // 布局方式，默认为水平布局，可选为：\n            // 'horizontal' | 'vertical'\n            orient: 'horizontal',\n\n            left: 'center',\n            // right: 'center',\n\n            top: 'top',\n            // bottom: 'top',\n\n            // 水平对齐\n            // 'auto' | 'left' | 'right'\n            // 默认为 'auto', 根据 x 的位置判断是左对齐还是右对齐\n            align: 'auto',\n\n            backgroundColor: 'rgba(0,0,0,0)',\n            // 图例边框颜色\n            borderColor: '#ccc',\n            // 图例边框线宽，单位px，默认为0（无边框）\n            borderWidth: 0,\n            // 图例内边距，单位px，默认各方向内边距为5，\n            // 接受数组分别设定上右下左边距，同css\n            padding: 5,\n            // 各个item之间的间隔，单位px，默认为10，\n            // 横向布局时为水平间隔，纵向布局时为纵向间隔\n            itemGap: 10,\n            // 图例图形宽度\n            itemWidth: 25,\n            // 图例图形高度\n            itemHeight: 14,\n\n            // 图例关闭时候的颜色\n            inactiveColor: '#ccc',\n\n            textStyle: {\n                // 图例文字颜色\n                color: '#333'\n            },\n            // formatter: '',\n            // 选择模式，默认开启图例开关\n            selectedMode: true,\n            // 配置默认选中状态，可配合LEGEND.SELECTED事件做动态数据载入\n            // selected: null,\n            // 图例内容（详见legend.data，数组中每一项代表一个item\n            // data: [],\n\n            // Tooltip 相关配置\n            tooltip: {\n                show: false\n            }\n        }\n    });\n\n    module.exports = LegendModel;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendModel.js\n// module id = 567\n// module chunks = 16","/**\n * @file Legend action\n */\n\n\n    var echarts = require('../../echarts');\n    var zrUtil = require('zrender/lib/core/util');\n\n    function legendSelectActionHandler(methodName, payload, ecModel) {\n        var selectedMap = {};\n        var isToggleSelect = methodName === 'toggleSelected';\n        var isSelected;\n        // Update all legend components\n        ecModel.eachComponent('legend', function (legendModel) {\n            if (isToggleSelect && isSelected != null) {\n                // Force other legend has same selected status\n                // Or the first is toggled to true and other are toggled to false\n                // In the case one legend has some item unSelected in option. And if other legend\n                // doesn't has the item, they will assume it is selected.\n                legendModel[isSelected ? 'select' : 'unSelect'](payload.name);\n            }\n            else {\n                legendModel[methodName](payload.name);\n                isSelected = legendModel.isSelected(payload.name);\n            }\n            var legendData = legendModel.getData();\n            zrUtil.each(legendData, function (model) {\n                var name = model.get('name');\n                // Wrap element\n                if (name === '\\n' || name === '') {\n                    return;\n                }\n                var isItemSelected = legendModel.isSelected(name);\n                if (name in selectedMap) {\n                    // Unselected if any legend is unselected\n                    selectedMap[name] = selectedMap[name] && isItemSelected;\n                }\n                else {\n                    selectedMap[name] = isItemSelected;\n                }\n            });\n        });\n        // Return the event explicitly\n        return {\n            name: payload.name,\n            selected: selectedMap\n        };\n    }\n    /**\n     * @event legendToggleSelect\n     * @type {Object}\n     * @property {string} type 'legendToggleSelect'\n     * @property {string} [from]\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendToggleSelect', 'legendselectchanged',\n        zrUtil.curry(legendSelectActionHandler, 'toggleSelected')\n    );\n\n    /**\n     * @event legendSelect\n     * @type {Object}\n     * @property {string} type 'legendSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendSelect', 'legendselected',\n        zrUtil.curry(legendSelectActionHandler, 'select')\n    );\n\n    /**\n     * @event legendUnSelect\n     * @type {Object}\n     * @property {string} type 'legendUnSelect'\n     * @property {string} name Series name or data item name\n     */\n    echarts.registerAction(\n        'legendUnSelect', 'legendunselected',\n        zrUtil.curry(legendSelectActionHandler, 'unSelect')\n    );\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendAction.js\n// module id = 568\n// module chunks = 16","\n\n    var zrUtil = require('zrender/lib/core/util');\n    var symbolCreator = require('../../util/symbol');\n    var graphic = require('../../util/graphic');\n    var listComponentHelper = require('../helper/listComponent');\n\n    var curry = zrUtil.curry;\n\n    function dispatchSelectAction(name, api) {\n        api.dispatchAction({\n            type: 'legendToggleSelect',\n            name: name\n        });\n    }\n\n    function dispatchHighlightAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'highlight',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    function dispatchDownplayAction(seriesModel, dataName, api) {\n        // If element hover will move to a hoverLayer.\n        var el = api.getZr().storage.getDisplayList()[0];\n        if (!(el && el.useHoverLayer)) {\n            seriesModel.get('legendHoverLink') && api.dispatchAction({\n                type: 'downplay',\n                seriesName: seriesModel.name,\n                name: dataName\n            });\n        }\n    }\n\n    module.exports = require('../../echarts').extendComponentView({\n\n        type: 'legend',\n\n        init: function () {\n            this._symbolTypeStore = {};\n        },\n\n        render: function (legendModel, ecModel, api) {\n            var group = this.group;\n            group.removeAll();\n\n            if (!legendModel.get('show')) {\n                return;\n            }\n\n            var selectMode = legendModel.get('selectedMode');\n            var itemAlign = legendModel.get('align');\n\n            if (itemAlign === 'auto') {\n                itemAlign = (legendModel.get('left') === 'right'\n                    && legendModel.get('orient') === 'vertical')\n                    ? 'right' : 'left';\n            }\n\n            var legendDrawedMap = {};\n\n            zrUtil.each(legendModel.getData(), function (itemModel) {\n                var name = itemModel.get('name');\n\n                // Use empty string or \\n as a newline string\n                if (name === '' || name === '\\n') {\n                    group.add(new graphic.Group({\n                        newline: true\n                    }));\n                    return;\n                }\n\n                var seriesModel = ecModel.getSeriesByName(name)[0];\n\n                if (legendDrawedMap[name]) {\n                    // Have been drawed\n                    return;\n                }\n\n                // Series legend\n                if (seriesModel) {\n                    var data = seriesModel.getData();\n                    var color = data.getVisual('color');\n\n                    // If color is a callback function\n                    if (typeof color === 'function') {\n                        // Use the first data\n                        color = color(seriesModel.getDataParams(0));\n                    }\n\n                    // Using rect symbol defaultly\n                    var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';\n                    var symbolType = data.getVisual('symbol');\n\n                    var itemGroup = this._createItem(\n                        name, itemModel, legendModel,\n                        legendSymbolType, symbolType,\n                        itemAlign, color,\n                        selectMode\n                    );\n\n                    itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                        .on('mouseover', curry(dispatchHighlightAction, seriesModel, null, api))\n                        .on('mouseout', curry(dispatchDownplayAction, seriesModel, null, api));\n\n                    legendDrawedMap[name] = true;\n                }\n                else {\n                    // Data legend of pie, funnel\n                    ecModel.eachRawSeries(function (seriesModel) {\n                        // In case multiple series has same data name\n                        if (legendDrawedMap[name]) {\n                            return;\n                        }\n                        if (seriesModel.legendDataProvider) {\n                            var data = seriesModel.legendDataProvider();\n                            var idx = data.indexOfName(name);\n                            if (idx < 0) {\n                                return;\n                            }\n\n                            var color = data.getItemVisual(idx, 'color');\n\n                            var legendSymbolType = 'roundRect';\n\n                            var itemGroup = this._createItem(\n                                name, itemModel, legendModel,\n                                legendSymbolType, null,\n                                itemAlign, color,\n                                selectMode\n                            );\n\n                            itemGroup.on('click', curry(dispatchSelectAction, name, api))\n                                // FIXME Should not specify the series name\n                                .on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api))\n                                .on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));\n\n                            legendDrawedMap[name] = true;\n                        }\n                    }, this);\n                }\n\n                if (__DEV__) {\n                    if (!legendDrawedMap[name]) {\n                        console.warn(name + ' series not exists. Legend data should be same with series name or data name.');\n                    }\n                }\n            }, this);\n\n            listComponentHelper.layout(group, legendModel, api);\n            // Render background after group is layout\n            // FIXME\n            listComponentHelper.addBackground(group, legendModel);\n        },\n\n        _createItem: function (\n            name, itemModel, legendModel,\n            legendSymbolType, symbolType,\n            itemAlign, color, selectMode\n        ) {\n            var itemWidth = legendModel.get('itemWidth');\n            var itemHeight = legendModel.get('itemHeight');\n            var inactiveColor = legendModel.get('inactiveColor');\n\n            var isSelected = legendModel.isSelected(name);\n            var itemGroup = new graphic.Group();\n\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var itemIcon = itemModel.get('icon');\n\n            var tooltipModel = itemModel.getModel('tooltip');\n            var legendGlobalTooltipModel = tooltipModel.parentModel;\n\n            // Use user given icon first\n            legendSymbolType = itemIcon || legendSymbolType;\n            itemGroup.add(symbolCreator.createSymbol(\n                legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor\n            ));\n\n            // Compose symbols\n            // PENDING\n            if (!itemIcon && symbolType\n                // At least show one symbol, can't be all none\n                && ((symbolType !== legendSymbolType) || symbolType == 'none')\n            ) {\n                var size = itemHeight * 0.8;\n                if (symbolType === 'none') {\n                    symbolType = 'circle';\n                }\n                // Put symbol in the center\n                itemGroup.add(symbolCreator.createSymbol(\n                    symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size,\n                    isSelected ? color : inactiveColor\n                ));\n            }\n\n            // Text\n            var textX = itemAlign === 'left' ? itemWidth + 5 : -5;\n            var textAlign = itemAlign;\n\n            var formatter = legendModel.get('formatter');\n            var content = name;\n            if (typeof formatter === 'string' && formatter) {\n                content = formatter.replace('{name}', name);\n            }\n            else if (typeof formatter === 'function') {\n                content = formatter(name);\n            }\n\n            var text = new graphic.Text({\n                style: {\n                    text: content,\n                    x: textX,\n                    y: itemHeight / 2,\n                    fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,\n                    textFont: textStyleModel.getFont(),\n                    textAlign: textAlign,\n                    textVerticalAlign: 'middle'\n                }\n            });\n            itemGroup.add(text);\n\n            // Add a invisible rect to increase the area of mouse hover\n            var hitRect = new graphic.Rect({\n                shape: itemGroup.getBoundingRect(),\n                invisible: true,\n                tooltip: tooltipModel.get('show') ? zrUtil.extend({\n                    content: name,\n                    // Defaul formatter\n                    formatter: legendGlobalTooltipModel.get('formatter', true) || function () {\n                        return name;\n                    },\n                    formatterParams: {\n                        componentType: 'legend',\n                        legendIndex: legendModel.componentIndex,\n                        name: name,\n                        $vars: ['name']\n                    }\n                }, tooltipModel.option) : null\n            });\n            itemGroup.add(hitRect);\n\n            itemGroup.eachChild(function (child) {\n                child.silent = true;\n            });\n\n            hitRect.silent = !selectMode;\n\n\n\n            this.group.add(itemGroup);\n\n            graphic.setHoverStyle(itemGroup);\n\n            return itemGroup;\n        }\n    });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/LegendView.js\n// module id = 569\n// module chunks = 16","\n    // List layout\n    var layout = require('../../util/layout');\n    var formatUtil = require('../../util/format');\n    var graphic = require('../../util/graphic');\n\n    function positionGroup(group, model, api) {\n        layout.positionGroup(\n            group, model.getBoxLayoutParams(),\n            {\n                width: api.getWidth(),\n                height: api.getHeight()\n            },\n            model.get('padding')\n        );\n    }\n\n    module.exports = {\n        /**\n         * Layout list like component.\n         * It will box layout each items in group of component and then position the whole group in the viewport\n         * @param {module:zrender/group/Group} group\n         * @param {module:echarts/model/Component} componentModel\n         * @param {module:echarts/ExtensionAPI}\n         */\n        layout: function (group, componentModel, api) {\n            var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }, componentModel.get('padding'));\n            layout.box(\n                componentModel.get('orient'),\n                group,\n                componentModel.get('itemGap'),\n                rect.width,\n                rect.height\n            );\n\n            positionGroup(group, componentModel, api);\n        },\n\n        addBackground: function (group, componentModel) {\n            var padding = formatUtil.normalizeCssArray(\n                componentModel.get('padding')\n            );\n            var boundingRect = group.getBoundingRect();\n            var style = componentModel.getItemStyle(['color', 'opacity']);\n            style.fill = componentModel.get('backgroundColor');\n            var rect = new graphic.Rect({\n                shape: {\n                    x: boundingRect.x - padding[3],\n                    y: boundingRect.y - padding[0],\n                    width: boundingRect.width + padding[1] + padding[3],\n                    height: boundingRect.height + padding[0] + padding[2]\n                },\n                style: style,\n                silent: true,\n                z2: -1\n            });\n            graphic.subPixelOptimizeRect(rect);\n\n            group.add(rect);\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/helper/listComponent.js\n// module id = 570\n// module chunks = 16","\n   module.exports = function (ecModel) {\n        var legendModels = ecModel.findComponents({\n            mainType: 'legend'\n        });\n        if (legendModels && legendModels.length) {\n            ecModel.filterSeries(function (series) {\n                // If in any legend component the status is not selected.\n                // Because in legend series is assumed selected when it is not in the legend data.\n                for (var i = 0; i < legendModels.length; i++) {\n                    if (!legendModels[i].isSelected(series.name)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n    };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/legend/legendFilter.js\n// module id = 571\n// module chunks = 16","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./chart.less\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./chart.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./chart.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/app/components/chart/chart.less\n// module id = 572\n// module chunks = 16","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".echarts-container{float:none;height:150px}.echarts{width:100%;height:100%;display:block}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/less-loader!./client/app/components/chart/chart.less\n// module id = 573\n// module chunks = 16"],"sourceRoot":""}