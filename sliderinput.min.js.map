{"version":3,"sources":["webpack:///sliderinput.min.js","webpack:///./example/app/components/sliderinput/sliderinput.html","webpack:///./example/app/components/sliderinput/sliderinput.less?b250","webpack:///./lib/Rangeinput/range.less?d368","webpack:///./example/app/components/sliderinput/sliderinput.js","webpack:///./example/app/components/sliderinput/sliderinput.less","webpack:///./lib/Rangeinput/range.less","webpack:///./example/app/components/sliderinput/sliderinput.component.js","webpack:///./example/app/components/sliderinput/sliderinput.controller.js","webpack:///./lib/Rangeinput/index.js","webpack:///./lib/touch/index.js"],"names":["webpackJsonp","1013","module","exports","1081","__webpack_require__","content","i","locals","1103","316","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_sliderinputComponent","_sliderinputComponent2","_index","_index2","angular","name","component","711","push","733","888","_sliderinput","_sliderinput2","_sliderinputController","_sliderinputController2","restrict","bindings","template","controller","controllerAs","889","_classCallCheck","instance","Constructor","TypeError","SliderinputController","$document","$state","this","$inject","949","_touch","_touch2","$element","element","min","max","step","directive","compile","tElement","children","length","attr","addClass","append","Math","random","toString","substring","scope","iElement","iAttrs","hasClass","$observe","newVal","isNaN","$emit","require","start","end","link","val","css","displayed","isDefined","$swipe","htmlElement","document","body","parentElement","_formatValue","formattedValue","floor","getFormattedValue","_cache","updateIfChanged","oldVal","isUndefined","ngModel","$modelValue","$setViewValue","_cached_layout_values","time","Date","track_bb","parent","getBoundingClientRect","trackOrigine","left","trackSize","width","_handleMouseEvent","coord","lastPos","x","the_thumb_value","ffanRangeCtrl","parseFloat","toFixed","$root","$$phase","$apply","$render","animationFrameRequested","$on","window","cancelAnimationFrame","requestAnimationFrame","the_thumb_pos","$viewValue","$formatters","$parsers","$setValidity","$isEmpty","isNumber","hasMultipleThumb","getElementsByClassName","bind","event","target","stopPropagation","preventDefault","move","unbind","triggerHandler","975","nodeName_","lowercase","nodeName","$TouchProvider","$provide","$compileProvider","ngClickOverrideEnabled","ngClickDirectiveAdded","enabled","ngTouchClickDirectiveFactory","$$moduleName","decorator","$delegate","shift","splice","$get","makeSwipeDirective","directiveName","direction","eventName","ngTouch","$parse","MAX_VERTICAL_DISTANCE","MAX_VERTICAL_RATIO","MIN_HORIZONTAL_DISTANCE","validSwipe","coords","startCoords","deltaY","abs","y","deltaX","valid","swipeHandler","pointerTypes","cancel","$event","provider","factory","getCoordinates","originalEvent","touches","e","changedTouches","clientX","clientY","getEvents","eventType","res","forEach","pointerType","POINTER_EVENTS","join","MOVE_BUFFER_RADIUS","mouse","touch","pointer","eventHandlers","totalX","totalY","active","on","events","$timeout","$rootElement","hit","x1","y1","x2","y2","CLICKBUSTER_THRESHOLD","checkAllowableRegions","touchCoordinates","onClick","now","lastPreventedTime","PREVENT_DURATION","lastLabelClickCoordinates","blur","onTouchStart","preventGhostClick","addEventListener","TAP_DURATION","MOVE_TOLERANCE","ACTIVE_CLASS_NAME","resetState","tapping","removeClass","tapElement","startTime","touchStartX","touchStartY","clickHandler","ngClick","srcElement","nodeType","parentNode","diff","dist","sqrt","pow","disabled","onclick","touchend"],"mappings":"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","file":"sliderinput.min.js","sourcesContent":["webpackJsonp([27],{\n\n/***/ 1013:\n/***/ function(module, exports) {\n\nmodule.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1 translate='{{vm.$state.current.name}}'></h1>\\n\\t<p>{{'SliderInputDesc'|translate}}</p>\\n</section>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Install' | translate}}</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"bash\\\">\\nnpm install fancyui --save\\n</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Inject_Module'|translate}}</h2>\\n</section>\\n\\n<div class=\\\"example-block no-border\\\">\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nimport sliderinputComponent from './sliderinput.component';\\nimport {RangeInput} from 'fancyui';\\nexport default angular.module('sliderInput', [\\n  RangeInput.name\\n])\\n.component('sliderInput', sliderinputComponent);\\n</div>\\n</div>\\n\\n\\n<h2>{{'Example'|translate}}</h2>\\n\\n<div class=\\\"example-block\\\">\\n\\t<div class=\\\"bs-example\\\">\\n\\t\\t<div class=\\\"range-container\\\">\\n\\t\\t\\t<div class=\\\"range-controller\\\">\\n\\t\\t\\t\\t<div class=\\\"ffan-range ffan-range--default\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\">\\n\\t\\t\\t\\t\\t<div class=\\\"ffan-range__range\\\" end=\\\"{{_c}}\\\" ></div>\\n\\t\\t\\t\\t\\t<div class=\\\"ffan-range__thumb\\\" ng-model=\\\"_c\\\" name=\\\"input\\\"></div>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\n\\t\\t\\t<div class=\\\"range-input\\\">\\n\\t\\t\\t\\t<input type=\\\"number\\\" class=\\\"form-control\\\" ng-model=\\\"_c\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\"> M\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<div class=\\\"range-container\\\">\\n  <div class=\\\"range-controller\\\">\\n    <div class=\\\"ffan-range ffan-range--default\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\">\\n    <div class=\\\"ffan-range__range\\\" end=\\\"{{_c}}\\\" ></div>\\n    <div class=\\\"ffan-range__thumb\\\" ng-model=\\\"_c\\\" name=\\\"input\\\"></div>\\n  </div>\\n  </div>\\n  <div class=\\\"range-input\\\">\\n    <input type=\\\"number\\\" class=\\\"form-control\\\" ng-model=\\\"_c\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\"> M\\n  </div>\\n</div>\\n</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Options'|translate}}</h2>\\n\\t<table class=\\\"demo-table\\\">\\n\\t\\t<thead>\\n\\t\\t<tr>\\n\\t\\t\\t<th>{{'Param'|translate}}</th>\\n\\t\\t\\t<th>{{'Description'|translate}}</th>\\n\\t\\t\\t<th>{{'Type'|translate}}</th>\\n\\t\\t\\t<th>{{'Optional'|translate}}</th>\\n\\t\\t\\t<th>{{'DefaultValue'|translate}}</th>\\n\\t\\t</tr>\\n\\t\\t</thead>\\n\\t\\t<tbody>\\n\\t\\t<tr>\\n\\t\\t\\t<td>min</td>\\n\\t\\t\\t<td>min value</td>\\n\\t\\t\\t<td>number</td>\\n\\t\\t\\t<td>—</td>\\n\\t\\t\\t<td>0</td>\\n\\t\\t</tr>\\n\\t\\t<tr>\\n\\t\\t\\t<td>max</td>\\n\\t\\t\\t<td>max value</td>\\n\\t\\t\\t<td>number</td>\\n\\t\\t\\t<td>—</td>\\n\\t\\t\\t<td>100</td>\\n\\t\\t</tr>\\n\\t\\t<tr>\\n\\t\\t\\t<td>step</td>\\n\\t\\t\\t<td>step number</td>\\n\\t\\t\\t<td>number</td>\\n\\t\\t\\t<td>—</td>\\n\\t\\t\\t<td>1</td>\\n\\t\\t</tr>\\n\\t\\t</tbody>\\n\\t</table>\\n</section>\\n\"\n\n/***/ },\n\n/***/ 1081:\n/***/ function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(711);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(2)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./sliderinput.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./sliderinput.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ },\n\n/***/ 1103:\n/***/ function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(733);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(2)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./range.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./range.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ },\n\n/***/ 316:\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n});\n\nvar _sliderinputComponent = __webpack_require__(888);\n\nvar _sliderinputComponent2 = _interopRequireDefault(_sliderinputComponent);\n\nvar _index = __webpack_require__(949);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = angular.module('sliderInput', [_index2.default.name]).component('sliderInput', _sliderinputComponent2.default);\n\n/***/ },\n\n/***/ 711:\n/***/ function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \".range-controller {\\n  width: 70%;\\n  display: inline-block;\\n  vertical-align: middle;\\n}\\n.range-input {\\n  width: 20%;\\n  display: inline-block;\\n  vertical-align: middle;\\n  margin-left: 10px;\\n}\\n.range-input input {\\n  width: 60%;\\n  display: inline-block;\\n  margin-right: 5px;\\n}\\n\", \"\"]);\n\n// exports\n\n\n/***/ },\n\n/***/ 733:\n/***/ function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \"/* =ffan.Range\\n-----------------------------------------------------------------------------*/\\n.ffan-range {\\n  position: relative;\\n  display: block;\\n}\\n.ffan-range:after {\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  display: block;\\n  content: '';\\n  z-index: 4;\\n}\\n.ffan-range__thumb {\\n  position: absolute;\\n  cursor: pointer;\\n  z-index: 5;\\n}\\n.ffan-range__range {\\n  position: absolute;\\n  height: 100%;\\n  left: 0;\\n  right: 100%;\\n  z-index: 6;\\n}\\n/* =ffan.Range default style\\n-----------------------------------------------------------------------------*/\\n.ffan-range--default {\\n  height: 20px;\\n  margin-right: 10px;\\n}\\n.ffan-range--default:after,\\n.ffan-range--default .ffan-range__range {\\n  height: 9px;\\n  border-radius: 3px;\\n  top: 5px;\\n  right: -10px;\\n}\\n.ffan-range--default .ffan-range__range {\\n  border-radius: 3px 0 0 3px;\\n}\\n.ffan-range--default:after {\\n  background: #e5e5e5;\\n}\\n.ffan-range--default .ffan-range__thumb {\\n  width: 10px;\\n  height: 20px;\\n  background: #10a793;\\n  border-radius: 3px;\\n}\\n.ffan-range--default .ffan-range__thumb:hover {\\n  background: #10a793;\\n}\\n.ffan-range--default .ffan-range__range {\\n  background: #1fbba6;\\n}\\n.echarts-container {\\n  float: none;\\n  height: 150px;\\n}\\n.echarts {\\n  width: 100%;\\n  height: 100%;\\n  display: block;\\n}\\n\", \"\"]);\n\n// exports\n\n\n/***/ },\n\n/***/ 888:\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _sliderinput = __webpack_require__(1013);\n\nvar _sliderinput2 = _interopRequireDefault(_sliderinput);\n\nvar _sliderinputController = __webpack_require__(889);\n\nvar _sliderinputController2 = _interopRequireDefault(_sliderinputController);\n\n__webpack_require__(1081);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  restrict: 'E',\n  bindings: {},\n  template: _sliderinput2.default,\n  controller: _sliderinputController2.default,\n  controllerAs: 'vm'\n};\n\n/***/ },\n\n/***/ 889:\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * (description)\n *\n * @author yourname\n */\n\nvar SliderinputController = function SliderinputController($document, $state) {\n  'ngInject';\n\n  _classCallCheck(this, SliderinputController);\n\n  this.$state = $state;\n};\nSliderinputController.$inject = [\"$document\", \"$state\"];\n\nexports.default = SliderinputController;\n\n/***/ },\n\n/***/ 949:\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n__webpack_require__(1103);\n\nvar _touch = __webpack_require__(975);\n\nvar _touch2 = _interopRequireDefault(_touch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * rangeInput\n */\n\nexports.default = angular.module('rangeInput', [_touch2.default.name]).value('ffanRangeConfig', {}).controller('ffanRangeController', [\"$element\", function ffanRangeCtrl($element) {\n  this.element = $element;\n  this.min = 0;\n  this.max = 100;\n  this.step = 1;\n}]).directive('ffanRange', function () {\n  return {\n    restrict: 'EAC',\n    controller: 'ffanRangeController',\n    compile: function compile(tElement) {\n      if (tElement.children().length === 0) {\n        // Create a default slider for design purpose.\n\n        if (!tElement.attr('class') && tElement.attr('class') !== '') {\n          tElement.addClass('ffan-range--default');\n        }\n\n        tElement.append(\n        // Use a virtual scope key to allow\n        '<div class=\"ffan-range__thumb\" ng-model=\"__' + Math.random().toString(36).substring(7) + '\"></div>');\n      }\n\n      return function (scope, iElement, iAttrs, controller) {\n\n        if (!iElement.hasClass('ffan-range')) {\n          iElement.addClass('ffan-range');\n        }\n\n        ////////////////////////////////////////////////////////////////////\n        // OBSERVERS\n        ////////////////////////////////////////////////////////////////////\n\n        // Observe the min attr (default 0)\n        iAttrs.$observe('min', function (newVal) {\n          controller.min = +newVal;\n          controller.min = !isNaN(controller.min) ? controller.min : 0;\n          scope.$emit('global min changed');\n        });\n\n        // Observe the max attr (default 100)\n        iAttrs.$observe('max', function (newVal) {\n          controller.max = +newVal;\n          controller.max = !isNaN(controller.max) ? controller.max : 100;\n          scope.$emit('global max changed');\n        });\n\n        // Observe the step attr (default 1)\n        iAttrs.$observe('step', function (newVal) {\n          controller.step = +newVal;\n          controller.step = !isNaN(controller.step) && controller.step > 0 ? controller.step : 1;\n          scope.$emit('global step changed');\n        });\n      };\n    }\n  };\n}).directive('ffanRangeRange', function () {\n  return {\n    restrict: 'EAC',\n    require: '^ffanRange',\n    scope: { start: '@', end: '@' },\n    link: function link(scope, iElement, iAttrs, controller) {\n\n      if (!iElement.hasClass('ffan-range__range')) {\n        iElement.addClass('ffan-range__range');\n      }\n\n      ////////////////////////////////////////////////////////////////////\n      // OBSERVERS\n      ////////////////////////////////////////////////////////////////////\n\n      // Observe the start attr (default 0%)\n      iAttrs.$observe('start', function (newVal) {\n        var val = !isNaN(+newVal) ? +newVal : 0;\n        val = (val - controller.min) / (controller.max - controller.min) * 100;\n        // TODO add half of th width of the targeted thumb ([ng-model='+ iAttrs.$attr.start + '])\n        // TODO force width 0 if (left + right === 100 )\n        iElement.css('left', val + '%');\n      });\n\n      // Observe the min attr (default 100%)\n      iAttrs.$observe('end', function (newVal) {\n        // Don't display the range if no attr are specified\n        var displayed = angular.isDefined(iAttrs.start) || angular.isDefined(iAttrs.end);\n        var val = !isNaN(+newVal) ? +newVal : displayed ? 100 : 0;\n        val = (val - controller.min) / (controller.max - controller.min) * 100;\n        // TODO add half of th width of the targeted thumb ([ng-model='+ iAttrs.$attr.end + '])\n        // TODO force width 0 if (left + right === 100 )\n        iElement.css('right', 100 - val + '%');\n      });\n    }\n  };\n}).directive('ffanRangeThumb', [\"$swipe\", function ($swipe) {\n  // Get all the page.\n  var htmlElement = angular.element(document.body.parentElement);\n\n  return {\n    restrict: 'EAC',\n    require: ['^ffanRange', '?ngModel'],\n    link: function link(scope, iElement, iAttrs, controller) {\n\n      if (!iElement.hasClass('ffan-range__thumb')) {\n        iElement.addClass('ffan-range__thumb');\n      }\n\n      if (!controller[1]) return;\n      var ngModel = controller[1];\n      var ffanRangeCtrl = controller[0];\n      var animationFrameRequested;\n      var _cache = {\n        min: ffanRangeCtrl.min,\n        max: ffanRangeCtrl.max,\n        step: ffanRangeCtrl.step\n      };\n\n      ////////////////////////////////////////////////////////////////////\n      // UTILS\n      ////////////////////////////////////////////////////////////////////\n\n      function _formatValue(value, min, max, step) {\n        var formattedValue = value;\n        if (min > max) return max;\n        formattedValue = Math.floor(formattedValue / step) * step;\n        formattedValue = Math.max(Math.min(formattedValue, max), min);\n        return formattedValue;\n      }\n\n      function getFormattedValue(value) {\n        var formattedValue = value;\n        formattedValue = _formatValue(formattedValue, _cache.min, _cache.max, _cache.step);\n        return formattedValue;\n      }\n\n      function updateIfChanged(newVal, oldVal) {\n        if (!angular.isUndefined(oldVal) && !isNaN(ngModel.$modelValue) && oldVal !== newVal) {\n          ngModel.$setViewValue(getFormattedValue(ngModel.$modelValue));\n        }\n      }\n\n      ////////////////////////////////////////////////////////////////////\n      // OBSERVERS\n      ////////////////////////////////////////////////////////////////////\n\n      // Observe the min attr (default 0)\n      iAttrs.$observe('min', function observeMin(newVal) {\n        var oldVal = _cache.min;\n        _cache.min = +newVal;\n        _cache.min = !isNaN(_cache.min) ? _cache.min : 0;\n\n        updateIfChanged(_cache.min, oldVal);\n\n        ngModel.$render();\n      });\n      scope.$on('global min changed', function observeGlobalMin() {\n        var oldVal = _cache.min;\n\n        _cache.min = angular.isDefined(iAttrs.min) ? _cache.min : ffanRangeCtrl.min;\n        // Secure no NaN here...\n        _cache.min = !isNaN(_cache.min) ? _cache.min : 0;\n\n        updateIfChanged(_cache.min, oldVal);\n        ngModel.$render();\n      });\n\n      // Observe the max attr (default 100)\n      iAttrs.$observe('max', function observeMax(newVal) {\n        var oldVal = _cache.max;\n        _cache.max = +newVal;\n        _cache.max = !isNaN(_cache.max) ? _cache.max : 100;\n\n        updateIfChanged(_cache.max, oldVal);\n\n        ngModel.$render();\n      });\n      scope.$on('global max changed', function observeGlobalMax() {\n        var oldVal = _cache.max;\n\n        _cache.max = angular.isDefined(iAttrs.max) ? _cache.max : ffanRangeCtrl.max;\n        // Secure no NaN here...\n        _cache.max = !isNaN(_cache.max) ? _cache.max : 100;\n\n        updateIfChanged(_cache.max, oldVal);\n        ngModel.$render();\n      });\n\n      // Observe the step attr (default 1)\n      iAttrs.$observe('step', function observeStep(newVal) {\n        var oldVal = _cache.step;\n        _cache.step = +newVal;\n        _cache.step = !isNaN(_cache.step) && _cache.step > 0 ? _cache.step : 1;\n\n        updateIfChanged(_cache.step, oldVal);\n\n        ngModel.$render();\n      });\n      scope.$on('global step changed', function observeGlobalStep() {\n        var oldVal = _cache.step;\n\n        _cache.step = angular.isDefined(iAttrs.step) ? _cache.step : ffanRangeCtrl.step;\n\n        // Secure no NaN here...\n        _cache.step = !isNaN(_cache.step) && _cache.step > 0 ? _cache.step : 1;\n\n        updateIfChanged(_cache.step, oldVal);\n        ngModel.$render();\n      });\n      ////////////////////////////////////////////////////////////////////\n      // RENDERING\n      ////////////////////////////////////////////////////////////////////\n\n      ngModel.$render = function ngModelRender() {\n\n        // Cancel previous rAF call\n        if (animationFrameRequested) {\n          window.cancelAnimationFrame(animationFrameRequested);\n        }\n\n        // Animate the page outside the event\n        animationFrameRequested = window.requestAnimationFrame(function drawFromTheModelValue() {\n          var the_thumb_pos = (ngModel.$viewValue - ffanRangeCtrl.min) / (ffanRangeCtrl.max - ffanRangeCtrl.min) * 100;\n          the_thumb_pos = the_thumb_pos.toFixed(5);\n          iElement.css('left', the_thumb_pos + '%');\n        });\n      };\n\n      ////////////////////////////////////////////////////////////////////\n      // FORMATTING\n      ////////////////////////////////////////////////////////////////////\n      // Final view format\n      ngModel.$formatters.push(function (value) {\n        return +value;\n      });\n\n      // Checks that it's on the step\n      ngModel.$parsers.push(function stepParser(value) {\n        ngModel.$setValidity('step', true);\n        return Math.floor(value / _cache.step) * _cache.step;\n      });\n      ngModel.$formatters.push(function stepValidator(value) {\n        if (!ngModel.$isEmpty(value) && value !== Math.floor(value / _cache.step) * _cache.step) {\n          ngModel.$setValidity('step', false);\n          return undefined;\n        } else {\n          ngModel.$setValidity('step', true);\n          return value;\n        }\n      });\n\n      // Checks that it's less then the maximum\n      ngModel.$parsers.push(function maxParser(value) {\n        ngModel.$setValidity('max', true);\n        return Math.min(value, _cache.max);\n      });\n      ngModel.$formatters.push(function maxValidator(value) {\n        if (!ngModel.$isEmpty(value) && value > _cache.max) {\n          ngModel.$setValidity('max', false);\n          return undefined;\n        } else {\n          ngModel.$setValidity('max', true);\n          return value;\n        }\n      });\n\n      // Checks that it's more then the minimum\n      ngModel.$parsers.push(function minParser(value) {\n        ngModel.$setValidity('min', true);\n        return Math.max(value, _cache.min);\n      });\n      ngModel.$formatters.push(function minValidator(value) {\n        if (!ngModel.$isEmpty(value) && value < _cache.min) {\n          ngModel.$setValidity('min', false);\n          return undefined;\n        } else {\n          ngModel.$setValidity('min', true);\n          return value;\n        }\n      });\n\n      // First check that a number is used\n      ngModel.$formatters.push(function numberValidator(value) {\n        if (ngModel.$isEmpty(value) || angular.isNumber(value)) {\n          ngModel.$setValidity('number', true);\n          return value;\n        } else {\n          ngModel.$setValidity('number', false);\n          return undefined;\n        }\n      });\n\n      ////////////////////////////////////////////////////////////////////\n      // USER EVENT BINDING\n      ////////////////////////////////////////////////////////////////////\n\n      var hasMultipleThumb = 1 < iElement.parent()[0].getElementsByClassName('ffan-range__thumb').length;\n\n      // Bind the click on the bar then you can move it all over the page.\n      $swipe.bind(ffanRangeCtrl.element, {\n\n        start: function start(coord, event) {\n\n          if (hasMultipleThumb && event.target !== iElement[0]) {\n            return;\n          }\n\n          $swipe.bind(htmlElement, {\n            start: function start(coord, event) {\n              event.stopPropagation();\n              event.preventDefault();\n            },\n            move: function move(coord) {\n              _handleMouseEvent(coord);\n            },\n            end: function end() {\n              // Don't preventDefault and stopPropagation\n              // The html element needs to be free of doing anything !\n              htmlElement.unbind();\n            }\n          });\n\n          if (!hasMultipleThumb) {\n            // Handle simple click\n            _handleMouseEvent(coord);\n            htmlElement.triggerHandler('touchstart mousedown', event);\n          }\n        }\n\n      });\n\n      function _cached_layout_values() {\n\n        if (_cache.time && +new Date() < _cache.time + 1000) {\n          return;\n        } // after ~60 frames\n\n        // track bounding box\n        var track_bb = iElement.parent()[0].getBoundingClientRect();\n\n        _cache.time = +new Date();\n        _cache.trackOrigine = track_bb.left;\n        _cache.trackSize = track_bb.width;\n      }\n\n      function _handleMouseEvent(coord) {\n\n        // Store the mouse position for later\n        _cache.lastPos = coord.x;\n\n        _cached_layout_values();\n\n        var the_thumb_value = ffanRangeCtrl.min + (_cache.lastPos - _cache.trackOrigine) / _cache.trackSize * (ffanRangeCtrl.max - ffanRangeCtrl.min);\n        the_thumb_value = getFormattedValue(the_thumb_value);\n\n        ngModel.$setViewValue(parseFloat(the_thumb_value.toFixed(5)));\n        if (!scope.$root.$$phase) {\n          scope.$root.$apply();\n        }\n        ngModel.$render();\n      }\n    }\n  };\n}]);\n\n/***/ },\n\n/***/ 975:\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * ngTouch  \n */\n\nvar ngTouch = angular.module('ffanTouch', []);\n\nngTouch.provider('$touch', $TouchProvider);\n\nfunction nodeName_(element) {\n  return angular.lowercase(element.nodeName || element[0] && element[0].nodeName);\n}\n\n/**\n * @ngdoc provider\n * @name $touchProvider\n *\n * @description\n * The `$touchProvider` allows enabling / disabling {@link ngTouch.ngClick ngTouch's ngClick directive}.\n */\n$TouchProvider.$inject = ['$provide', '$compileProvider'];\nfunction $TouchProvider($provide, $compileProvider) {\n\n  /**\n   * @ngdoc method\n   * @name  $touchProvider#ngClickOverrideEnabled\n   *\n   * @param {boolean=} enabled update the ngClickOverrideEnabled state if provided, otherwise just return the\n   * current ngClickOverrideEnabled state\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   *\n   * @kind function\n   *\n   * @description\n   * Call this method to enable/disable {@link ngTouch.ngClick ngTouch's ngClick directive}. If enabled,\n   * the default ngClick directive will be replaced by a version that eliminates the 300ms delay for\n   * click events on browser for touch-devices.\n   *\n   * The default is `false`.\n   *\n   */\n  var _ngClickOverrideEnabled = false;\n  var ngClickDirectiveAdded = false;\n  // eslint-disable-next-line no-invalid-this\n  this.ngClickOverrideEnabled = function (enabled) {\n    if (angular.isDefined(enabled)) {\n\n      if (enabled && !ngClickDirectiveAdded) {\n        ngClickDirectiveAdded = true;\n\n        // Use this to identify the correct directive in the delegate\n        ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';\n        $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);\n\n        $provide.decorator('ngClickDirective', ['$delegate', function ($delegate) {\n          if (_ngClickOverrideEnabled) {\n            // drop the default ngClick directive\n            $delegate.shift();\n          } else {\n            // drop the ngTouch ngClick directive if the override has been re-disabled (because\n            // we cannot de-register added directives)\n            var i = $delegate.length - 1;\n            while (i >= 0) {\n              if ($delegate[i].$$moduleName === 'ngTouch') {\n                $delegate.splice(i, 1);\n                break;\n              }\n              i--;\n            }\n          }\n\n          return $delegate;\n        }]);\n      }\n\n      _ngClickOverrideEnabled = enabled;\n      return this;\n    }\n\n    return _ngClickOverrideEnabled;\n  };\n\n  /**\n  * @ngdoc service\n  * @name $touch\n  * @kind object\n  *\n  * @description\n  * Provides the {@link ngTouch.$touch#ngClickOverrideEnabled `ngClickOverrideEnabled`} method.\n  *\n  */\n  // eslint-disable-next-line no-invalid-this\n  this.$get = function () {\n    return {\n      /**\n       * @ngdoc method\n       * @name  $touch#ngClickOverrideEnabled\n       *\n       * @returns {*} current value of `ngClickOverrideEnabled` set in the {@link ngTouch.$touchProvider $touchProvider},\n       * i.e. if {@link ngTouch.ngClick ngTouch's ngClick} directive is enabled.\n       *\n       * @kind function\n       */\n      ngClickOverrideEnabled: function ngClickOverrideEnabled() {\n        return _ngClickOverrideEnabled;\n      }\n    };\n  };\n}\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc service\n * @name $swipe\n *\n * @description\n * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe\n * behavior, to make implementing swipe-related directives more convenient.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`.\n *\n * # Usage\n * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element\n * which is to be watched for swipes, and an object with four handler functions. See the\n * documentation for `bind` below.\n */\n\nngTouch.factory('$swipe', [function () {\n  // The total distance in any direction before we make the call on swipe vs. scroll.\n  var MOVE_BUFFER_RADIUS = 10;\n\n  var POINTER_EVENTS = {\n    'mouse': {\n      start: 'mousedown',\n      move: 'mousemove',\n      end: 'mouseup'\n    },\n    'touch': {\n      start: 'touchstart',\n      move: 'touchmove',\n      end: 'touchend',\n      cancel: 'touchcancel'\n    },\n    'pointer': {\n      start: 'pointerdown',\n      move: 'pointermove',\n      end: 'pointerup',\n      cancel: 'pointercancel'\n    }\n  };\n\n  function getCoordinates(event) {\n    var originalEvent = event.originalEvent || event;\n    var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n    var e = originalEvent.changedTouches && originalEvent.changedTouches[0] || touches[0];\n\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n\n  function getEvents(pointerTypes, eventType) {\n    var res = [];\n    angular.forEach(pointerTypes, function (pointerType) {\n      var eventName = POINTER_EVENTS[pointerType][eventType];\n      if (eventName) {\n        res.push(eventName);\n      }\n    });\n    return res.join(' ');\n  }\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $swipe#bind\n     *\n     * @description\n     * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an\n     * object containing event handlers.\n     * The pointer types that should be used can be specified via the optional\n     * third argument, which is an array of strings `'mouse'`, `'touch'` and `'pointer'`. By default,\n     * `$swipe` will listen for `mouse`, `touch` and `pointer` events.\n     *\n     * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`\n     * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }` and the raw\n     * `event`. `cancel` receives the raw `event` as its single parameter.\n     *\n     * `start` is called on either `mousedown`, `touchstart` or `pointerdown`. After this event, `$swipe` is\n     * watching for `touchmove`, `mousemove` or `pointermove` events. These events are ignored until the total\n     * distance moved in either dimension exceeds a small threshold.\n     *\n     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.\n     * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.\n     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.\n     *   A `cancel` event is sent.\n     *\n     * `move` is called on `mousemove`, `touchmove` and `pointermove` after the above logic has determined that\n     * a swipe is in progress.\n     *\n     * `end` is called when a swipe is successfully completed with a `touchend`, `mouseup` or `pointerup`.\n     *\n     * `cancel` is called either on a `touchcancel` or `pointercancel`  from the browser, or when we begin scrolling\n     * as described above.\n     *\n     */\n    bind: function bind(element, eventHandlers, pointerTypes) {\n      // Absolute total movement, used to control swipe vs. scroll.\n      var totalX, totalY;\n      // Coordinates of the start position.\n      var startCoords;\n      // Last event's position.\n      var lastPos;\n      // Whether a swipe is active.\n      var active = false;\n\n      pointerTypes = pointerTypes || ['mouse', 'touch', 'pointer'];\n      element.on(getEvents(pointerTypes, 'start'), function (event) {\n        startCoords = getCoordinates(event);\n        active = true;\n        totalX = 0;\n        totalY = 0;\n        lastPos = startCoords;\n        if (eventHandlers['start']) {\n          eventHandlers['start'](startCoords, event);\n        }\n      });\n      var events = getEvents(pointerTypes, 'cancel');\n      if (events) {\n        element.on(events, function (event) {\n          active = false;\n          if (eventHandlers['cancel']) {\n            eventHandlers['cancel'](event);\n          }\n        });\n      }\n\n      element.on(getEvents(pointerTypes, 'move'), function (event) {\n        if (!active) return;\n\n        // Android will send a touchcancel if it thinks we're starting to scroll.\n        // So when the total distance (+ or - or both) exceeds 10px in either direction,\n        // we either:\n        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.\n        // - On totalY > totalX, we let the browser handle it as a scroll.\n\n        if (!startCoords) return;\n        var coords = getCoordinates(event);\n\n        totalX += Math.abs(coords.x - lastPos.x);\n        totalY += Math.abs(coords.y - lastPos.y);\n\n        lastPos = coords;\n\n        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {\n          return;\n        }\n\n        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.\n        if (totalY > totalX) {\n          // Allow native scrolling to take over.\n          active = false;\n          if (eventHandlers['cancel']) {\n            eventHandlers['cancel'](event);\n          }\n          return;\n        } else {\n          // Prevent the browser from scrolling.\n          event.preventDefault();\n          if (eventHandlers['move']) {\n            eventHandlers['move'](coords, event);\n          }\n        }\n      });\n\n      element.on(getEvents(pointerTypes, 'end'), function (event) {\n        if (!active) return;\n        active = false;\n        if (eventHandlers['end']) {\n          eventHandlers['end'](getCoordinates(event), event);\n        }\n      });\n    }\n  };\n}]);\n\n/* global ngTouch: false,\n  nodeName_: false\n*/\n\nvar ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement', function ($parse, $timeout, $rootElement) {\n  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.\n  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.\n  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click\n  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.\n\n  var ACTIVE_CLASS_NAME = 'ng-click-active';\n  var lastPreventedTime;\n  var touchCoordinates;\n  var lastLabelClickCoordinates;\n\n  function hit(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;\n  }\n\n  // Checks a list of allowable regions against a click location.\n  // Returns true if the click should be allowed.\n  // Splices out the allowable region from the list after it has been used.\n  function checkAllowableRegions(touchCoordinates, x, y) {\n    for (var i = 0; i < touchCoordinates.length; i += 2) {\n      if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {\n        touchCoordinates.splice(i, i + 2);\n        return true; // allowable region\n      }\n    }\n    return false; // No allowable region; bust it.\n  }\n\n  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick\n  // was called recently.\n  function onClick(event) {\n    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {\n      return; // Too old.\n    }\n\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label\n    // and on the input element). Depending on the exact browser, this second click we don't want\n    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label\n    // click event\n    if (x < 1 && y < 1) {\n      return; // offscreen\n    }\n    if (lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {\n      return; // input click triggered by label click\n    }\n    // reset label click coordinates on first subsequent click\n    if (lastLabelClickCoordinates) {\n      lastLabelClickCoordinates = null;\n    }\n    // remember label click coordinates to prevent click busting of trigger click event on input\n    if (nodeName_(event.target) === 'label') {\n      lastLabelClickCoordinates = [x, y];\n    }\n\n    // Look for an allowable region containing this click.\n    // If we find one, that means it was created by touchstart and not removed by\n    // preventGhostClick, so we don't bust it.\n    if (checkAllowableRegions(touchCoordinates, x, y)) {\n      return;\n    }\n\n    // If we didn't find an allowable region, bust the click.\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Blur focused form elements\n    if (event.target && event.target.blur) {\n      event.target.blur();\n    }\n  }\n\n  // Global touchstart handler that creates an allowable region for a click event.\n  // This allowable region can be removed by preventGhostClick if we want to bust it.\n  function onTouchStart(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    touchCoordinates.push(x, y);\n\n    $timeout(function () {\n      // Remove the allowable region.\n      for (var i = 0; i < touchCoordinates.length; i += 2) {\n        if (touchCoordinates[i] === x && touchCoordinates[i + 1] === y) {\n          touchCoordinates.splice(i, i + 2);\n          return;\n        }\n      }\n    }, PREVENT_DURATION, false);\n  }\n\n  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a\n  // zone around the touchstart where clicks will get busted.\n  function preventGhostClick(x, y) {\n    if (!touchCoordinates) {\n      $rootElement[0].addEventListener('click', onClick, true);\n      $rootElement[0].addEventListener('touchstart', onTouchStart, true);\n      touchCoordinates = [];\n    }\n\n    lastPreventedTime = Date.now();\n\n    checkAllowableRegions(touchCoordinates, x, y);\n  }\n\n  // Actual linking function.\n  return function (scope, element, attr) {\n    var clickHandler = $parse(attr.ngClick),\n        tapping = false,\n        tapElement,\n        // Used to blur the element after a tap.\n    startTime,\n        // Used to check if the tap was held too long.\n    touchStartX,\n        touchStartY;\n\n    function resetState() {\n      tapping = false;\n      element.removeClass(ACTIVE_CLASS_NAME);\n    }\n\n    element.on('touchstart', function (event) {\n      tapping = true;\n      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.\n      // Hack for Safari, which can target text nodes instead of containers.\n      if (tapElement.nodeType === 3) {\n        tapElement = tapElement.parentNode;\n      }\n\n      element.addClass(ACTIVE_CLASS_NAME);\n\n      startTime = Date.now();\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n      var e = touches[0];\n      touchStartX = e.clientX;\n      touchStartY = e.clientY;\n    });\n\n    element.on('touchcancel', function (event) {\n      resetState();\n    });\n\n    element.on('touchend', function (event) {\n      var diff = Date.now() - startTime;\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches : originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n      var e = touches[0];\n      var x = e.clientX;\n      var y = e.clientY;\n      var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));\n\n      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {\n        // Call preventGhostClick so the clickbuster will catch the corresponding click.\n        preventGhostClick(x, y);\n\n        // Blur the focused element (the button, probably) before firing the callback.\n        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.\n        // I couldn't get anything to work reliably on Android Chrome.\n        if (tapElement) {\n          tapElement.blur();\n        }\n\n        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {\n          element.triggerHandler('click', [event]);\n        }\n      }\n\n      resetState();\n    });\n\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n    // something else nearby.\n    element.onclick = function (event) {};\n\n    // Actual click handler.\n    // There are three different kinds of clicks, only two of which reach this point.\n    // - On desktop browsers without touch events, their clicks will always come here.\n    // - On mobile browsers, the simulated \"fast\" click will call this.\n    // - But the browser's follow-up slow click will be \"busted\" before it reaches this handler.\n    // Therefore it's safe to use this directive on both mobile and desktop.\n    element.on('click', function (event, touchend) {\n      scope.$apply(function () {\n        clickHandler(scope, { $event: touchend || event });\n      });\n    });\n\n    element.on('mousedown', function (event) {\n      element.addClass(ACTIVE_CLASS_NAME);\n    });\n\n    element.on('mousemove mouseup', function (event) {\n      element.removeClass(ACTIVE_CLASS_NAME);\n    });\n  };\n}];\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc directive\n * @name ngSwipeLeft\n *\n * @description\n * Specify custom behavior when an element is swiped to the left on a touchscreen device.\n * A leftward swipe is a quick, right-to-left slide of the finger.\n * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * To disable the mouse click and drag functionality, add `ng-swipe-disable-mouse` to\n * the `ng-swipe-left` or `ng-swipe-right` DOM Element.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate\n * upon left swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeLeftExample\" deps=\"angular-touch.js\" name=\"ng-swipe-left\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeLeftExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\n/**\n * @ngdoc directive\n * @name ngSwipeRight\n *\n * @description\n * Specify custom behavior when an element is swiped to the right on a touchscreen device.\n * A rightward swipe is a quick, left-to-right slide of the finger.\n * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate\n * upon right swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeRightExample\" deps=\"angular-touch.js\" name=\"ng-swipe-right\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeRightExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nfunction makeSwipeDirective(directiveName, direction, eventName) {\n  ngTouch.directive(directiveName, ['$parse', '$swipe', function ($parse, $swipe) {\n    // The maximum vertical delta for a swipe should be less than 75px.\n    var MAX_VERTICAL_DISTANCE = 75;\n    // Vertical distance should not be more than a fraction of the horizontal distance.\n    var MAX_VERTICAL_RATIO = 0.3;\n    // At least a 30px lateral motion is necessary for a swipe.\n    var MIN_HORIZONTAL_DISTANCE = 30;\n\n    return function (scope, element, attr) {\n      var swipeHandler = $parse(attr[directiveName]);\n\n      var startCoords, valid;\n\n      function validSwipe(coords) {\n        // Check that it's within the coordinates.\n        // Absolute vertical distance must be within tolerances.\n        // Horizontal distance, we take the current X - the starting X.\n        // This is negative for leftward swipes and positive for rightward swipes.\n        // After multiplying by the direction (-1 for left, +1 for right), legal swipes\n        // (ie. same direction as the directive wants) will have a positive delta and\n        // illegal ones a negative delta.\n        // Therefore this delta must be positive, and larger than the minimum.\n        if (!startCoords) return false;\n        var deltaY = Math.abs(coords.y - startCoords.y);\n        var deltaX = (coords.x - startCoords.x) * direction;\n        return valid && // Short circuit for already-invalidated swipes.\n        deltaY < MAX_VERTICAL_DISTANCE && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && deltaY / deltaX < MAX_VERTICAL_RATIO;\n      }\n\n      var pointerTypes = ['touch'];\n      if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {\n        pointerTypes.push('mouse');\n      }\n      $swipe.bind(element, {\n        'start': function start(coords, event) {\n          startCoords = coords;\n          valid = true;\n        },\n        'cancel': function cancel(event) {\n          valid = false;\n        },\n        'end': function end(coords, event) {\n          if (validSwipe(coords)) {\n            scope.$apply(function () {\n              element.triggerHandler(eventName);\n              swipeHandler(scope, { $event: event });\n            });\n          }\n        }\n      }, pointerTypes);\n    };\n  }]);\n}\n\n// Left is negative X-coordinate, right is positive.\nmakeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');\nmakeSwipeDirective('ngSwipeRight', 1, 'swiperight');\n\nexports.default = ngTouch;\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// sliderinput.min.js","module.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1 translate='{{vm.$state.current.name}}'></h1>\\n\\t<p>{{'SliderInputDesc'|translate}}</p>\\n</section>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Install' | translate}}</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"bash\\\">\\nnpm install fancyui --save\\n</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Inject_Module'|translate}}</h2>\\n</section>\\n\\n<div class=\\\"example-block no-border\\\">\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nimport sliderinputComponent from './sliderinput.component';\\nimport {RangeInput} from 'fancyui';\\nexport default angular.module('sliderInput', [\\n  RangeInput.name\\n])\\n.component('sliderInput', sliderinputComponent);\\n</div>\\n</div>\\n\\n\\n<h2>{{'Example'|translate}}</h2>\\n\\n<div class=\\\"example-block\\\">\\n\\t<div class=\\\"bs-example\\\">\\n\\t\\t<div class=\\\"range-container\\\">\\n\\t\\t\\t<div class=\\\"range-controller\\\">\\n\\t\\t\\t\\t<div class=\\\"ffan-range ffan-range--default\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\">\\n\\t\\t\\t\\t\\t<div class=\\\"ffan-range__range\\\" end=\\\"{{_c}}\\\" ></div>\\n\\t\\t\\t\\t\\t<div class=\\\"ffan-range__thumb\\\" ng-model=\\\"_c\\\" name=\\\"input\\\"></div>\\n\\t\\t\\t\\t</div>\\n\\t\\t\\t</div>\\n\\n\\t\\t\\t<div class=\\\"range-input\\\">\\n\\t\\t\\t\\t<input type=\\\"number\\\" class=\\\"form-control\\\" ng-model=\\\"_c\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\"> M\\n\\t\\t\\t</div>\\n\\t\\t</div>\\n\\t</div>\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<div class=\\\"range-container\\\">\\n  <div class=\\\"range-controller\\\">\\n    <div class=\\\"ffan-range ffan-range--default\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\">\\n    <div class=\\\"ffan-range__range\\\" end=\\\"{{_c}}\\\" ></div>\\n    <div class=\\\"ffan-range__thumb\\\" ng-model=\\\"_c\\\" name=\\\"input\\\"></div>\\n  </div>\\n  </div>\\n  <div class=\\\"range-input\\\">\\n    <input type=\\\"number\\\" class=\\\"form-control\\\" ng-model=\\\"_c\\\" min=\\\"0\\\" max=\\\"1024\\\" step=\\\"1\\\"> M\\n  </div>\\n</div>\\n</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Options'|translate}}</h2>\\n\\t<table class=\\\"demo-table\\\">\\n\\t\\t<thead>\\n\\t\\t<tr>\\n\\t\\t\\t<th>{{'Param'|translate}}</th>\\n\\t\\t\\t<th>{{'Description'|translate}}</th>\\n\\t\\t\\t<th>{{'Type'|translate}}</th>\\n\\t\\t\\t<th>{{'Optional'|translate}}</th>\\n\\t\\t\\t<th>{{'DefaultValue'|translate}}</th>\\n\\t\\t</tr>\\n\\t\\t</thead>\\n\\t\\t<tbody>\\n\\t\\t<tr>\\n\\t\\t\\t<td>min</td>\\n\\t\\t\\t<td>min value</td>\\n\\t\\t\\t<td>number</td>\\n\\t\\t\\t<td>—</td>\\n\\t\\t\\t<td>0</td>\\n\\t\\t</tr>\\n\\t\\t<tr>\\n\\t\\t\\t<td>max</td>\\n\\t\\t\\t<td>max value</td>\\n\\t\\t\\t<td>number</td>\\n\\t\\t\\t<td>—</td>\\n\\t\\t\\t<td>100</td>\\n\\t\\t</tr>\\n\\t\\t<tr>\\n\\t\\t\\t<td>step</td>\\n\\t\\t\\t<td>step number</td>\\n\\t\\t\\t<td>number</td>\\n\\t\\t\\t<td>—</td>\\n\\t\\t\\t<td>1</td>\\n\\t\\t</tr>\\n\\t\\t</tbody>\\n\\t</table>\\n</section>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/app/components/sliderinput/sliderinput.html\n// module id = 1013\n// module chunks = 27","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./sliderinput.less\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./sliderinput.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./sliderinput.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/app/components/sliderinput/sliderinput.less\n// module id = 1081\n// module chunks = 27","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./range.less\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./range.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/less-loader/index.js!./range.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./lib/Rangeinput/range.less\n// module id = 1103\n// module chunks = 27","import sliderinputComponent from './sliderinput.component.js';\nimport RangeInput from '../../../../lib/Rangeinput/index.js';\n\nexport default angular.module('sliderInput', [\n\t\tRangeInput.name\n])\n.component('sliderInput', sliderinputComponent);\n\n\n\n// WEBPACK FOOTER //\n// ./example/app/components/sliderinput/sliderinput.js","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".range-controller {\\n  width: 70%;\\n  display: inline-block;\\n  vertical-align: middle;\\n}\\n.range-input {\\n  width: 20%;\\n  display: inline-block;\\n  vertical-align: middle;\\n  margin-left: 10px;\\n}\\n.range-input input {\\n  width: 60%;\\n  display: inline-block;\\n  margin-right: 5px;\\n}\\n\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/less-loader!./example/app/components/sliderinput/sliderinput.less\n// module id = 711\n// module chunks = 27","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"/* =ffan.Range\\n-----------------------------------------------------------------------------*/\\n.ffan-range {\\n  position: relative;\\n  display: block;\\n}\\n.ffan-range:after {\\n  position: absolute;\\n  left: 0;\\n  right: 0;\\n  display: block;\\n  content: '';\\n  z-index: 4;\\n}\\n.ffan-range__thumb {\\n  position: absolute;\\n  cursor: pointer;\\n  z-index: 5;\\n}\\n.ffan-range__range {\\n  position: absolute;\\n  height: 100%;\\n  left: 0;\\n  right: 100%;\\n  z-index: 6;\\n}\\n/* =ffan.Range default style\\n-----------------------------------------------------------------------------*/\\n.ffan-range--default {\\n  height: 20px;\\n  margin-right: 10px;\\n}\\n.ffan-range--default:after,\\n.ffan-range--default .ffan-range__range {\\n  height: 9px;\\n  border-radius: 3px;\\n  top: 5px;\\n  right: -10px;\\n}\\n.ffan-range--default .ffan-range__range {\\n  border-radius: 3px 0 0 3px;\\n}\\n.ffan-range--default:after {\\n  background: #e5e5e5;\\n}\\n.ffan-range--default .ffan-range__thumb {\\n  width: 10px;\\n  height: 20px;\\n  background: #10a793;\\n  border-radius: 3px;\\n}\\n.ffan-range--default .ffan-range__thumb:hover {\\n  background: #10a793;\\n}\\n.ffan-range--default .ffan-range__range {\\n  background: #1fbba6;\\n}\\n.echarts-container {\\n  float: none;\\n  height: 150px;\\n}\\n.echarts {\\n  width: 100%;\\n  height: 100%;\\n  display: block;\\n}\\n\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/less-loader!./lib/Rangeinput/range.less\n// module id = 733\n// module chunks = 27","import template from './sliderinput.html';\nimport controller from './sliderinput.controller.js';\nimport './sliderinput.less';\n\nexport default {\n  restrict: 'E',\n  bindings: {},\n  template,\n  controller,\n  controllerAs: 'vm'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./example/app/components/sliderinput/sliderinput.component.js","/**\n * (description)\n *\n * @author yourname\n */\n\nexport default class SliderinputController {\n\tconstructor($document,$state) {\n\t\t'ngInject';\n\t\tthis.$state = $state;\n\n\t}\n}\n\n\n// WEBPACK FOOTER //\n// ./example/app/components/sliderinput/sliderinput.controller.js","\n  /**\n   * rangeInput\n   */\n\nimport './range.less';\nimport touch from '../touch';\n\nexport default  angular.module('rangeInput', [touch.name]).value('ffanRangeConfig', {})\n    .controller('ffanRangeController', function ffanRangeCtrl($element) {\n      this.element = $element;\n      this.min = 0;\n      this.max = 100;\n      this.step = 1;\n    })\n\t  \n    .directive('ffanRange', function () {\n      return {\n        restrict: 'EAC',\n        controller: 'ffanRangeController',\n        compile: function (tElement) {\n          if (tElement.children().length === 0) {\n            // Create a default slider for design purpose.\n\n            if (!tElement.attr('class') && tElement.attr('class') !== '') {\n              tElement.addClass('ffan-range--default');\n            }\n\n            tElement.append(\n              // Use a virtual scope key to allow\n                '<div class=\"ffan-range__thumb\" ng-model=\"__' + Math.random().toString(36).substring(7) + '\"></div>' \n            );\n          }\n\n          return function (scope, iElement, iAttrs, controller) {\n\n            if (!iElement.hasClass('ffan-range')) {\n              iElement.addClass('ffan-range');\n            }\n\n            ////////////////////////////////////////////////////////////////////\n            // OBSERVERS\n            ////////////////////////////////////////////////////////////////////\n\n            // Observe the min attr (default 0)\n            iAttrs.$observe('min', function (newVal) {\n              controller.min = +newVal;\n              controller.min = !isNaN(controller.min) ? controller.min : 0;\n              scope.$emit('global min changed');\n            });\n\n            // Observe the max attr (default 100)\n            iAttrs.$observe('max', function (newVal) {\n              controller.max = +newVal;\n              controller.max = !isNaN(controller.max) ? controller.max : 100;\n              scope.$emit('global max changed');\n            });\n\n            // Observe the step attr (default 1)\n            iAttrs.$observe('step', function (newVal) {\n              controller.step = +newVal;\n              controller.step = !isNaN(controller.step) && controller.step > 0 ? controller.step : 1;\n              scope.$emit('global step changed');\n            });\n\n          };\n        }\n      };\n    })\n\n    .directive('ffanRangeRange', function () {\n      return {\n        restrict: 'EAC',\n        require: '^ffanRange',\n        scope: { start: '@', end: '@' },\n        link: function (scope, iElement, iAttrs, controller) {\n\n          if (!iElement.hasClass('ffan-range__range')) {\n            iElement.addClass('ffan-range__range');\n          }\n\n          ////////////////////////////////////////////////////////////////////\n          // OBSERVERS\n          ////////////////////////////////////////////////////////////////////\n\n          // Observe the start attr (default 0%)\n          iAttrs.$observe('start', function (newVal) {\n            var val = !isNaN(+newVal) ? +newVal : 0;\n            val = (val - controller.min ) / (controller.max - controller.min) * 100;\n            // TODO add half of th width of the targeted thumb ([ng-model='+ iAttrs.$attr.start + '])\n            // TODO force width 0 if (left + right === 100 )\n            iElement.css('left', val + '%');\n          });\n\n          // Observe the min attr (default 100%)\n          iAttrs.$observe('end', function (newVal) {\n            // Don't display the range if no attr are specified\n            var displayed = angular.isDefined(iAttrs.start) || angular.isDefined(iAttrs.end);\n            var val = !isNaN(+newVal) ? +newVal : displayed ? 100 : 0;\n            val = (val - controller.min ) / (controller.max - controller.min) * 100;\n            // TODO add half of th width of the targeted thumb ([ng-model='+ iAttrs.$attr.end + '])\n            // TODO force width 0 if (left + right === 100 )\n            iElement.css('right', (100 - val) + '%');\n          });\n\n        }\n      };\n    })\n\n    .directive('ffanRangeThumb', function ($swipe) {\n      // Get all the page.\n      var htmlElement = angular.element(document.body.parentElement);\n\n      return {\n        restrict: 'EAC',\n        require: ['^ffanRange', '?ngModel'],\n        link: function (scope, iElement, iAttrs, controller) {\n\n          if (!iElement.hasClass('ffan-range__thumb')) {\n            iElement.addClass('ffan-range__thumb');\n          }\n\n          if (!controller[1]) return;\n          var ngModel = controller[1];\n          var ffanRangeCtrl = controller[0];\n          var animationFrameRequested;\n          var _cache = {\n            min: ffanRangeCtrl.min,\n            max: ffanRangeCtrl.max,\n            step: ffanRangeCtrl.step\n          };\n\n          ////////////////////////////////////////////////////////////////////\n          // UTILS\n          ////////////////////////////////////////////////////////////////////\n\n          function _formatValue(value, min, max, step) {\n            var formattedValue = value;\n            if (min > max) return max;\n            formattedValue = Math.floor(formattedValue / step) * step;\n            formattedValue = Math.max(Math.min(formattedValue, max), min);\n            return formattedValue;\n          }\n\n          function getFormattedValue(value) {\n            var formattedValue = value;\n            formattedValue = _formatValue(formattedValue, _cache.min, _cache.max, _cache.step);\n            return formattedValue;\n          }\n\n          function updateIfChanged(newVal, oldVal) {\n            if (!angular.isUndefined(oldVal) && !isNaN(ngModel.$modelValue) && oldVal !== newVal) {\n              ngModel.$setViewValue(getFormattedValue(ngModel.$modelValue));\n            }\n          }\n\n          ////////////////////////////////////////////////////////////////////\n          // OBSERVERS\n          ////////////////////////////////////////////////////////////////////\n\n          // Observe the min attr (default 0)\n          iAttrs.$observe('min', function observeMin(newVal) {\n            var oldVal = _cache.min;\n            _cache.min = +newVal;\n            _cache.min = !isNaN(_cache.min) ? _cache.min : 0;\n\n            updateIfChanged(_cache.min, oldVal);\n\n            ngModel.$render();\n          });\n          scope.$on('global min changed', function observeGlobalMin() {\n            var oldVal = _cache.min;\n\n            _cache.min = (angular.isDefined(iAttrs.min)) ? _cache.min : ffanRangeCtrl.min;\n            // Secure no NaN here...\n            _cache.min = !isNaN(_cache.min) ? _cache.min : 0;\n\n            updateIfChanged(_cache.min, oldVal);\n            ngModel.$render();\n          });\n\n          // Observe the max attr (default 100)\n          iAttrs.$observe('max', function observeMax(newVal) {\n            var oldVal = _cache.max;\n            _cache.max = +newVal;\n            _cache.max = !isNaN(_cache.max) ? _cache.max : 100;\n\n            updateIfChanged(_cache.max, oldVal);\n\n            ngModel.$render();\n          });\n          scope.$on('global max changed', function observeGlobalMax() {\n            var oldVal = _cache.max;\n\n            _cache.max = (angular.isDefined(iAttrs.max)) ? _cache.max : ffanRangeCtrl.max;\n            // Secure no NaN here...\n            _cache.max = !isNaN(_cache.max) ? _cache.max : 100;\n\n            updateIfChanged(_cache.max, oldVal);\n            ngModel.$render();\n          });\n\n          // Observe the step attr (default 1)\n          iAttrs.$observe('step', function observeStep(newVal) {\n            var oldVal = _cache.step;\n            _cache.step = +newVal;\n            _cache.step = !isNaN(_cache.step) && _cache.step > 0 ? _cache.step : 1;\n\n            updateIfChanged(_cache.step, oldVal);\n\n            ngModel.$render();\n          });\n          scope.$on('global step changed', function observeGlobalStep() {\n            var oldVal = _cache.step;\n\n            _cache.step = (angular.isDefined(iAttrs.step)) ? _cache.step : ffanRangeCtrl.step;\n\n            // Secure no NaN here...\n            _cache.step = !isNaN(_cache.step) && _cache.step > 0 ? _cache.step : 1;\n\n            updateIfChanged(_cache.step, oldVal);\n            ngModel.$render();\n          });\n          ////////////////////////////////////////////////////////////////////\n          // RENDERING\n          ////////////////////////////////////////////////////////////////////\n\n          ngModel.$render = function ngModelRender() {\n\n            // Cancel previous rAF call\n            if (animationFrameRequested) {\n              window.cancelAnimationFrame(animationFrameRequested);\n            }\n\n            // Animate the page outside the event\n            animationFrameRequested = window.requestAnimationFrame(function drawFromTheModelValue() {\n              var the_thumb_pos = (ngModel.$viewValue - ffanRangeCtrl.min ) / (ffanRangeCtrl.max - ffanRangeCtrl.min) * 100;\n              the_thumb_pos = the_thumb_pos.toFixed(5);\n              iElement.css('left', the_thumb_pos + '%');\n            });\n          };\n\n          ////////////////////////////////////////////////////////////////////\n          // FORMATTING\n          ////////////////////////////////////////////////////////////////////\n          // Final view format\n          ngModel.$formatters.push(function (value) {\n            return +value;\n          });\n\n          // Checks that it's on the step\n          ngModel.$parsers.push(function stepParser(value) {\n            ngModel.$setValidity('step', true);\n            return Math.floor(value / _cache.step) * _cache.step;\n          });\n          ngModel.$formatters.push(function stepValidator(value) {\n            if (!ngModel.$isEmpty(value) && value !== Math.floor(value / _cache.step) * _cache.step) {\n              ngModel.$setValidity('step', false);\n              return undefined;\n            } else {\n              ngModel.$setValidity('step', true);\n              return value;\n            }\n          });\n\n          // Checks that it's less then the maximum\n          ngModel.$parsers.push(function maxParser(value) {\n            ngModel.$setValidity('max', true);\n            return Math.min(value, _cache.max);\n          });\n          ngModel.$formatters.push(function maxValidator(value) {\n            if (!ngModel.$isEmpty(value) && value > _cache.max) {\n              ngModel.$setValidity('max', false);\n              return undefined;\n            } else {\n              ngModel.$setValidity('max', true);\n              return value;\n            }\n          });\n\n          // Checks that it's more then the minimum\n          ngModel.$parsers.push(function minParser(value) {\n            ngModel.$setValidity('min', true);\n            return Math.max(value, _cache.min);\n          });\n          ngModel.$formatters.push(function minValidator(value) {\n            if (!ngModel.$isEmpty(value) && value < _cache.min) {\n              ngModel.$setValidity('min', false);\n              return undefined;\n            } else {\n              ngModel.$setValidity('min', true);\n              return value;\n            }\n          });\n\n\n          // First check that a number is used\n          ngModel.$formatters.push(function numberValidator(value) {\n            if (ngModel.$isEmpty(value) || angular.isNumber(value)) {\n              ngModel.$setValidity('number', true);\n              return value;\n            } else {\n              ngModel.$setValidity('number', false);\n              return undefined;\n            }\n          });\n\n          ////////////////////////////////////////////////////////////////////\n          // USER EVENT BINDING\n          ////////////////////////////////////////////////////////////////////\n\n          var hasMultipleThumb = 1 < iElement.parent()[0].getElementsByClassName('ffan-range__thumb').length;\n\n          // Bind the click on the bar then you can move it all over the page.\n          $swipe.bind(ffanRangeCtrl.element, {\n\n            start: function (coord, event) {\n\n              if (hasMultipleThumb && event.target !== iElement[0]) {\n                return;\n              }\n\n              $swipe.bind(htmlElement, {\n                start: function (coord, event) {\n                  event.stopPropagation();\n                  event.preventDefault();\n                },\n                move: function (coord) {\n                  _handleMouseEvent(coord);\n                },\n                end: function () {\n                  // Don't preventDefault and stopPropagation\n                  // The html element needs to be free of doing anything !\n                  htmlElement.unbind();\n                }\n              });\n\n              if (!hasMultipleThumb) {\n                // Handle simple click\n                _handleMouseEvent(coord);\n                htmlElement.triggerHandler('touchstart mousedown', event);\n              }\n\n            }\n\n          });\n\n          function _cached_layout_values() {\n\n            if (_cache.time && +new Date() < _cache.time + 1000) {\n              return;\n            } // after ~60 frames\n\n            // track bounding box\n            var track_bb = iElement.parent()[0].getBoundingClientRect();\n\n            _cache.time = +new Date();\n            _cache.trackOrigine = track_bb.left;\n            _cache.trackSize = track_bb.width;\n          }\n\n          function _handleMouseEvent(coord) {\n\n            // Store the mouse position for later\n            _cache.lastPos = coord.x;\n\n            _cached_layout_values();\n\n            var the_thumb_value = ffanRangeCtrl.min + (_cache.lastPos - _cache.trackOrigine) / _cache.trackSize * (ffanRangeCtrl.max - ffanRangeCtrl.min);\n            the_thumb_value = getFormattedValue(the_thumb_value);\n\n            ngModel.$setViewValue(parseFloat(the_thumb_value.toFixed(5)));\n            if (!scope.$root.$$phase) {\n              scope.$root.$apply();\n            }\n            ngModel.$render();\n\n          }\n\n        }\n      };\n    })\n  \n\n\n// WEBPACK FOOTER //\n// ./lib/Rangeinput/index.js","/**\n * ngTouch  \n */\n\nvar ngTouch = angular.module('ffanTouch', []);\n\nngTouch.provider('$touch', $TouchProvider);\n\nfunction nodeName_(element) {\n  return angular.lowercase(element.nodeName || (element[0] && element[0].nodeName));\n}\n\n/**\n * @ngdoc provider\n * @name $touchProvider\n *\n * @description\n * The `$touchProvider` allows enabling / disabling {@link ngTouch.ngClick ngTouch's ngClick directive}.\n */\n$TouchProvider.$inject = ['$provide', '$compileProvider'];\nfunction $TouchProvider($provide, $compileProvider) {\n\n  /**\n   * @ngdoc method\n   * @name  $touchProvider#ngClickOverrideEnabled\n   *\n   * @param {boolean=} enabled update the ngClickOverrideEnabled state if provided, otherwise just return the\n   * current ngClickOverrideEnabled state\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   *\n   * @kind function\n   *\n   * @description\n   * Call this method to enable/disable {@link ngTouch.ngClick ngTouch's ngClick directive}. If enabled,\n   * the default ngClick directive will be replaced by a version that eliminates the 300ms delay for\n   * click events on browser for touch-devices.\n   *\n   * The default is `false`.\n   *\n   */\n  var ngClickOverrideEnabled = false;\n  var ngClickDirectiveAdded = false;\n  // eslint-disable-next-line no-invalid-this\n  this.ngClickOverrideEnabled = function(enabled) {\n    if (angular.isDefined(enabled)) {\n\n      if (enabled && !ngClickDirectiveAdded) {\n        ngClickDirectiveAdded = true;\n\n        // Use this to identify the correct directive in the delegate\n        ngTouchClickDirectiveFactory.$$moduleName = 'ngTouch';\n        $compileProvider.directive('ngClick', ngTouchClickDirectiveFactory);\n\n        $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\n          if (ngClickOverrideEnabled) {\n            // drop the default ngClick directive\n            $delegate.shift();\n          } else {\n            // drop the ngTouch ngClick directive if the override has been re-disabled (because\n            // we cannot de-register added directives)\n            var i = $delegate.length - 1;\n            while (i >= 0) {\n              if ($delegate[i].$$moduleName === 'ngTouch') {\n                $delegate.splice(i, 1);\n                break;\n              }\n              i--;\n            }\n          }\n\n          return $delegate;\n        }]);\n      }\n\n      ngClickOverrideEnabled = enabled;\n      return this;\n    }\n\n    return ngClickOverrideEnabled;\n  };\n\n  /**\n  * @ngdoc service\n  * @name $touch\n  * @kind object\n  *\n  * @description\n  * Provides the {@link ngTouch.$touch#ngClickOverrideEnabled `ngClickOverrideEnabled`} method.\n  *\n  */\n  // eslint-disable-next-line no-invalid-this\n  this.$get = function() {\n    return {\n      /**\n       * @ngdoc method\n       * @name  $touch#ngClickOverrideEnabled\n       *\n       * @returns {*} current value of `ngClickOverrideEnabled` set in the {@link ngTouch.$touchProvider $touchProvider},\n       * i.e. if {@link ngTouch.ngClick ngTouch's ngClick} directive is enabled.\n       *\n       * @kind function\n       */\n      ngClickOverrideEnabled: function() {\n        return ngClickOverrideEnabled;\n      }\n    };\n  };\n\n}\n\n/* global ngTouch: false */\n\n    /**\n     * @ngdoc service\n     * @name $swipe\n     *\n     * @description\n     * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe\n     * behavior, to make implementing swipe-related directives more convenient.\n     *\n     * Requires the {@link ngTouch `ngTouch`} module to be installed.\n     *\n     * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`.\n     *\n     * # Usage\n     * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element\n     * which is to be watched for swipes, and an object with four handler functions. See the\n     * documentation for `bind` below.\n     */\n\nngTouch.factory('$swipe', [function() {\n  // The total distance in any direction before we make the call on swipe vs. scroll.\n  var MOVE_BUFFER_RADIUS = 10;\n\n  var POINTER_EVENTS = {\n    'mouse': {\n      start: 'mousedown',\n      move: 'mousemove',\n      end: 'mouseup'\n    },\n    'touch': {\n      start: 'touchstart',\n      move: 'touchmove',\n      end: 'touchend',\n      cancel: 'touchcancel'\n    },\n    'pointer': {\n      start: 'pointerdown',\n      move: 'pointermove',\n      end: 'pointerup',\n      cancel: 'pointercancel'\n    }\n  };\n\n  function getCoordinates(event) {\n    var originalEvent = event.originalEvent || event;\n    var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n    var e = (originalEvent.changedTouches && originalEvent.changedTouches[0]) || touches[0];\n\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n\n  function getEvents(pointerTypes, eventType) {\n    var res = [];\n    angular.forEach(pointerTypes, function(pointerType) {\n      var eventName = POINTER_EVENTS[pointerType][eventType];\n      if (eventName) {\n        res.push(eventName);\n      }\n    });\n    return res.join(' ');\n  }\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $swipe#bind\n     *\n     * @description\n     * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an\n     * object containing event handlers.\n     * The pointer types that should be used can be specified via the optional\n     * third argument, which is an array of strings `'mouse'`, `'touch'` and `'pointer'`. By default,\n     * `$swipe` will listen for `mouse`, `touch` and `pointer` events.\n     *\n     * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`\n     * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }` and the raw\n     * `event`. `cancel` receives the raw `event` as its single parameter.\n     *\n     * `start` is called on either `mousedown`, `touchstart` or `pointerdown`. After this event, `$swipe` is\n     * watching for `touchmove`, `mousemove` or `pointermove` events. These events are ignored until the total\n     * distance moved in either dimension exceeds a small threshold.\n     *\n     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.\n     * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.\n     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.\n     *   A `cancel` event is sent.\n     *\n     * `move` is called on `mousemove`, `touchmove` and `pointermove` after the above logic has determined that\n     * a swipe is in progress.\n     *\n     * `end` is called when a swipe is successfully completed with a `touchend`, `mouseup` or `pointerup`.\n     *\n     * `cancel` is called either on a `touchcancel` or `pointercancel`  from the browser, or when we begin scrolling\n     * as described above.\n     *\n     */\n    bind: function(element, eventHandlers, pointerTypes) {\n      // Absolute total movement, used to control swipe vs. scroll.\n      var totalX, totalY;\n      // Coordinates of the start position.\n      var startCoords;\n      // Last event's position.\n      var lastPos;\n      // Whether a swipe is active.\n      var active = false;\n\n      pointerTypes = pointerTypes || ['mouse', 'touch', 'pointer'];\n      element.on(getEvents(pointerTypes, 'start'), function(event) {\n        startCoords = getCoordinates(event);\n        active = true;\n        totalX = 0;\n        totalY = 0;\n        lastPos = startCoords;\n        if (eventHandlers['start']) {\n          eventHandlers['start'](startCoords, event);\n        }\n      });\n      var events = getEvents(pointerTypes, 'cancel');\n      if (events) {\n        element.on(events, function(event) {\n          active = false;\n          if (eventHandlers['cancel']) {\n            eventHandlers['cancel'](event);\n          }\n        });\n      }\n\n      element.on(getEvents(pointerTypes, 'move'), function(event) {\n        if (!active) return;\n\n        // Android will send a touchcancel if it thinks we're starting to scroll.\n        // So when the total distance (+ or - or both) exceeds 10px in either direction,\n        // we either:\n        // - On totalX > totalY, we send preventDefault() and treat this as a swipe.\n        // - On totalY > totalX, we let the browser handle it as a scroll.\n\n        if (!startCoords) return;\n        var coords = getCoordinates(event);\n\n        totalX += Math.abs(coords.x - lastPos.x);\n        totalY += Math.abs(coords.y - lastPos.y);\n\n        lastPos = coords;\n\n        if (totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS) {\n          return;\n        }\n\n        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.\n        if (totalY > totalX) {\n          // Allow native scrolling to take over.\n          active = false;\n          if (eventHandlers['cancel']) {\n            eventHandlers['cancel'](event);\n          }\n          return;\n        } else {\n          // Prevent the browser from scrolling.\n          event.preventDefault();\n          if (eventHandlers['move']) {\n            eventHandlers['move'](coords, event);\n          }\n        }\n      });\n\n      element.on(getEvents(pointerTypes, 'end'), function(event) {\n        if (!active) return;\n        active = false;\n        if (eventHandlers['end']) {\n          eventHandlers['end'](getCoordinates(event), event);\n        }\n      });\n    }\n  };\n}]);\n\n/* global ngTouch: false,\n  nodeName_: false\n*/\n\n\nvar ngTouchClickDirectiveFactory = ['$parse', '$timeout', '$rootElement',\n    function($parse, $timeout, $rootElement) {\n  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.\n  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.\n  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click\n  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.\n\n  var ACTIVE_CLASS_NAME = 'ng-click-active';\n  var lastPreventedTime;\n  var touchCoordinates;\n  var lastLabelClickCoordinates;\n\n  function hit(x1, y1, x2, y2) {\n    return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD;\n  }\n\n  // Checks a list of allowable regions against a click location.\n  // Returns true if the click should be allowed.\n  // Splices out the allowable region from the list after it has been used.\n  function checkAllowableRegions(touchCoordinates, x, y) {\n    for (var i = 0; i < touchCoordinates.length; i += 2) {\n      if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {\n        touchCoordinates.splice(i, i + 2);\n        return true; // allowable region\n      }\n    }\n    return false; // No allowable region; bust it.\n  }\n\n  // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick\n  // was called recently.\n  function onClick(event) {\n    if (Date.now() - lastPreventedTime > PREVENT_DURATION) {\n      return; // Too old.\n    }\n\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label\n    // and on the input element). Depending on the exact browser, this second click we don't want\n    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label\n    // click event\n    if (x < 1 && y < 1) {\n      return; // offscreen\n    }\n    if (lastLabelClickCoordinates &&\n        lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y) {\n      return; // input click triggered by label click\n    }\n    // reset label click coordinates on first subsequent click\n    if (lastLabelClickCoordinates) {\n      lastLabelClickCoordinates = null;\n    }\n    // remember label click coordinates to prevent click busting of trigger click event on input\n    if (nodeName_(event.target) === 'label') {\n      lastLabelClickCoordinates = [x, y];\n    }\n\n    // Look for an allowable region containing this click.\n    // If we find one, that means it was created by touchstart and not removed by\n    // preventGhostClick, so we don't bust it.\n    if (checkAllowableRegions(touchCoordinates, x, y)) {\n      return;\n    }\n\n    // If we didn't find an allowable region, bust the click.\n    event.stopPropagation();\n    event.preventDefault();\n\n    // Blur focused form elements\n    if (event.target && event.target.blur) {\n      event.target.blur();\n    }\n  }\n\n\n  // Global touchstart handler that creates an allowable region for a click event.\n  // This allowable region can be removed by preventGhostClick if we want to bust it.\n  function onTouchStart(event) {\n    var touches = event.touches && event.touches.length ? event.touches : [event];\n    var x = touches[0].clientX;\n    var y = touches[0].clientY;\n    touchCoordinates.push(x, y);\n\n    $timeout(function() {\n      // Remove the allowable region.\n      for (var i = 0; i < touchCoordinates.length; i += 2) {\n        if (touchCoordinates[i] === x && touchCoordinates[i + 1] === y) {\n          touchCoordinates.splice(i, i + 2);\n          return;\n        }\n      }\n    }, PREVENT_DURATION, false);\n  }\n\n  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a\n  // zone around the touchstart where clicks will get busted.\n  function preventGhostClick(x, y) {\n    if (!touchCoordinates) {\n      $rootElement[0].addEventListener('click', onClick, true);\n      $rootElement[0].addEventListener('touchstart', onTouchStart, true);\n      touchCoordinates = [];\n    }\n\n    lastPreventedTime = Date.now();\n\n    checkAllowableRegions(touchCoordinates, x, y);\n  }\n\n  // Actual linking function.\n  return function(scope, element, attr) {\n    var clickHandler = $parse(attr.ngClick),\n        tapping = false,\n        tapElement,  // Used to blur the element after a tap.\n        startTime,   // Used to check if the tap was held too long.\n        touchStartX,\n        touchStartY;\n\n    function resetState() {\n      tapping = false;\n      element.removeClass(ACTIVE_CLASS_NAME);\n    }\n\n    element.on('touchstart', function(event) {\n      tapping = true;\n      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.\n      // Hack for Safari, which can target text nodes instead of containers.\n      if (tapElement.nodeType === 3) {\n        tapElement = tapElement.parentNode;\n      }\n\n      element.addClass(ACTIVE_CLASS_NAME);\n\n      startTime = Date.now();\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent];\n      var e = touches[0];\n      touchStartX = e.clientX;\n      touchStartY = e.clientY;\n    });\n\n    element.on('touchcancel', function(event) {\n      resetState();\n    });\n\n    element.on('touchend', function(event) {\n      var diff = Date.now() - startTime;\n\n      // Use jQuery originalEvent\n      var originalEvent = event.originalEvent || event;\n      var touches = (originalEvent.changedTouches && originalEvent.changedTouches.length) ?\n          originalEvent.changedTouches :\n          ((originalEvent.touches && originalEvent.touches.length) ? originalEvent.touches : [originalEvent]);\n      var e = touches[0];\n      var x = e.clientX;\n      var y = e.clientY;\n      var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));\n\n      if (tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE) {\n        // Call preventGhostClick so the clickbuster will catch the corresponding click.\n        preventGhostClick(x, y);\n\n        // Blur the focused element (the button, probably) before firing the callback.\n        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.\n        // I couldn't get anything to work reliably on Android Chrome.\n        if (tapElement) {\n          tapElement.blur();\n        }\n\n        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {\n          element.triggerHandler('click', [event]);\n        }\n      }\n\n      resetState();\n    });\n\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n    // something else nearby.\n    element.onclick = function(event) { };\n\n    // Actual click handler.\n    // There are three different kinds of clicks, only two of which reach this point.\n    // - On desktop browsers without touch events, their clicks will always come here.\n    // - On mobile browsers, the simulated \"fast\" click will call this.\n    // - But the browser's follow-up slow click will be \"busted\" before it reaches this handler.\n    // Therefore it's safe to use this directive on both mobile and desktop.\n    element.on('click', function(event, touchend) {\n      scope.$apply(function() {\n        clickHandler(scope, {$event: (touchend || event)});\n      });\n    });\n\n    element.on('mousedown', function(event) {\n      element.addClass(ACTIVE_CLASS_NAME);\n    });\n\n    element.on('mousemove mouseup', function(event) {\n      element.removeClass(ACTIVE_CLASS_NAME);\n    });\n\n  };\n}];\n\n/* global ngTouch: false */\n\n/**\n * @ngdoc directive\n * @name ngSwipeLeft\n *\n * @description\n * Specify custom behavior when an element is swiped to the left on a touchscreen device.\n * A leftward swipe is a quick, right-to-left slide of the finger.\n * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * To disable the mouse click and drag functionality, add `ng-swipe-disable-mouse` to\n * the `ng-swipe-left` or `ng-swipe-right` DOM Element.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate\n * upon left swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeLeftExample\" deps=\"angular-touch.js\" name=\"ng-swipe-left\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeLeftExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\n/**\n * @ngdoc directive\n * @name ngSwipeRight\n *\n * @description\n * Specify custom behavior when an element is swiped to the right on a touchscreen device.\n * A rightward swipe is a quick, left-to-right slide of the finger.\n * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag\n * too.\n *\n * Requires the {@link ngTouch `ngTouch`} module to be installed.\n *\n * @element ANY\n * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate\n * upon right swipe. (Event object is available as `$event`)\n *\n * @example\n    <example module=\"ngSwipeRightExample\" deps=\"angular-touch.js\" name=\"ng-swipe-right\">\n      <file name=\"index.html\">\n        <div ng-show=\"!showActions\" ng-swipe-left=\"showActions = true\">\n          Some list content, like an email in the inbox\n        </div>\n        <div ng-show=\"showActions\" ng-swipe-right=\"showActions = false\">\n          <button ng-click=\"reply()\">Reply</button>\n          <button ng-click=\"delete()\">Delete</button>\n        </div>\n      </file>\n      <file name=\"script.js\">\n        angular.module('ngSwipeRightExample', ['ngTouch']);\n      </file>\n    </example>\n */\n\nfunction makeSwipeDirective(directiveName, direction, eventName) {\n  ngTouch.directive(directiveName, ['$parse', '$swipe', function($parse, $swipe) {\n    // The maximum vertical delta for a swipe should be less than 75px.\n    var MAX_VERTICAL_DISTANCE = 75;\n    // Vertical distance should not be more than a fraction of the horizontal distance.\n    var MAX_VERTICAL_RATIO = 0.3;\n    // At least a 30px lateral motion is necessary for a swipe.\n    var MIN_HORIZONTAL_DISTANCE = 30;\n\n    return function(scope, element, attr) {\n      var swipeHandler = $parse(attr[directiveName]);\n\n      var startCoords, valid;\n\n      function validSwipe(coords) {\n        // Check that it's within the coordinates.\n        // Absolute vertical distance must be within tolerances.\n        // Horizontal distance, we take the current X - the starting X.\n        // This is negative for leftward swipes and positive for rightward swipes.\n        // After multiplying by the direction (-1 for left, +1 for right), legal swipes\n        // (ie. same direction as the directive wants) will have a positive delta and\n        // illegal ones a negative delta.\n        // Therefore this delta must be positive, and larger than the minimum.\n        if (!startCoords) return false;\n        var deltaY = Math.abs(coords.y - startCoords.y);\n        var deltaX = (coords.x - startCoords.x) * direction;\n        return valid && // Short circuit for already-invalidated swipes.\n            deltaY < MAX_VERTICAL_DISTANCE &&\n            deltaX > 0 &&\n            deltaX > MIN_HORIZONTAL_DISTANCE &&\n            deltaY / deltaX < MAX_VERTICAL_RATIO;\n      }\n\n      var pointerTypes = ['touch'];\n      if (!angular.isDefined(attr['ngSwipeDisableMouse'])) {\n        pointerTypes.push('mouse');\n      }\n      $swipe.bind(element, {\n        'start': function(coords, event) {\n          startCoords = coords;\n          valid = true;\n        },\n        'cancel': function(event) {\n          valid = false;\n        },\n        'end': function(coords, event) {\n          if (validSwipe(coords)) {\n            scope.$apply(function() {\n              element.triggerHandler(eventName);\n              swipeHandler(scope, {$event: event});\n            });\n          }\n        }\n      }, pointerTypes);\n    };\n  }]);\n}\n\n// Left is negative X-coordinate, right is positive.\nmakeSwipeDirective('ngSwipeLeft', -1, 'swipeleft');\nmakeSwipeDirective('ngSwipeRight', 1, 'swiperight');\n\nexport default ngTouch;\n\n\n// WEBPACK FOOTER //\n// ./lib/touch/index.js"],"sourceRoot":""}