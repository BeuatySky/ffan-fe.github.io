{"version":3,"sources":["webpack:///table.min.js","webpack:///./example/app/components/table/table.html","webpack:///./example/app/components/table/table.less?3e47","webpack:///./example/app/components/table/table.js","webpack:///./lib/ffanTable/index.js?861b","webpack:///./example/app/components/table/table.less","webpack:///./example/app/components/table/table.component.js","webpack:///./example/app/components/table/table.controller.js"],"names":["webpackJsonp","1017","module","exports","1085","__webpack_require__","content","i","locals","320","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_tableComponent","_tableComponent2","_index","_index2","angular","name","component","649","_typeof","Symbol","iterator","constructor","prototype","params","settings","ngTableEventsChannel","$rootScope","addChangeEvent","eventName","target","fnName","charAt","toUpperCase","substring","event","createEventSubscriptionFn","createPublishEventFn","extend","handler","eventSelector","identity","scope","arguments","length","isFunction","$new","isObject","requiredPublisher","publisher","$on","isNullInstance","eventArgs","rest","fnArgs","concat","apply","this","Array","slice","call","$broadcast","array","n","events","factory","$inject","ngTableFilterConfigProvider","init","resetConfigs","config","defaultConfig","setConfig","customConfig","mergeConfig","aliasUrls","ngTableFilterConfig","getTemplateUrl","filterValue","filterKey","id","indexOf","service","getUrlForAlias","aliasName","defaultBaseUrl","defaultExt","publicConfig","get","copy","enumerable","$get","provider","ngTableDefaultGetDataProvider","ngTableDefaultGetData","$filter","getFilterFn","filterOptions","filterFn","filterFilterName","getOrderByFn","sortingFilterName","applyFilter","data","hasFilter","filter","filterKeys","keys","parsedFilter","reduce","result","key","setPath","filterComparator","applyPaging","pagedData","page","count","total","applySort","orderBy","orderByFn","getData","options","defaultDataOptions","dataOptions","fData","orderedData","path","split","ret","lastKey","parentPathKeys","forEach","hasOwnProperty","ngTableGetDataBcShim","$q","createWrapper","getDataFn","$defer","defer","pData","promise","buildColumn","column","defaultScope","columns","extendedCol","create","defaults","createDefaults","prop","undefined","prop1","getterSetter","isScopeLike","assign","$scope","getterFn","context","$column","$columns","class","createGetterSetter","groupable","filterData","noop","headerTemplateURL","headerTitle","sortable","show","title","titleAlt","initialValue","newValue","object","$log","ngTableDefaults","isNumber","isNaN","parseFloat","isFinite","NgTableParams","baseParameters","baseSettings","parseGroup","group","defaultSort","groupOptions","sortDirection","isString","grp","convertSortToOrderBy","sorting","push","createComparableParams","groupSortDirection","hasGlobalSearchFieldChanges","currentVal","$","previousVal","prevParamsMemento","equals","optimizeFilterDelay","filterDelay","defaultFilterOptions","filterDelayThreshold","defaultSettingsFns","runGetData","getDataFnAdaptor","when","self","runGetGroups","getGroupsFn","getGroupsFnAdaptor","getGroups","runInterceptorPipeline","fetchFn","interceptors","interceptor","thenFn","response","bind","rejectFn","responseError","reject","then","reason","getDefaultSettingFns","dataset","groupFn","groupField","item","getPath","originalDataOptions","adaptedFn","gotData","groups","groupName","$hideRows","isExpanded","ks","errParamsMemento","isCommittedDataset","initialEvents","log","debugMode","debug","filterLayout","defaultGroupOptions","parameters","newParameters","parseParamsFromUrl","isDefined","reverse","len","v","newSettings","isArray","originalDataset","hasDatasetChanged","fireEvent","publishDatasetChanged","significantFilter","groupArray","sortArray","isSortBy","field","direction","generatePagesArray","currentPage","totalItems","pageSize","maxBlocks","maxPage","maxPivotPages","minPage","numPages","pages","Math","ceil","type","number","max","active","current","round","paginationMaxBlocks","paginationMinBlocks","min","isDataReloadRequired","hasGroup","hasFilterChanges","previousFilter","url","asString","collectValue","pairs","encodeURIComponent","isSignificantValue","subkey","pname","reload","$loading","oldData","publishAfterReloadData","reloadPages","$emit","hasErrorState","currentPages","oldPages","newPages","publishPagesChanged","counts","sortingIndicator","publishAfterCreated","controller","$timeout","$parse","$compile","$attrs","$element","ngTableColumn","onDataReloadStatusChange","newStatus","currentParams","delayFilter","setupFilterRowBindingsToInternalScope","showFilter","$parent","$watch","show_filter","hasVisibleFilterColumn","disableFilter","$filterRow","disabled","setupGroupRowBindingsToInternalScope","$groupRow","showGroup","showGroupGetter","getVisibleColumns","c","some","predicate","found","commonInit","bindDataToScope","newDatapage","visibleColumns","$groups","visibleColumnCount","$data","bindPagesToScope","isMyPublisher","onAfterReloadData","onPagesChanged","timer","callback","ms","cancel","newParams","oldParams","compileDirectiveTemplates","hasClass","templates","header","templateHeader","pagination","templatePagination","addClass","headerTemplate","theadFound","children","e","tagName","element","document","createElement","attr","prepend","paginationTemplate","ng-table-pagination","template-url","after","loadFilterData","buildColumns","col","parseNgTableDynamicExpr","parts","tableParams","Error","setupBindingsToInternalScope","tableParamsExpr","tableParamsGetter","isUndefined","paramsModel","directive","restrict","priority","compile","dataRow","groupRow","rows","find","tr","el","getAttrValue","setAttrValue","parsedAttribute","expr","localValue","getter","parsedExpr","titleExpr","attrs","ngTable","tElement","row","showExpr","ngTableDynamic","$watchCollection","newCols","ngTableColumnsBinding","linkFn","setter","newColumns","shallowClone","require","link","templateUrl","replace","pubParams","template","ng-include","append","ngTableFilterRowController","getFilterCellCss","layout","size","width","parseInt","getFilterPlaceholderValue","placeholder","ngTableFilterRow","ngTableGroupRowController","getGroupables","getGroupTitle","groupBy","isSelectedGroup","toggleDetail","setGroup","changeSortDirection","newDirection","$selGroup","findGroupColumn","groupKey","groupableCols","groupFns","existingGroupCol","$selGroupTitle","groupedColumn","ngTableGroupRow","controllerAs","ngTableSorterRowController","sortBy","parsedSortable","inverseSort","sortingParams","ctrlKey","metaKey","ngTableSorterRow","ngTableSelectFilterDs","ngTableSelectFilterDsController","bindDataSource","getSelectListData","hasEmptyOption","unshift","$selectData","isMatch","run","$templateCache","put","715","896","_table","_table2","_tableController","_tableController2","bindings","897","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","props","descriptor","configurable","writable","protoProps","staticProps","TableController","$state","datas","viewName","lastStatus","lastNO","lastFailNO","getDataList"],"mappings":"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","file":"table.min.js","sourcesContent":["webpackJsonp([28],{\n\n/***/ 1017:\n/***/ function(module, exports) {\n\nmodule.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1 translate='{{vm.$state.current.name}}'></h1>\\n\\t<p>{{'TableDes'|translate}}</p>\\n</section>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Install' | translate}}</h2>\\n\\t<p>{{'Install_FancyUI'|translate}}</p>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n\\t<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"bash\\\">npm install fancyui --save</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Inject_Module'|translate}}</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"javascript\\\">\\nimport { ffanTable } from 'fancyui';\\n\\nexport default angular.module('tableDemo', [\\n  ffanTable.name\\n])</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Example'|translate}}</h2>\\n</section>\\n\\n<div class=\\\"table-container\\\">\\n\\t<div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t\\t\\t<thead>\\n\\t\\t\\t<tr>\\n\\t\\t\\t\\t<th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</thead>\\n\\t\\t\\t<tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t\\t\\t<td>{{row.name}}</td>\\n\\t\\t\\t\\t<td>{{row.viewName}}</td>\\n\\t\\t\\t\\t<td>{{row.lastStatus}}</td>\\n\\t\\t\\t\\t<td>{{row.lastNO}}</td>\\n\\t\\t\\t\\t<td>{{row.lastFailNO}}</td>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</tbody>\\n\\t\\t</table>\\n\\n\\t\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<p class=\\\"text-danger\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n\\t</div>\\n</div>\\n\\n<h3>\\n\\tview\\n</h3>\\n<div class=\\\"example-block\\\">\\n\\t\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<div class=\\\"table-container\\\">\\n  <div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t  <thead>\\n\\t\\t<tr>\\n\\t\\t  <th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t  <th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t</tr>\\n\\t  </thead>\\n\\t  <tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t    <tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t  <td>{{row.name}}</td>\\n\\t\\t  <td>{{row.viewName}}</td>\\n\\t\\t  <td>{{row.lastStatus}}</td>\\n\\t\\t  <td>{{row.lastNO}}</td>\\n\\t\\t  <td>{{row.lastFailNO}}</td>\\n\\t    </tr>\\n\\t  </tbody>\\n\\t</table>\\n\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t  <p class=\\\"text-warning\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t</div>\\n\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n  </div>\\n</div>\\n</div>\\n</div>\\n\\n<h3>\\n\\tcontroller\\n</h3>\\n\\n<div class=\\\"example-block\\\">\\n\\t\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nconstructor(NgTableParams) {\\n  \\\"ngInject\\\";\\n  this.NgTableParams = NgTableParams;\\n  this.data = {\\n      \\\"total\\\": 85,\\n      \\\"datas\\\": [\\n        {\\n          \\\"name\\\": 'fix_web',\\n          \\\"viewName\\\": \\\"tool-wd\\\",\\n          \\\"lastStatus\\\": \\\"SUCCESS\\\",\\n          \\\"lastNO\\\": \\\"#10\\\",\\n          \\\"lastFailNO\\\": \\\"#4\\\"\\n         },\\n         {\\n           \\\"name\\\": 'fix_web',\\n           \\\"viewName\\\": \\\"tool-wd\\\",\\n           \\\"lastStatus\\\": \\\"SUCCESS\\\",\\n           \\\"lastNO\\\": \\\"#10\\\",\\n           \\\"lastFailNO\\\": \\\"#4\\\"\\n         }\\n       ]\\n    };\\n  this.init();\\n}\\n\\ninit(){\\n  var self = this;\\n    self.tableParams = new this.NgTableParams({\\n      page: 1,\\n      count: 5\\n    }, {\\n    counts: [],\\n      getData: function (params) {\\n      params.total(self.data.total);\\n      return self.data.datas;\\n    }\\n  });\\n}</div>\\n</div>\\n\"\n\n/***/ },\n\n/***/ 1085:\n/***/ function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(715);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(2)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/***/ },\n\n/***/ 320:\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n});\n\nvar _tableComponent = __webpack_require__(896);\n\nvar _tableComponent2 = _interopRequireDefault(_tableComponent);\n\nvar _index = __webpack_require__(649);\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = angular.module('tableDemo', [_index2.default.name]).component('tableDemo', _tableComponent2.default);\n\n/***/ },\n\n/***/ 649:\n/***/ function(module, exports) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function () {\n  /**\n   * @ngdoc module\n   * @name ngTable\n   * @description ngTable: Table + Angular JS\n   */\n  angular.module('ngTable', []);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc object\n   * @name ngTableDefaultParams\n   * @module ngTable\n   * @description Default Parameters for ngTable\n   */\n  angular.module('ngTable').value('ngTableDefaults', {\n    params: {},\n    settings: {}\n  });\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').factory('ngTableEventsChannel', ngTableEventsChannel);\n\n  ngTableEventsChannel.$inject = ['$rootScope'];\n\n  /**\n   * @ngdoc service\n   * @name ngTableEventsChannel\n   * @description strongly typed pub/sub for `NgTableParams`\n   *\n   * Supported events:\n   *\n   * * afterCreated - raised when a new instance of `NgTableParams` has finished being constructed\n   * * afterReloadData - raised when the `reload` event has finished loading new data\n   * * datasetChanged - raised when `settings` receives a new data array\n   * * pagesChanged - raised when a new pages array has been generated\n   */\n  function ngTableEventsChannel($rootScope) {\n\n    var events = {};\n    events = addChangeEvent('afterCreated', events);\n    events = addChangeEvent('afterReloadData', events);\n    events = addChangeEvent('datasetChanged', events);\n    events = addChangeEvent('pagesChanged', events);\n    return events;\n\n    //////////\n\n    function addChangeEvent(eventName, target) {\n      var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n      var event = {};\n      event['on' + fnName] = createEventSubscriptionFn(eventName);\n      event['publish' + fnName] = createPublishEventFn(eventName);\n      return angular.extend(target, event);\n    }\n\n    function createEventSubscriptionFn(eventName) {\n\n      return function subscription(handler /*[, eventSelector or $scope][, eventSelector]*/) {\n        var eventSelector = angular.identity;\n        var scope = $rootScope;\n\n        if (arguments.length === 2) {\n          if (angular.isFunction(arguments[1].$new)) {\n            scope = arguments[1];\n          } else {\n            eventSelector = arguments[1];\n          }\n        } else if (arguments.length > 2) {\n          scope = arguments[1];\n          eventSelector = arguments[2];\n        }\n\n        // shorthand for subscriber to only receive events from a specific publisher instance\n        if (angular.isObject(eventSelector)) {\n          var requiredPublisher = eventSelector;\n          eventSelector = function eventSelector(publisher) {\n            return publisher === requiredPublisher;\n          };\n        }\n\n        return scope.$on('ngTable:' + eventName, function (event, params /*, ...args*/) {\n          // don't send events published by the internal NgTableParams created by ngTableController\n          if (params.isNullInstance) return;\n\n          var eventArgs = rest(arguments, 2);\n          var fnArgs = [params].concat(eventArgs);\n          if (eventSelector.apply(this, fnArgs)) {\n            handler.apply(this, fnArgs);\n          }\n        });\n      };\n    }\n\n    function createPublishEventFn(eventName) {\n      return function publish() /*args*/{\n        var fnArgs = ['ngTable:' + eventName].concat(Array.prototype.slice.call(arguments));\n        $rootScope.$broadcast.apply($rootScope, fnArgs);\n      };\n    }\n\n    function rest(array, n) {\n      return Array.prototype.slice.call(array, n == null ? 1 : n);\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').provider('ngTableFilterConfig', ngTableFilterConfigProvider);\n\n  ngTableFilterConfigProvider.$inject = [];\n\n  function ngTableFilterConfigProvider() {\n    var config;\n    var defaultConfig = {\n      defaultBaseUrl: 'ng-table/filters/',\n      defaultExt: '.html',\n      aliasUrls: {}\n    };\n\n    this.$get = ngTableFilterConfig;\n    this.resetConfigs = resetConfigs;\n    this.setConfig = setConfig;\n\n    init();\n\n    /////////\n\n    function init() {\n      resetConfigs();\n    }\n\n    function resetConfigs() {\n      config = defaultConfig;\n    }\n\n    function setConfig(customConfig) {\n      var mergeConfig = angular.extend({}, config, customConfig);\n      mergeConfig.aliasUrls = angular.extend({}, config.aliasUrls, customConfig.aliasUrls);\n      config = mergeConfig;\n    }\n\n    /////////\n\n    ngTableFilterConfig.$inject = [];\n\n    function ngTableFilterConfig() {\n\n      var publicConfig;\n\n      var service = {\n        config: publicConfig,\n        getTemplateUrl: getTemplateUrl,\n        getUrlForAlias: getUrlForAlias\n      };\n      Object.defineProperty(service, \"config\", {\n        get: function get() {\n          return publicConfig = publicConfig || angular.copy(config);\n        },\n        enumerable: true\n      });\n\n      return service;\n\n      /////////\n\n      function getTemplateUrl(filterValue, filterKey) {\n        if (angular.isObject(filterValue)) {\n          filterValue = filterValue.id;\n        }\n        if (filterValue.indexOf('/') !== -1) {\n          return filterValue;\n        }\n\n        return service.getUrlForAlias(filterValue, filterKey);\n      }\n\n      function getUrlForAlias(aliasName /*, filterKey*/) {\n        return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;\n      }\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').provider('ngTableDefaultGetData', ngTableDefaultGetDataProvider);\n\n  ngTableDefaultGetDataProvider.$inject = [];\n\n  /**\n   * @ngdoc provider\n   * @name ngTableDefaultGetDataProvider\n   * @description Allows for the configuration of the ngTableDefaultGetData service.\n   *\n   * Set filterFilterName to the name of a angular filter that knows how to apply the values returned by\n   * `NgTableParams.filter()` to restrict an array of data.\n   *\n   * Set sortingFilterName to the name of a angular filter that knows how to apply the values returned by\n   * `NgTableParams.orderBy()` to sort an array of data.\n   *\n   * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`\n   * filters respectively\n   */\n  function ngTableDefaultGetDataProvider() {\n    var provider = this;\n    provider.$get = ngTableDefaultGetData;\n    provider.filterFilterName = 'filter';\n    provider.sortingFilterName = 'orderBy';\n\n    ///////////\n\n    ngTableDefaultGetData.$inject = ['$filter'];\n\n    /**\n     * @ngdoc service\n     * @name ngTableDefaultGetData\n     * @description A default implementation of the getData function that will apply the `filter`, `orderBy` and\n     * paging values from the `NgTableParams` instance supplied to the data array supplied.\n     *\n     * The outcome will be to return the resulting array and to assign the total item count after filtering\n     * to the `total` of the `NgTableParams` instance supplied\n     */\n    function ngTableDefaultGetData($filter) {\n\n      var defaultDataOptions = { applyFilter: true, applySort: true, applyPaging: true };\n\n      getData.applyPaging = applyPaging;\n      getData.getFilterFn = getFilterFn;\n      getData.getOrderByFn = getOrderByFn;\n\n      return getData;\n\n      function getFilterFn(params) {\n        var filterOptions = params.settings().filterOptions;\n        if (angular.isFunction(filterOptions.filterFn)) {\n          return filterOptions.filterFn;\n        } else {\n          return $filter(filterOptions.filterFilterName || provider.filterFilterName);\n        }\n      }\n\n      function getOrderByFn() /*params*/{\n        return $filter(provider.sortingFilterName);\n      }\n\n      function applyFilter(data, params) {\n        if (!params.hasFilter()) {\n          return data;\n        }\n\n        var filter = params.filter(true);\n        var filterKeys = Object.keys(filter);\n        var parsedFilter = filterKeys.reduce(function (result, key) {\n          result = setPath(result, filter[key], key);\n          return result;\n        }, {});\n        var filterFn = getFilterFn(params);\n        return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n      }\n\n      function applyPaging(data, params) {\n        var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n        params.total(data.length); // set total for recalc pagination\n        return pagedData;\n      }\n\n      function applySort(data, params) {\n        var orderBy = params.orderBy();\n        var orderByFn = getOrderByFn(params);\n        return orderBy.length ? orderByFn(data, orderBy) : data;\n      }\n\n      function getData(data, params) {\n        if (data == null) {\n          return [];\n        }\n\n        var options = angular.extend({}, defaultDataOptions, params.settings().dataOptions);\n\n        var fData = options.applyFilter ? applyFilter(data, params) : data;\n        var orderedData = options.applySort ? applySort(fData, params) : fData;\n        return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n      }\n\n      // Sets the value at any depth in a nested object based on the path\n      // note: adapted from: underscore-contrib#setPath\n      function setPath(obj, value, path) {\n        var keys = path.split('.');\n        var ret = obj;\n        var lastKey = keys[keys.length - 1];\n        var target = ret;\n\n        var parentPathKeys = keys.slice(0, keys.length - 1);\n        parentPathKeys.forEach(function (key) {\n          if (!target.hasOwnProperty(key)) {\n            target[key] = {};\n          }\n          target = target[key];\n        });\n\n        target[lastKey] = value;\n        return ret;\n      }\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  // todo: remove shim after an acceptable depreciation period\n\n  angular.module('ngTable').factory('ngTableGetDataBcShim', ngTableGetDataBcShim);\n\n  ngTableGetDataBcShim.$inject = ['$q'];\n\n  function ngTableGetDataBcShim($q) {\n\n    return createWrapper;\n\n    function createWrapper(getDataFn) {\n      return function getDataShim() /*args*/{\n        var $defer = $q.defer();\n        var pData = getDataFn.apply(this, [$defer].concat(Array.prototype.slice.call(arguments)));\n        if (!pData) {\n          // If getData resolved the $defer, and didn't promise us data,\n          //   create a promise from the $defer. We need to return a promise.\n          pData = $defer.promise;\n        }\n        return pData;\n      };\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc service\n   * @name ngTableColumn\n   * @module ngTable\n   * @description\n   * Service to construct a $column definition used by {@link ngTable ngTable} directive\n   */\n  angular.module('ngTable').factory('ngTableColumn', [function () {\n\n    return {\n      buildColumn: buildColumn\n    };\n\n    //////////////\n\n    /**\n     * @ngdoc method\n     * @name ngTableColumn#buildColumn\n     * @description Creates a $column for use within a header template\n     *\n     * @param {Object} column an existing $column or simple column data object\n     * @param {Scope} defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n     * @param {Array} columns a reference to the columns array to make available on the context supplied to the\n     * $column getter methods\n     * @returns {Object} a $column object\n     */\n    function buildColumn(column, defaultScope, columns) {\n      // note: we're not modifying the original column object. This helps to avoid unintended side affects\n      var extendedCol = Object.create(column);\n      var defaults = createDefaults();\n      for (var prop in defaults) {\n        if (extendedCol[prop] === undefined) {\n          extendedCol[prop] = defaults[prop];\n        }\n        if (!angular.isFunction(extendedCol[prop])) {\n          // wrap raw field values with \"getter\" functions\n          // - this is to ensure consistency with how ngTable.compile builds columns\n          // - note that the original column object is being \"proxied\"; this is important\n          //   as it ensure that any changes to the original object will be returned by the \"getter\"\n          (function (prop1) {\n            var getterSetter = function getterSetter() /*[value] || [$scope, locals]*/{\n              if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                getterSetter.assign(null, arguments[0]);\n              } else {\n                return column[prop1];\n              }\n            };\n            getterSetter.assign = function ($scope, value) {\n              column[prop1] = value;\n            };\n            extendedCol[prop1] = getterSetter;\n          })(prop);\n        }\n        (function (prop1) {\n          // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n          var getterFn = extendedCol[prop1];\n          extendedCol[prop1] = function () {\n            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n              getterFn.assign(null, arguments[0]);\n            } else {\n              var scope = arguments[0] || defaultScope;\n              var context = Object.create(scope);\n              angular.extend(context, {\n                $column: extendedCol,\n                $columns: columns\n              });\n              return getterFn.call(column, context);\n            }\n          };\n          if (getterFn.assign) {\n            extendedCol[prop1].assign = getterFn.assign;\n          }\n        })(prop);\n      }\n      return extendedCol;\n    }\n\n    function createDefaults() {\n      return {\n        'class': createGetterSetter(''),\n        filter: createGetterSetter(false),\n        groupable: createGetterSetter(false),\n        filterData: angular.noop,\n        headerTemplateURL: createGetterSetter(false),\n        headerTitle: createGetterSetter(''),\n        sortable: createGetterSetter(false),\n        show: createGetterSetter(true),\n        title: createGetterSetter(''),\n        titleAlt: createGetterSetter('')\n      };\n    }\n\n    function createGetterSetter(initialValue) {\n      var value = initialValue;\n      var getterSetter = function getterSetter() /*[value] || [$scope, locals]*/{\n        if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n          getterSetter.assign(null, arguments[0]);\n        } else {\n          return value;\n        }\n      };\n      getterSetter.assign = function ($scope, newValue) {\n        value = newValue;\n      };\n      return getterSetter;\n    }\n\n    function isScopeLike(object) {\n      return object != null && angular.isFunction(object.$new);\n    }\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc service\n   * @name NgTableParams\n   * @module ngTable\n   * @description Parameters manager for ngTable\n   */\n\n  angular.module('ngTable').factory('NgTableParams', ['$q', '$log', '$filter', 'ngTableDefaults', 'ngTableGetDataBcShim', 'ngTableDefaultGetData', 'ngTableEventsChannel', function ($q, $log, $filter, ngTableDefaults, ngTableGetDataBcShim, ngTableDefaultGetData, ngTableEventsChannel) {\n    var isNumber = function isNumber(n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    };\n    var NgTableParams = function NgTableParams(baseParameters, baseSettings) {\n\n      // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n      // is one of these\n      if (typeof baseParameters === \"boolean\") {\n        this.isNullInstance = true;\n      }\n\n      var self = this,\n          prevParamsMemento,\n          errParamsMemento,\n          isCommittedDataset = false,\n          initialEvents = [],\n          log = function log() {\n        if (settings.debugMode && $log.debug) {\n          $log.debug.apply($log, arguments);\n        }\n      },\n          defaultFilterOptions = {\n        filterComparator: undefined, // look for a substring match in case insensitive way\n        filterDelay: 500,\n        filterDelayThreshold: 10000, // size of dataset array that will trigger the filterDelay being applied\n        filterFilterName: undefined, // when defined overrides ngTableDefaultGetDataProvider.filterFilterName\n        filterFn: undefined, // when defined overrides the filter function that ngTableDefaultGetData uses\n        filterLayout: 'stack' // alternative: 'horizontal'\n      },\n          defaultGroupOptions = {\n        defaultSort: 'asc', // set to 'asc' or 'desc' to apply sorting to groups\n        isExpanded: true\n      },\n          defaultSettingsFns = getDefaultSettingFns();\n\n      this.data = [];\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#parameters\n       * @description Set new parameters or get current parameters\n       *\n       * @param {string} newParameters      New parameters\n       * @param {string} parseParamsFromUrl Flag if parse parameters like in url\n       * @returns {Object} Current parameters or `this`\n       */\n      this.parameters = function (newParameters, parseParamsFromUrl) {\n        parseParamsFromUrl = parseParamsFromUrl || false;\n        if (angular.isDefined(newParameters)) {\n          for (var key in newParameters) {\n            var value = newParameters[key];\n            if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n              var keys = key.split(/\\[(.*)\\]/).reverse();\n              var lastKey = '';\n              for (var i = 0, len = keys.length; i < len; i++) {\n                var name = keys[i];\n                if (name !== '') {\n                  var v = value;\n                  value = {};\n                  value[lastKey = name] = isNumber(v) ? parseFloat(v) : v;\n                }\n              }\n              if (lastKey === 'sorting') {\n                params[lastKey] = {};\n              }\n              params[lastKey] = angular.extend(params[lastKey] || {}, value[lastKey]);\n            } else {\n              if (key === 'group') {\n                params[key] = parseGroup(newParameters[key]);\n              } else {\n                params[key] = isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key];\n              }\n            }\n          }\n          log('ngTable: set parameters', params);\n          return this;\n        }\n        return params;\n      };\n\n      function parseGroup(group) {\n        var defaultSort = settings.groupOptions && settings.groupOptions.defaultSort;\n        if (angular.isFunction(group)) {\n          if (group.sortDirection == null) {\n            group.sortDirection = defaultSort;\n          }\n          return group;\n        } else if (angular.isString(group)) {\n          var grp = {};\n          grp[group] = defaultSort;\n          return grp;\n        } else if (angular.isObject(group)) {\n          for (var key in group) {\n            if (group[key] == null) {\n              group[key] = defaultSort;\n            }\n          }\n          return group;\n        } else {\n          return group;\n        }\n      }\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#settings\n       * @description Set new settings for table\n       *\n       * @param {string} newSettings New settings or undefined\n       * @returns {Object} Current settings or `this`\n       */\n      this.settings = function (newSettings) {\n        if (angular.isDefined(newSettings)) {\n\n          // todo: don't modify newSettings object: this introduces unexpected side effects;\n          // instead take a copy of newSettings\n\n          if (newSettings.filterOptions) {\n            newSettings.filterOptions = angular.extend({}, settings.filterOptions, newSettings.filterOptions);\n          }\n          if (newSettings.groupOptions) {\n            newSettings.groupOptions = angular.extend({}, settings.groupOptions, newSettings.groupOptions);\n          }\n\n          if (angular.isArray(newSettings.dataset)) {\n            //auto-set the total from passed in dataset\n            newSettings.total = newSettings.dataset.length;\n          }\n\n          // todo: remove the backwards compatibility shim and the following two if blocks\n          if (newSettings.getData && newSettings.getData.length > 1) {\n            // support the old getData($defer, params) api\n            newSettings.getDataFnAdaptor = ngTableGetDataBcShim;\n          }\n          if (newSettings.getGroups && newSettings.getGroups.length > 2) {\n            // support the old getGroups($defer, params) api\n            newSettings.getGroupsFnAdaptor = ngTableGetDataBcShim;\n          }\n\n          var originalDataset = settings.dataset;\n          settings = angular.extend(settings, newSettings);\n\n          if (angular.isArray(newSettings.dataset)) {\n            optimizeFilterDelay();\n          }\n\n          // note: using != as want null and undefined to be treated the same\n          var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && newSettings.dataset != originalDataset;\n          if (hasDatasetChanged) {\n            if (isCommittedDataset) {\n              this.page(1); // reset page as a new dataset has been supplied\n            }\n            isCommittedDataset = false;\n\n            var fireEvent = function fireEvent() {\n              ngTableEventsChannel.publishDatasetChanged(self, newSettings.dataset, originalDataset);\n            };\n\n            if (initialEvents) {\n              initialEvents.push(fireEvent);\n            } else {\n              fireEvent();\n            }\n          }\n          log('ngTable: set settings', settings);\n          return this;\n        }\n        return settings;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#page\n       * @description If parameter page not set return current page else set current page\n       *\n       * @param {string} page Page number\n       * @returns {Object|Number} Current page or `this`\n       */\n      this.page = function (page) {\n        return angular.isDefined(page) ? this.parameters({\n          'page': page\n        }) : params.page;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#total\n       * @description If parameter total not set return current quantity else set quantity\n       *\n       * @param {string} total Total quantity of items\n       * @returns {Object|Number} Current page or `this`\n       */\n      this.total = function (total) {\n        return angular.isDefined(total) ? this.settings({\n          'total': total\n        }) : settings.total;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#count\n       * @description If parameter count not set return current count per page else set count per page\n       *\n       * @param {string} count Count per number\n       * @returns {Object|Number} Count per page or `this`\n       */\n      this.count = function (count) {\n        // reset to first page because can be blank page\n        return angular.isDefined(count) ? this.parameters({\n          'count': count,\n          'page': 1\n        }) : params.count;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#filter\n       * @description If 'filter' parameter not set return current filter else set current filter\n       *\n       * Note: when assigning a new filter, {@link NgTableParams#page page} will be set to 1\n       *\n       * @param {Object|Boolean} filter 'object': new filter to assign or\n       * 'true': to return the current filter minus any insignificant values (null,  undefined and empty string); or\n       * 'falsey': to return the current filter \"as is\"\n       * @returns {Object} Current filter or `this`\n       */\n      this.filter = function (filter) {\n        if (angular.isDefined(filter) && angular.isObject(filter)) {\n          return this.parameters({\n            'filter': filter,\n            'page': 1\n          });\n        } else if (filter === true) {\n          var keys = Object.keys(params.filter);\n          var significantFilter = {};\n          for (var i = 0; i < keys.length; i++) {\n            var filterValue = params.filter[keys[i]];\n            if (filterValue != null && filterValue !== '') {\n              significantFilter[keys[i]] = filterValue;\n            }\n          }\n          return significantFilter;\n        } else {\n          return params.filter;\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#group\n       * @description If 'group' parameter is not set, return current grouping. Otherwise set current group.\n       *\n       * @param {string|Function|Object} group New group field\n       * @param {string} sortDirection Optional direction that the list of groups should be sorted\n       * @returns {Object} Current grouping or `this`\n       */\n      this.group = function (group, sortDirection) {\n        if (!angular.isDefined(group)) {\n          return params.group;\n        }\n\n        var newParameters = {\n          page: 1\n        };\n        if (angular.isFunction(group) && angular.isDefined(sortDirection)) {\n          group.sortDirection = sortDirection;\n          newParameters.group = group;\n        } else if (angular.isDefined(group) && angular.isDefined(sortDirection)) {\n          var groupArray = {};\n          groupArray[group] = sortDirection;\n          newParameters.group = groupArray;\n        } else {\n          newParameters.group = group;\n        }\n        this.parameters(newParameters);\n        return this;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#sorting\n       * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.\n       *\n       * @param {string} sorting New sorting\n       * @returns {Object} Current sorting or `this`\n       */\n      this.sorting = function (sorting) {\n        if (arguments.length == 2) {\n          var sortArray = {};\n          sortArray[sorting] = arguments[1];\n          this.parameters({\n            'sorting': sortArray\n          });\n          return this;\n        }\n        return angular.isDefined(sorting) ? this.parameters({\n          'sorting': sorting\n        }) : params.sorting;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#isSortBy\n       * @description Checks sort field\n       *\n       * @param {string} field     Field name\n       * @param {string} direction Optional direction of sorting ('asc' or 'desc')\n       * @returns {Array} Return true if field sorted by direction\n       */\n      this.isSortBy = function (field, direction) {\n        if (direction !== undefined) {\n          return angular.isDefined(params.sorting[field]) && params.sorting[field] == direction;\n        } else {\n          return angular.isDefined(params.sorting[field]);\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#orderBy\n       * @description Return object of sorting parameters for angular filter\n       *\n       * @returns {Array} Array like: [ '-name', '+age' ]\n       */\n      this.orderBy = function () {\n        return convertSortToOrderBy(params.sorting);\n      };\n\n      function convertSortToOrderBy(sorting) {\n        var result = [];\n        for (var column in sorting) {\n          result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n        }\n        return result;\n      }\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#generatePagesArray\n       * @description Generate array of pages\n       *\n       * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n       *\n       * @param {boolean} currentPage which page must be active\n       * @param {boolean} totalItems  Total quantity of items\n       * @param {boolean} pageSize    Quantity of items on page\n       * @param {number} maxBlocks    Quantity of blocks for pagination\n       * @returns {Array} Array of pages\n       */\n      this.generatePagesArray = function (currentPage, totalItems, pageSize, maxBlocks) {\n        if (!arguments.length) {\n          currentPage = this.page();\n          totalItems = this.total();\n          pageSize = this.count();\n        }\n\n        var maxPage, maxPivotPages, minPage, numPages, pages;\n        maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n\n        pages = [];\n        numPages = Math.ceil(totalItems / pageSize);\n        if (numPages > 1) {\n          pages.push({\n            type: 'prev',\n            number: Math.max(1, currentPage - 1),\n            active: currentPage > 1\n          });\n          pages.push({\n            type: 'first',\n            number: 1,\n            active: currentPage > 1,\n            current: currentPage === 1\n          });\n          maxPivotPages = Math.round((settings.paginationMaxBlocks - settings.paginationMinBlocks) / 2);\n          minPage = Math.max(2, currentPage - maxPivotPages);\n          maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n          minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n          var i = minPage;\n          while (i <= maxPage) {\n            if (i === minPage && i !== 2 || i === maxPage && i !== numPages - 1) {\n              pages.push({\n                type: 'more',\n                active: false\n              });\n            } else {\n              pages.push({\n                type: 'page',\n                number: i,\n                active: currentPage !== i,\n                current: currentPage === i\n              });\n            }\n            i++;\n          }\n          pages.push({\n            type: 'last',\n            number: numPages,\n            active: currentPage !== numPages,\n            current: currentPage === numPages\n          });\n          pages.push({\n            type: 'next',\n            number: Math.min(numPages, currentPage + 1),\n            active: currentPage < numPages\n          });\n        }\n        return pages;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#isDataReloadRequired\n       * @description Return true when a change to this `NgTableParams` instance should require the reload method\n       * to be run so as to ensure the data presented to the user reflects the `NgTableParams`\n       *\n       * Note that this method will return false when the reload method has run but fails. In this case\n       * `hasErrorState` will return true.\n       */\n      this.isDataReloadRequired = function () {\n        // note: using != as want to treat null and undefined the same\n        return !isCommittedDataset || !angular.equals(createComparableParams(), prevParamsMemento) || hasGlobalSearchFieldChanges();\n      };\n\n      function createComparableParams() {\n        var result = { params: params };\n        if (angular.isFunction(params.group)) {\n          result.groupSortDirection = params.group.sortDirection;\n        }\n        return result;\n      }\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasFilter\n       * @description Determines if NgTableParams#filter has significant filter value(s)\n       * (any value except null, undefined, or empty string)\n       * @returns {Boolean} true when NgTableParams#filter has at least one significant field value\n       */\n      this.hasFilter = function () {\n        return Object.keys(this.filter(true)).length > 0;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasGroup\n       * @description Determines if at least one group has been set\n       * @returns {Boolean}\n       */\n      this.hasGroup = function (group, sortDirection) {\n        if (group == null) {\n          return angular.isFunction(params.group) || Object.keys(params.group).length > 0;\n        }\n\n        if (angular.isFunction(group)) {\n          if (sortDirection == null) {\n            return params.group === group;\n          } else {\n            return params.group === group && group.sortDirection === sortDirection;\n          }\n        } else {\n          if (sortDirection == null) {\n            return Object.keys(params.group).indexOf(group) !== -1;\n          } else {\n            return params.group[group] === sortDirection;\n          }\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasFilterChanges\n       * @description Return true when a change to `NgTableParams.filters`require the reload method\n       * to be run so as to ensure the data presented to the user reflects these filters\n       */\n      this.hasFilterChanges = function () {\n        var previousFilter = prevParamsMemento && prevParamsMemento.params.filter;\n        return !angular.equals(params.filter, previousFilter) || hasGlobalSearchFieldChanges();\n      };\n\n      function hasGlobalSearchFieldChanges() {\n        var currentVal = params.filter && params.filter.$;\n        var previousVal = prevParamsMemento && prevParamsMemento.params.filter && prevParamsMemento.params.filter.$;\n        return !angular.equals(currentVal, previousVal);\n      }\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#url\n       * @description Return groups for table grouping\n       *\n       * @param {boolean} asString flag indicates return array of string or object\n       * @returns {Array} If asString = true will be return array of url string parameters else key-value object\n       */\n      this.url = function (asString) {\n        asString = asString || false;\n        var pairs = asString ? [] : {};\n        for (var key in params) {\n          if (params.hasOwnProperty(key)) {\n            var item = params[key],\n                name = encodeURIComponent(key);\n            if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === \"object\") {\n              for (var subkey in item) {\n                if (isSignificantValue(item[subkey], key)) {\n                  var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                  collectValue(item[subkey], pname);\n                }\n              }\n            } else if (!angular.isFunction(item) && isSignificantValue(item, key)) {\n              collectValue(item, name);\n            }\n          }\n        }\n        return pairs;\n\n        function collectValue(value, key) {\n          if (asString) {\n            pairs.push(key + \"=\" + encodeURIComponent(value));\n          } else {\n            pairs[key] = encodeURIComponent(value);\n          }\n        }\n\n        function isSignificantValue(value, key) {\n          return key === \"group\" ? true : angular.isDefined(value) && value !== \"\";\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#reload\n       * @description Reload table data\n       */\n      this.reload = function () {\n        var self = this,\n            pData = null;\n\n        settings.$loading = true;\n\n        prevParamsMemento = angular.copy(createComparableParams());\n        isCommittedDataset = true;\n\n        if (self.hasGroup()) {\n          pData = runInterceptorPipeline(runGetGroups);\n        } else {\n          pData = runInterceptorPipeline(runGetData);\n        }\n\n        log('ngTable: reload data');\n\n        var oldData = self.data;\n        return pData.then(function (data) {\n          settings.$loading = false;\n          errParamsMemento = null;\n\n          self.data = data;\n          // note: I think it makes sense to publish this event even when data === oldData\n          // subscribers can always set a filter to only receive the event when data !== oldData\n          ngTableEventsChannel.publishAfterReloadData(self, data, oldData);\n          self.reloadPages();\n\n          // todo: remove after acceptable depreciation period\n          if (settings.$scope) {\n            settings.$scope.$emit('ngTableAfterReloadData');\n          }\n\n          return data;\n        }).catch(function (reason) {\n          errParamsMemento = prevParamsMemento;\n          // \"rethrow\"\n          return $q.reject(reason);\n        });\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasErrorState\n       * @description Return true when an attempt to `reload` the current `parameter` values have resulted in\n       * a failure\n       *\n       * This method will continue to return true until the reload is successfully called or when the\n       * `parameter` values have changed\n       */\n      this.hasErrorState = function () {\n        return !!(errParamsMemento && angular.equals(errParamsMemento, createComparableParams()));\n      };\n\n      function optimizeFilterDelay() {\n        // don't debounce by default filter input when working with small synchronous datasets\n        if (settings.filterOptions.filterDelay === defaultFilterOptions.filterDelay && settings.total <= settings.filterOptions.filterDelayThreshold && settings.getData === defaultSettingsFns.getData) {\n          settings.filterOptions.filterDelay = 0;\n        }\n      }\n\n      this.reloadPages = function () {\n        var currentPages;\n        return function () {\n          var oldPages = currentPages;\n          var newPages = self.generatePagesArray(self.page(), self.total(), self.count());\n          if (!angular.equals(oldPages, newPages)) {\n            currentPages = newPages;\n            ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);\n          }\n        };\n      }();\n\n      function runGetData() {\n        var getDataFn = settings.getDataFnAdaptor(settings.getData);\n        return $q.when(getDataFn.call(settings, self));\n      }\n\n      function runGetGroups() {\n        var getGroupsFn = settings.getGroupsFnAdaptor(settings.getGroups);\n        return $q.when(getGroupsFn.call(settings, self));\n      }\n\n      function runInterceptorPipeline(fetchFn) {\n        var interceptors = settings.interceptors || [];\n\n        return interceptors.reduce(function (result, interceptor) {\n          var thenFn = interceptor.response && interceptor.response.bind(interceptor) || $q.when;\n          var rejectFn = interceptor.responseError && interceptor.responseError.bind(interceptor) || $q.reject;\n          return result.then(function (data) {\n            return thenFn(data, self);\n          }, function (reason) {\n            return rejectFn(reason, self);\n          });\n        }, fetchFn());\n      }\n\n      function getDefaultSettingFns() {\n\n        return {\n          getDataFnAdaptor: angular.identity,\n          getGroupsFnAdaptor: angular.identity,\n          getData: getData,\n          getGroups: getGroups\n        };\n\n        /**\n         * @ngdoc method\n         * @name settings#getData\n         * @description Returns the data to display in the table\n         *\n         * Called by `NgTableParams` whenever it considers new data is to be loaded\n         *\n         * @param {Object} params the `NgTableParams` requesting data\n         */\n        function getData(params) {\n          return ngTableDefaultGetData(params.settings().dataset, params);\n        }\n\n        /**\n         * @ngdoc method\n         * @name settings#getGroups\n         * @description Return groups of data to display in the table\n         *\n         * Called by `NgTableParams` whenever it considers new data is to be loaded\n         * and when a `group` value has been assigned\n         *\n         * @param {Object} params the `NgTableParams` requesting data\n         */\n        function getGroups(params) {\n\n          var group = params.group();\n          var groupFn;\n          var sortDirection = undefined;\n          if (angular.isFunction(group)) {\n            groupFn = group;\n            sortDirection = group.sortDirection;\n          } else {\n            // currently support for only one group implemented\n            var groupField = Object.keys(group)[0];\n            sortDirection = group[groupField];\n            groupFn = function groupFn(item) {\n              return getPath(item, groupField);\n            };\n          }\n\n          var settings = params.settings();\n          var originalDataOptions = settings.dataOptions;\n          settings.dataOptions = { applyPaging: false };\n          var adaptedFn = settings.getDataFnAdaptor(settings.getData);\n          var gotData = $q.when(adaptedFn.call(settings, params));\n          return gotData.then(function (data) {\n            var groups = {};\n            angular.forEach(data, function (item) {\n              var groupName = groupFn(item);\n              groups[groupName] = groups[groupName] || {\n                data: [],\n                $hideRows: !settings.groupOptions.isExpanded,\n                value: groupName\n              };\n              groups[groupName].data.push(item);\n            });\n            var result = [];\n            for (var i in groups) {\n              result.push(groups[i]);\n            }\n            if (sortDirection) {\n              var orderByFn = ngTableDefaultGetData.getOrderByFn();\n              var orderBy = convertSortToOrderBy({\n                value: sortDirection\n              });\n              result = orderByFn(result, orderBy);\n            }\n\n            return ngTableDefaultGetData.applyPaging(result, params);\n          }).finally(function () {\n            // restore the real options\n            settings.dataOptions = originalDataOptions;\n          });\n        }\n\n        function getPath(obj, ks) {\n          // origianl source https://github.com/documentcloud/underscore-contrib\n\n          if (typeof ks == \"string\") ks = ks.split(\".\");\n\n          // If we have reached an undefined property\n          // then stop executing and return undefined\n          if (obj === undefined) return void 0;\n\n          // If the path array has no more elements, we've reached\n          // the intended property and return its value\n          if (ks.length === 0) return obj;\n\n          // If we still have elements in the path array and the current\n          // value is null, stop executing and return undefined\n          if (obj === null) return void 0;\n\n          return getPath(obj[ks[0]], ks.slice(1));\n        }\n      }\n\n      var params = {\n        page: 1,\n        count: 10,\n        filter: {},\n        sorting: {},\n        group: {}\n      };\n      angular.extend(params, ngTableDefaults.params);\n\n      /**\n       * @ngdoc object\n       * @name settings\n       * @module ngTable\n       * @description configuration settings for `NgTableParams`\n       */\n      var settings = {\n        // todo: remove $scope after acceptable depreciation period as no longer required\n        $scope: null, // set by ngTable controller\n        $loading: false,\n        dataset: null, //allows data to be set when table is initialized\n        total: 0,\n        defaultSort: 'desc',\n        filterOptions: angular.copy(defaultFilterOptions),\n        groupOptions: angular.copy(defaultGroupOptions),\n        counts: [10, 25, 50, 100],\n        interceptors: [],\n        paginationMaxBlocks: 11,\n        paginationMinBlocks: 5,\n        sortingIndicator: 'span'\n      };\n\n      this.settings(defaultSettingsFns);\n      this.settings(ngTableDefaults.settings);\n      this.settings(baseSettings);\n      this.parameters(baseParameters, true);\n\n      ngTableEventsChannel.publishAfterCreated(this);\n      // run events during construction after the initial create event. That way a consumer\n      // can subscribe to all events for a table without \"dropping\" an event\n      angular.forEach(initialEvents, function (event) {\n        event();\n      });\n      initialEvents = null;\n\n      return this;\n    };\n    return NgTableParams;\n  }]);\n\n  /**\n   * @ngdoc service\n   * @name ngTableParams\n   * @description Backwards compatible shim for lowercase 'n' in NgTableParams\n   */\n  angular.module('ngTable').factory('ngTableParams', ['NgTableParams', function (NgTableParams) {\n    return NgTableParams;\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc object\n   * @name ngTableController\n   *\n   * @description\n   * Each {@link ngTable ngTable} directive creates an instance of `ngTableController`\n   */\n  angular.module('ngTable').controller('ngTableController', ['$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element', 'ngTableColumn', 'ngTableEventsChannel', function ($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, ngTableColumn, ngTableEventsChannel) {\n    var isFirstTimeLoad = true;\n    $scope.$filterRow = {};\n    $scope.$loading = false;\n\n    // until such times as the directive uses an isolated scope, we need to ensure that the check for\n    // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n    // field on a $scope higher up in the prototype chain\n    if (!$scope.hasOwnProperty(\"params\")) {\n      $scope.params = new NgTableParams(true);\n    }\n    $scope.params.settings().$scope = $scope;\n\n    var delayFilter = function () {\n      var timer = 0;\n      return function (callback, ms) {\n        $timeout.cancel(timer);\n        timer = $timeout(callback, ms);\n      };\n    }();\n\n    function onDataReloadStatusChange(newStatus /*, oldStatus*/) {\n      if (!newStatus || $scope.params.hasErrorState()) {\n        return;\n      }\n\n      $scope.params.settings().$scope = $scope;\n\n      var currentParams = $scope.params;\n      var filterOptions = currentParams.settings().filterOptions;\n\n      if (currentParams.hasFilterChanges()) {\n        var applyFilter = function applyFilter() {\n          currentParams.page(1);\n          currentParams.reload();\n        };\n        if (filterOptions.filterDelay) {\n          delayFilter(applyFilter, filterOptions.filterDelay);\n        } else {\n          applyFilter();\n        }\n      } else {\n        currentParams.reload();\n      }\n    }\n\n    // watch for when a new NgTableParams is bound to the scope\n    // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n    // the current data page as a field. Checking this for value equality would be terrible for performance\n    // and potentially cause an error if the items in that array has circular references\n    $scope.$watch('params', function (newParams, oldParams) {\n      if (newParams === oldParams || !newParams) {\n        return;\n      }\n\n      newParams.reload();\n    }, false);\n\n    $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);\n\n    this.compileDirectiveTemplates = function () {\n      if (!$element.hasClass('ng-table')) {\n        $scope.templates = {\n          header: $attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html',\n          pagination: $attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html'\n        };\n        $element.addClass('ng-table');\n        var headerTemplate = null;\n\n        // $element.find('> thead').length === 0 doesn't work on jqlite\n        var theadFound = false;\n        angular.forEach($element.children(), function (e) {\n          if (e.tagName === 'THEAD') {\n            theadFound = true;\n          }\n        });\n        if (!theadFound) {\n          headerTemplate = angular.element(document.createElement('thead')).attr('ng-include', 'templates.header');\n          $element.prepend(headerTemplate);\n        }\n        var paginationTemplate = angular.element(document.createElement('div')).attr({\n          'ng-table-pagination': 'params',\n          'template-url': 'templates.pagination'\n        });\n        $element.after(paginationTemplate);\n        if (headerTemplate) {\n          $compile(headerTemplate)($scope);\n        }\n        $compile(paginationTemplate)($scope);\n      }\n    };\n\n    this.loadFilterData = function ($columns) {\n      angular.forEach($columns, function ($column) {\n        var result;\n        result = $column.filterData($scope);\n        if (!result) {\n          delete $column.filterData;\n          return;\n        }\n\n        // if we're working with a deferred object or a promise, let's wait for the promise\n        /* WARNING: support for returning a $defer is depreciated */\n        if (angular.isObject(result) && (angular.isObject(result.promise) || angular.isFunction(result.then))) {\n          var pData = angular.isFunction(result.then) ? result : result.promise;\n          delete $column.filterData;\n          return pData.then(function (data) {\n            // our deferred can eventually return arrays, functions and objects\n            if (!angular.isArray(data) && !angular.isFunction(data) && !angular.isObject(data)) {\n              // if none of the above was found - we just want an empty array\n              data = [];\n            }\n            $column.data = data;\n          });\n        }\n        // otherwise, we just return what the user gave us. It could be a function, array, object, whatever\n        else {\n            return $column.data = result;\n          }\n      });\n    };\n\n    this.buildColumns = function (columns) {\n      var result = [];\n      (columns || []).forEach(function (col) {\n        result.push(ngTableColumn.buildColumn(col, $scope, result));\n      });\n      return result;\n    };\n\n    this.parseNgTableDynamicExpr = function (attr) {\n      if (!attr || attr.indexOf(\" with \") > -1) {\n        var parts = attr.split(/\\s+with\\s+/);\n        return {\n          tableParams: parts[0],\n          columns: parts[1]\n        };\n      } else {\n        throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n      }\n    };\n\n    this.setupBindingsToInternalScope = function (tableParamsExpr) {\n\n      // note: this we're setting up watches to simulate angular's isolated scope bindings\n\n      // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n      // $watch for value equivalence. This is because ngTableParams references the current page of data as\n      // a field and it's important not to watch this\n      var tableParamsGetter = $parse(tableParamsExpr);\n      $scope.$watch(tableParamsGetter, function (params) {\n        if (angular.isUndefined(params)) {\n          return;\n        }\n        $scope.paramsModel = tableParamsGetter;\n        $scope.params = params;\n      }, false);\n\n      setupFilterRowBindingsToInternalScope();\n      setupGroupRowBindingsToInternalScope();\n    };\n\n    function setupFilterRowBindingsToInternalScope() {\n      if ($attrs.showFilter) {\n        $scope.$parent.$watch($attrs.showFilter, function (value) {\n          $scope.show_filter = value;\n        });\n      } else {\n        $scope.$watch(hasVisibleFilterColumn, function (value) {\n          $scope.show_filter = value;\n        });\n      }\n\n      if ($attrs.disableFilter) {\n        $scope.$parent.$watch($attrs.disableFilter, function (value) {\n          $scope.$filterRow.disabled = value;\n        });\n      }\n    }\n\n    function setupGroupRowBindingsToInternalScope() {\n      $scope.$groupRow = {};\n      if ($attrs.showGroup) {\n        var showGroupGetter = $parse($attrs.showGroup);\n        $scope.$parent.$watch(showGroupGetter, function (value) {\n          $scope.$groupRow.show = value;\n        });\n        if (showGroupGetter.assign) {\n          // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n          $scope.$watch('$groupRow.show', function (value) {\n            showGroupGetter.assign($scope.$parent, value);\n          });\n        }\n      } else {\n        $scope.$watch('params.hasGroup()', function (newValue) {\n          $scope.$groupRow.show = newValue;\n        });\n      }\n    }\n\n    function getVisibleColumns() {\n      return ($scope.$columns || []).filter(function (c) {\n        return c.show($scope);\n      });\n    }\n\n    function hasVisibleFilterColumn() {\n      if (!$scope.$columns) return false;\n\n      return some($scope.$columns, function ($column) {\n        return $column.show($scope) && $column.filter($scope);\n      });\n    }\n\n    function some(array, predicate) {\n      var found = false;\n      for (var i = 0; i < array.length; i++) {\n        var obj = array[i];\n        if (predicate(obj)) {\n          found = true;\n          break;\n        }\n      }\n      return found;\n    }\n\n    function commonInit() {\n      ngTableEventsChannel.onAfterReloadData(bindDataToScope, $scope, isMyPublisher);\n      ngTableEventsChannel.onPagesChanged(bindPagesToScope, $scope, isMyPublisher);\n\n      function bindDataToScope(params, newDatapage) {\n        var visibleColumns = getVisibleColumns();\n        if (params.hasGroup()) {\n          $scope.$groups = newDatapage || [];\n          $scope.$groups.visibleColumnCount = visibleColumns.length;\n        } else {\n          $scope.$data = newDatapage || [];\n          $scope.$data.visibleColumnCount = visibleColumns.length;\n        }\n      }\n\n      function bindPagesToScope(params, newPages) {\n        $scope.pages = newPages;\n      }\n\n      function isMyPublisher(publisher) {\n        return $scope.params === publisher;\n      }\n    }\n\n    commonInit();\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc directive\n   * @name ngTable\n   * @module ngTable\n   * @restrict A\n   *\n   * @description\n   * Directive that instantiates {@link ngTableController ngTableController}.\n   */\n  angular.module('ngTable').directive('ngTable', ['$q', '$parse', function ($q, $parse) {\n    'use strict';\n\n    return {\n      restrict: 'A',\n      priority: 1001,\n      scope: true,\n      controller: 'ngTableController',\n      compile: function compile(element) {\n        var columns = [],\n            i = 0,\n            dataRow,\n            groupRow,\n            rows = [];\n\n        angular.forEach(element.find('tr'), function (tr) {\n          rows.push(angular.element(tr));\n        });\n        dataRow = rows.filter(function (tr) {\n          return !tr.hasClass('ng-table-group');\n        })[0];\n        groupRow = rows.filter(function (tr) {\n          return tr.hasClass('ng-table-group');\n        })[0];\n\n        if (!dataRow) {\n          return;\n        }\n        angular.forEach(dataRow.find('td'), function (item) {\n          var el = angular.element(item);\n          if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n            return;\n          }\n\n          var getAttrValue = function getAttrValue(attr) {\n            return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n          };\n          var setAttrValue = function setAttrValue(attr, value) {\n            if (el.attr('x-data-' + attr)) {\n              el.attr('x-data-' + attr, value);\n            } else if (el.attr('data' + attr)) {\n              el.attr('data' + attr, value);\n            } else {\n              el.attr(attr, value);\n            }\n          };\n\n          var parsedAttribute = function parsedAttribute(attr) {\n            var expr = getAttrValue(attr);\n            if (!expr) {\n              return undefined;\n            }\n\n            var localValue;\n            var getter = function getter(context) {\n              if (localValue !== undefined) {\n                return localValue;\n              }\n              return $parse(expr)(context);\n            };\n            getter.assign = function ($scope, value) {\n              var parsedExpr = $parse(expr);\n              if (parsedExpr.assign) {\n                // we should be writing back to the parent scope as this is where the expression\n                // came from\n                parsedExpr.assign($scope.$parent, value);\n              } else {\n                localValue = value;\n              }\n            };\n            return getter;\n          };\n          var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n          if (titleExpr) {\n            el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n          }\n          // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n          // a corresponding \"safe\" default\n          columns.push({\n            id: i++,\n            title: parsedAttribute('title'),\n            titleAlt: parsedAttribute('title-alt'),\n            headerTitle: parsedAttribute('header-title'),\n            sortable: parsedAttribute('sortable'),\n            'class': parsedAttribute('header-class'),\n            filter: parsedAttribute('filter'),\n            groupable: parsedAttribute('groupable'),\n            headerTemplateURL: parsedAttribute('header'),\n            filterData: parsedAttribute('filter-data'),\n            show: el.attr(\"ng-if\") ? parsedAttribute('ng-if') : undefined\n          });\n\n          if (groupRow || el.attr(\"ng-if\")) {\n            // change ng-if to bind to our column definition which we know will be writable\n            // because this will potentially increase the $watch count, only do so if we already have an\n            // ng-if or when we definitely need to change visibility of the columns.\n            // currently only ngTableGroupRow directive needs to change visibility\n            setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n          }\n        });\n        return function (scope, element, attrs, controller) {\n          scope.$columns = columns = controller.buildColumns(columns);\n\n          controller.setupBindingsToInternalScope(attrs.ngTable);\n          controller.loadFilterData(columns);\n          controller.compileDirectiveTemplates();\n        };\n      }\n    };\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n\n  /**\n   * @ngdoc directive\n   * @name ngTableDynamic\n   * @module ngTable\n   * @restrict A\n   *\n   * @description\n   * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n   * definitions to render\n   */\n  angular.module('ngTable').directive('ngTableDynamic', [function () {\n\n    return {\n      restrict: 'A',\n      priority: 1001,\n      scope: true,\n      controller: 'ngTableController',\n      compile: function compile(tElement) {\n        var row;\n\n        // IE 8 fix :not(.ng-table-group) selector\n        angular.forEach(tElement.find('tr'), function (tr) {\n          tr = angular.element(tr);\n          if (!tr.hasClass('ng-table-group') && !row) {\n            row = tr;\n          }\n        });\n        if (!row) {\n          return;\n        }\n\n        angular.forEach(row.find('td'), function (item) {\n          var el = angular.element(item);\n          var getAttrValue = function getAttrValue(attr) {\n            return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n          };\n\n          // this used in responsive table\n          var titleExpr = getAttrValue('title');\n          if (!titleExpr) {\n            el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n          }\n          var showExpr = el.attr('ng-if');\n          if (!showExpr) {\n            el.attr('ng-if', '$columns[$index].show(this)');\n          }\n        });\n        return function (scope, element, attrs, controller) {\n          var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n\n          controller.setupBindingsToInternalScope(expr.tableParams);\n          controller.compileDirectiveTemplates();\n\n          scope.$watchCollection(expr.columns, function (newCols /*, oldCols*/) {\n            scope.$columns = controller.buildColumns(newCols);\n            controller.loadFilterData(scope.$columns);\n          });\n        };\n      }\n    };\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').directive('ngTableColumnsBinding', ngTableColumnsBinding);\n\n  ngTableColumnsBinding.$inject = [\"$parse\"];\n\n  /**\n   * @ngdoc directive\n   * @name ngTableColumnsBinding\n   * @description One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n   * expression.\n   *\n   * This allows the $columns array to be accessed outside of the html table markup\n   */\n  function ngTableColumnsBinding($parse) {\n    var directive = {\n      restrict: 'A',\n      require: 'ngTable',\n      link: linkFn\n    };\n    return directive;\n\n    function linkFn($scope, $element, $attrs) {\n      var setter = $parse($attrs.ngTableColumnsBinding).assign;\n      if (setter) {\n        $scope.$watch('$columns', function (newColumns) {\n          var shallowClone = (newColumns || []).slice(0);\n          setter($scope, shallowClone);\n        });\n      }\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc directive\n   * @name ngTablePagination\n   * @module ngTable\n   * @restrict A\n   */\n  angular.module('ngTable').directive('ngTablePagination', ['$compile', 'ngTableEventsChannel', function ($compile, ngTableEventsChannel) {\n    'use strict';\n\n    return {\n      restrict: 'A',\n      scope: {\n        'params': '=ngTablePagination',\n        'templateUrl': '='\n      },\n      replace: false,\n      link: function link(scope, element /*, attrs*/) {\n\n        ngTableEventsChannel.onAfterReloadData(function (pubParams) {\n          scope.pages = pubParams.generatePagesArray();\n        }, scope, function (pubParams) {\n          return pubParams === scope.params;\n        });\n\n        scope.$watch('templateUrl', function (templateUrl) {\n          if (angular.isUndefined(templateUrl)) {\n            return;\n          }\n          var template = angular.element(document.createElement('div'));\n          template.attr({\n            'ng-include': 'templateUrl'\n          });\n          element.append(template);\n          $compile(template)(scope);\n        });\n      }\n    };\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').controller('ngTableFilterRowController', ngTableFilterRowController);\n\n  ngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];\n\n  function ngTableFilterRowController($scope, ngTableFilterConfig) {\n\n    $scope.config = ngTableFilterConfig;\n\n    $scope.getFilterCellCss = function (filter, layout) {\n      if (layout !== 'horizontal') {\n        return 's12';\n      }\n\n      var size = Object.keys(filter).length;\n      var width = parseInt(12 / size, 10);\n      return 's' + width;\n    };\n\n    $scope.getFilterPlaceholderValue = function (filterValue /*, filterName*/) {\n      if (angular.isObject(filterValue)) {\n        return filterValue.placeholder;\n      } else {\n        return '';\n      }\n    };\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').directive('ngTableFilterRow', ngTableFilterRow);\n\n  ngTableFilterRow.$inject = [];\n\n  function ngTableFilterRow() {\n    var directive = {\n      restrict: 'E',\n      replace: true,\n      templateUrl: 'ng-table/filterRow.html',\n      scope: true,\n      controller: 'ngTableFilterRowController'\n    };\n    return directive;\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').controller('ngTableGroupRowController', ngTableGroupRowController);\n\n  ngTableGroupRowController.$inject = ['$scope'];\n\n  function ngTableGroupRowController($scope) {\n\n    var groupFns = [];\n\n    init();\n\n    function init() {\n      $scope.getGroupables = getGroupables;\n      $scope.getGroupTitle = getGroupTitle;\n      $scope.getVisibleColumns = getVisibleColumns;\n      $scope.groupBy = groupBy;\n      $scope.isSelectedGroup = isSelectedGroup;\n      $scope.toggleDetail = toggleDetail;\n\n      $scope.$watch('params.group()', setGroup, true);\n    }\n\n    function changeSortDirection() {\n      var newDirection;\n      if ($scope.params.hasGroup($scope.$selGroup, 'asc')) {\n        newDirection = 'desc';\n      } else if ($scope.params.hasGroup($scope.$selGroup, 'desc')) {\n        newDirection = '';\n      } else {\n        newDirection = 'asc';\n      }\n      $scope.params.group($scope.$selGroup, newDirection);\n    }\n\n    function findGroupColumn(groupKey) {\n      return $scope.$columns.filter(function ($column) {\n        return $column.groupable($scope) === groupKey;\n      })[0];\n    }\n\n    function getGroupTitle(group) {\n      return angular.isFunction(group) ? group.title : group.title($scope);\n    }\n\n    function getGroupables() {\n      var groupableCols = $scope.$columns.filter(function ($column) {\n        return $column.groupable($scope);\n      });\n      return groupFns.concat(groupableCols);\n    }\n\n    function getVisibleColumns() {\n      return $scope.$columns.filter(function ($column) {\n        return $column.show($scope);\n      });\n    }\n\n    function groupBy(group) {\n      if (isSelectedGroup(group)) {\n        changeSortDirection();\n      } else {\n        if (group.groupable) {\n          $scope.params.group(group.groupable($scope));\n        } else {\n          $scope.params.group(group);\n        }\n      }\n    }\n\n    function isSelectedGroup(group) {\n      if (group.groupable) {\n        return group.groupable($scope) === $scope.$selGroup;\n      } else {\n        return group === $scope.$selGroup;\n      }\n    }\n\n    function setGroup(group) {\n      var existingGroupCol = findGroupColumn($scope.$selGroup);\n      if (existingGroupCol && existingGroupCol.show.assign) {\n        existingGroupCol.show.assign($scope, true);\n      }\n      if (angular.isFunction(group)) {\n        groupFns = [group];\n        $scope.$selGroup = group;\n        $scope.$selGroupTitle = group.title;\n      } else {\n        // note: currently only one group is implemented\n        var groupKey = Object.keys(group || {})[0];\n        var groupedColumn = findGroupColumn(groupKey);\n        if (groupedColumn) {\n          $scope.$selGroupTitle = groupedColumn.title($scope);\n          $scope.$selGroup = groupKey;\n          if (groupedColumn.show.assign) {\n            groupedColumn.show.assign($scope, false);\n          }\n        }\n      }\n    }\n\n    function toggleDetail() {\n      $scope.params.settings().groupOptions.isExpanded = !$scope.params.settings().groupOptions.isExpanded;\n      return $scope.params.reload();\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').directive('ngTableGroupRow', ngTableGroupRow);\n\n  ngTableGroupRow.$inject = [];\n\n  function ngTableGroupRow() {\n    var directive = {\n      restrict: 'E',\n      replace: true,\n      templateUrl: 'ng-table/groupRow.html',\n      scope: true,\n      controller: 'ngTableGroupRowController',\n      controllerAs: 'dctrl'\n    };\n    return directive;\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').controller('ngTableSorterRowController', ngTableSorterRowController);\n\n  ngTableSorterRowController.$inject = ['$scope'];\n\n  function ngTableSorterRowController($scope) {\n\n    $scope.sortBy = sortBy;\n\n    ///////////\n\n    function sortBy($column, event) {\n      var parsedSortable = $column.sortable && $column.sortable();\n      if (!parsedSortable) {\n        return;\n      }\n      var defaultSort = $scope.params.settings().defaultSort;\n      var inverseSort = defaultSort === 'asc' ? 'desc' : 'asc';\n      var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && $scope.params.sorting()[parsedSortable] === defaultSort;\n      var sortingParams = event.ctrlKey || event.metaKey ? $scope.params.sorting() : {};\n      sortingParams[parsedSortable] = sorting ? inverseSort : defaultSort;\n      $scope.params.parameters({\n        sorting: sortingParams\n      });\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable').directive('ngTableSorterRow', ngTableSorterRow);\n\n  ngTableSorterRow.$inject = [];\n\n  function ngTableSorterRow() {\n    var directive = {\n      restrict: 'E',\n      replace: true,\n      templateUrl: 'ng-table/sorterRow.html',\n      scope: true,\n      controller: 'ngTableSorterRowController'\n    };\n    return directive;\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  /**\n   * @ngdoc directive\n   * @name ngTableSelectFilterDs\n   * @module ngTable\n   * @restrict A\n   *\n   * @description\n   * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n   *\n   * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n   * \"deselecting\" an item from a `<select>` tag\n   *\n   * This directive is is focused on providing a datasource to an `ngOptions` directive\n   */\n\n  angular.module('ngTable').directive('ngTableSelectFilterDs', ngTableSelectFilterDs);\n\n  ngTableSelectFilterDs.$inject = [];\n\n  function ngTableSelectFilterDs() {\n    // note: not using isolated or child scope \"by design\"\n    // this is to allow this directive to be combined with other directives that do\n\n    var directive = {\n      restrict: 'A',\n      controller: ngTableSelectFilterDsController\n    };\n    return directive;\n  }\n\n  ngTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];\n  function ngTableSelectFilterDsController($scope, $parse, $attrs, $q) {\n\n    var $column = {};\n    init();\n\n    function init() {\n      $column = $parse($attrs.ngTableSelectFilterDs)($scope);\n      $scope.$watch(function () {\n        return $column.data;\n      }, bindDataSource);\n    }\n\n    function bindDataSource() {\n      getSelectListData($column).then(function (data) {\n        if (data && !hasEmptyOption(data)) {\n          data.unshift({ id: '', title: '' });\n        }\n        data = data || [];\n        $scope.$selectData = data;\n      });\n    }\n\n    function hasEmptyOption(data) {\n      var isMatch;\n      for (var i = 0; i < data.length; i++) {\n        var item = data[i];\n        if (item && item.id === '') {\n          isMatch = true;\n          break;\n        }\n      }\n      return isMatch;\n    }\n\n    function getSelectListData($column) {\n      var data = angular.isFunction($column.data) ? $column.data() : $column.data;\n      return $q.when(data);\n    }\n  }\n})();\n\nangular.module('ngTable').run(['$templateCache', function ($templateCache) {\n  $templateCache.put('ng-table/filterRow.html', '<tr ng-show=\"show_filter\" class=\"ng-table-filters\"> <th data-title-text=\"{{$column.titleAlt(this) || $column.title(this)}}\" ng-repeat=\"$column in $columns\" ng-if=\"$column.show(this)\" class=\"filter {{$column.class(this)}}\" ng-class=\"params.settings().filterOptions.filterLayout===\\'horizontal\\' ? \\'filter-horizontal\\' : \\'\\'\"> <div ng-repeat=\"(name, filter) in $column.filter(this)\" ng-include=\"config.getTemplateUrl(filter)\" class=\"filter-cell\" ng-class=\"[getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? \\'last\\' : \\'\\']\"> </div> </th> </tr> ');\n  $templateCache.put('ng-table/filters/number.html', '<input type=\"number\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n  $templateCache.put('ng-table/filters/select-multiple.html', '<select ng-options=\"data.id as data.title for data in $column.data\" ng-disabled=\"$filterRow.disabled\" multiple ng-multiple=\"true\" ng-model=\"params.filter()[name]\" class=\"filter filter-select-multiple form-control\" name=\"{{name}}\"> </select> ');\n  $templateCache.put('ng-table/filters/select.html', '<select ng-options=\"data.id as data.title for data in $selectData\" ng-table-select-filter-ds=\"$column\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"filter filter-select form-control\" name=\"{{name}}\"> <option style=\"display:none\" value=\"\"></option> </select> ');\n  $templateCache.put('ng-table/filters/text.html', '<input type=\"text\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n  $templateCache.put('ng-table/groupRow.html', '<tr ng-if=\"params.hasGroup()\" ng-show=\"$groupRow.show\" class=\"ng-table-group-header\"> <th colspan=\"{{getVisibleColumns().length}}\" class=\"sortable\" ng-class=\"{ \\'sort-asc\\': params.hasGroup($selGroup, \\'asc\\'), \\'sort-desc\\':params.hasGroup($selGroup, \\'desc\\') }\"> <a href=\"\" ng-click=\"isSelectorOpen=!isSelectorOpen\" class=\"ng-table-group-selector\"> <strong class=\"sort-indicator\">{{$selGroupTitle}}</strong> <button class=\"btn btn-default btn-xs ng-table-group-close\" ng-click=\"$groupRow.show=false; $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon glyphicon-remove\"></span> </button> <button class=\"btn btn-default btn-xs ng-table-group-toggle\" ng-click=\"toggleDetail(); $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon\" ng-class=\"{ \\'glyphicon-resize-small\\': params.settings().groupOptions.isExpanded, \\'glyphicon-resize-full\\': !params.settings().groupOptions.isExpanded }\"></span> </button> </a> <div class=\"list-group\" ng-if=\"isSelectorOpen\"> <a href=\"\" class=\"list-group-item\" ng-repeat=\"group in getGroupables()\" ng-click=\"groupBy(group)\"> <strong>{{ getGroupTitle(group)}}</strong> <strong ng-class=\"isSelectedGroup(group) && \\'sort-indicator\\'\"></strong> </a> </div> </th> </tr> ');\n  $templateCache.put('ng-table/header.html', '<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> ');\n  $templateCache.put('ng-table/pager.html', '<div class=\"ng-cloak ng-table-pager\" ng-if=\"params.data.length\"> <div ng-if=\"params.settings().counts.length\" class=\"ng-table-counts btn-group pull-right\"> <button ng-repeat=\"count in params.settings().counts\" type=\"button\" ng-class=\"{\\'active\\':params.count()==count}\" ng-click=\"params.count(count)\" class=\"btn btn-default\"> <span ng-bind=\"count\"></span> </button> </div> <ul ng-if=\"pages.length\" class=\"pagination ng-table-pagination\"> <li ng-class=\"{\\'disabled\\': !page.active && !page.current, \\'active\\': page.current}\" ng-repeat=\"page in pages\" ng-switch=\"page.type\"> <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\">&laquo;</a> <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">&#8230;</a> <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\">&raquo;</a> </li> </ul> </div> ');\n  $templateCache.put('ng-table/sorterRow.html', '<tr class=\"ng-table-sort-header\"> <th title=\"{{$column.headerTitle(this)}}\" ng-repeat=\"$column in $columns\" ng-class=\"{ \\'sortable\\': $column.sortable(this), \\'sort-asc\\': params.sorting()[$column.sortable(this)]==\\'asc\\', \\'sort-desc\\': params.sorting()[$column.sortable(this)]==\\'desc\\' }\" ng-click=\"sortBy($column, $event)\" ng-if=\"$column.show(this)\" ng-init=\"template=$column.headerTemplateURL(this)\" class=\"header {{$column.class(this)}}\"> <div ng-if=\"!template\" class=\"ng-table-header\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'div\\'}\"> <span ng-bind=\"$column.title(this)\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'span\\'}\"></span> </div> <div ng-if=\"template\" ng-include=\"template\"></div> </th> </tr> ');\n}]);\n\nexports.default = angular.module('ngTable');\n\n/***/ },\n\n/***/ 715:\n/***/ function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(1)();\n// imports\n\n\n// module\nexports.push([module.i, \"\", \"\"]);\n\n// exports\n\n\n/***/ },\n\n/***/ 896:\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _table = __webpack_require__(1017);\n\nvar _table2 = _interopRequireDefault(_table);\n\nvar _tableController = __webpack_require__(897);\n\nvar _tableController2 = _interopRequireDefault(_tableController);\n\n__webpack_require__(1085);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n  restrict: 'E',\n  bindings: {},\n  template: _table2.default,\n  controller: _tableController2.default,\n  controllerAs: 'vm'\n};\n\n/***/ },\n\n/***/ 897:\n/***/ function(module, exports) {\n\n\"use strict\";\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * (description)\n *\n * @author yourname\n */\n\nvar TableController = function () {\n\tTableController.$inject = [\"NgTableParams\", \"$state\"];\n\tfunction TableController(NgTableParams, $state) {\n\t\t\"ngInject\";\n\n\t\t_classCallCheck(this, TableController);\n\n\t\tthis.$state = $state;\n\t\tthis.NgTableParams = NgTableParams;\n\t\tthis.data = {\n\t\t\t\"total\": 85,\n\t\t\t\"datas\": [{\n\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t}, {\n\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t}]\n\t\t};\n\t\tthis.init();\n\t}\n\n\t_createClass(TableController, [{\n\t\tkey: \"init\",\n\t\tvalue: function init() {\n\t\t\tthis.getDataList();\n\t\t}\n\t}, {\n\t\tkey: \"getDataList\",\n\t\tvalue: function getDataList() {\n\t\t\tvar self = this;\n\t\t\tvar self = this;\n\t\t\tself.tableParams = new this.NgTableParams({\n\t\t\t\tpage: 1,\n\t\t\t\tcount: 5\n\t\t\t}, {\n\t\t\t\tcounts: [],\n\t\t\t\tgetData: function getData(params) {\n\t\t\t\t\tparams.total(self.data.total);\n\t\t\t\t\treturn self.data.datas;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}]);\n\n\treturn TableController;\n}();\n\nexports.default = TableController;\n\n/***/ }\n\n});\n\n\n// WEBPACK FOOTER //\n// table.min.js","module.exports = \"<section class=\\\"intro-content\\\">\\n\\t<h1 translate='{{vm.$state.current.name}}'></h1>\\n\\t<p>{{'TableDes'|translate}}</p>\\n</section>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Install' | translate}}</h2>\\n\\t<p>{{'Install_FancyUI'|translate}}</p>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n\\t<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"bash\\\">npm install fancyui --save</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Inject_Module'|translate}}</h2>\\n</section>\\n\\n<div class=\\\"example-block\\\">\\n<div class=\\\"highlight no-border\\\" hljs hljs-language=\\\"javascript\\\">\\nimport { ffanTable } from 'fancyui';\\n\\nexport default angular.module('tableDemo', [\\n  ffanTable.name\\n])</div>\\n</div>\\n\\n<section class=\\\"intro-content\\\">\\n\\t<h2>{{'Example'|translate}}</h2>\\n</section>\\n\\n<div class=\\\"table-container\\\">\\n\\t<div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t\\t\\t<thead>\\n\\t\\t\\t<tr>\\n\\t\\t\\t\\t<th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t\\t\\t<th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</thead>\\n\\t\\t\\t<tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t\\t\\t<td>{{row.name}}</td>\\n\\t\\t\\t\\t<td>{{row.viewName}}</td>\\n\\t\\t\\t\\t<td>{{row.lastStatus}}</td>\\n\\t\\t\\t\\t<td>{{row.lastNO}}</td>\\n\\t\\t\\t\\t<td>{{row.lastFailNO}}</td>\\n\\t\\t\\t</tr>\\n\\t\\t\\t</tbody>\\n\\t\\t</table>\\n\\n\\t\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t\\t\\t<p class=\\\"text-danger\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t\\t</div>\\n\\t\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n\\t</div>\\n</div>\\n\\n<h3>\\n\\tview\\n</h3>\\n<div class=\\\"example-block\\\">\\n\\t\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"html\\\">\\n<div class=\\\"table-container\\\">\\n  <div class=\\\"table-wrapper ng-scope ng-table\\\">\\n\\t<table class=\\\"table table-bordered table-hover\\\" ng-table=\\\"vm.tableParams\\\">\\n\\t  <thead>\\n\\t\\t<tr>\\n\\t\\t  <th style=\\\"width: 25%;\\\">名称</th>\\n\\t\\t  <th style=\\\"width: 15%;\\\">视图名称</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的状态</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译结果的序号</th>\\n\\t\\t  <th style=\\\"width: 20%;\\\">上一次编译失败的序号</th>\\n\\t\\t</tr>\\n\\t  </thead>\\n\\t  <tbody ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t    <tr ng-repeat=\\\"row in $data\\\">\\n\\t\\t  <td>{{row.name}}</td>\\n\\t\\t  <td>{{row.viewName}}</td>\\n\\t\\t  <td>{{row.lastStatus}}</td>\\n\\t\\t  <td>{{row.lastNO}}</td>\\n\\t\\t  <td>{{row.lastFailNO}}</td>\\n\\t    </tr>\\n\\t  </tbody>\\n\\t</table>\\n\\t<div class=\\\"prompt\\\" ng-if=\\\"vm.tableParams.data.length != 0\\\">\\n\\t  <p class=\\\"text-warning\\\">点击存储卷名称可对其进行文件导入，导出操作.</p>\\n\\t</div>\\n\\t<div class=\\\"no-result\\\" ng-if=\\\"vm.tableParams.data.length == 0\\\">结果为空</div>\\n  </div>\\n</div>\\n</div>\\n</div>\\n\\n<h3>\\n\\tcontroller\\n</h3>\\n\\n<div class=\\\"example-block\\\">\\n\\t\\n<div class=\\\"highlight\\\" hljs hljs-language=\\\"javascript\\\">\\nconstructor(NgTableParams) {\\n  \\\"ngInject\\\";\\n  this.NgTableParams = NgTableParams;\\n  this.data = {\\n      \\\"total\\\": 85,\\n      \\\"datas\\\": [\\n        {\\n          \\\"name\\\": 'fix_web',\\n          \\\"viewName\\\": \\\"tool-wd\\\",\\n          \\\"lastStatus\\\": \\\"SUCCESS\\\",\\n          \\\"lastNO\\\": \\\"#10\\\",\\n          \\\"lastFailNO\\\": \\\"#4\\\"\\n         },\\n         {\\n           \\\"name\\\": 'fix_web',\\n           \\\"viewName\\\": \\\"tool-wd\\\",\\n           \\\"lastStatus\\\": \\\"SUCCESS\\\",\\n           \\\"lastNO\\\": \\\"#10\\\",\\n           \\\"lastFailNO\\\": \\\"#4\\\"\\n         }\\n       ]\\n    };\\n  this.init();\\n}\\n\\ninit(){\\n  var self = this;\\n    self.tableParams = new this.NgTableParams({\\n      page: 1,\\n      count: 5\\n    }, {\\n    counts: [],\\n      getData: function (params) {\\n      params.total(self.data.total);\\n      return self.data.datas;\\n    }\\n  });\\n}</div>\\n</div>\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/app/components/table/table.html\n// module id = 1017\n// module chunks = 28","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/css-loader/index.js!./../../../../node_modules/less-loader/index.js!./table.less\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./example/app/components/table/table.less\n// module id = 1085\n// module chunks = 28","import tableComponent from './table.component.js';\nimport ffanTable from '../../../../lib/ffanTable/index.js';\n\nexport default angular.module('tableDemo', [\n\t\tffanTable.name\n])\n\t.component('tableDemo', tableComponent);\n\n\n\n// WEBPACK FOOTER //\n// ./example/app/components/table/table.js","\n(function () {\n  /**\n   * @ngdoc module\n   * @name ngTable\n   * @description ngTable: Table + Angular JS\n   */\n  angular.module('ngTable', []);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc object\n   * @name ngTableDefaultParams\n   * @module ngTable\n   * @description Default Parameters for ngTable\n   */\n  angular.module('ngTable')\n    .value('ngTableDefaults', {\n      params: {},\n      settings: {}\n    });\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .factory('ngTableEventsChannel', ngTableEventsChannel);\n\n  ngTableEventsChannel.$inject = ['$rootScope'];\n\n  /**\n   * @ngdoc service\n   * @name ngTableEventsChannel\n   * @description strongly typed pub/sub for `NgTableParams`\n   *\n   * Supported events:\n   *\n   * * afterCreated - raised when a new instance of `NgTableParams` has finished being constructed\n   * * afterReloadData - raised when the `reload` event has finished loading new data\n   * * datasetChanged - raised when `settings` receives a new data array\n   * * pagesChanged - raised when a new pages array has been generated\n   */\n  function ngTableEventsChannel($rootScope) {\n\n    var events = {};\n    events = addChangeEvent('afterCreated', events);\n    events = addChangeEvent('afterReloadData', events);\n    events = addChangeEvent('datasetChanged', events);\n    events = addChangeEvent('pagesChanged', events);\n    return events;\n\n    //////////\n\n    function addChangeEvent(eventName, target) {\n      var fnName = eventName.charAt(0).toUpperCase() + eventName.substring(1);\n      var event = {};\n      event['on' + fnName] = createEventSubscriptionFn(eventName);\n      event['publish' + fnName] = createPublishEventFn(eventName);\n      return angular.extend(target, event);\n    }\n\n    function createEventSubscriptionFn(eventName) {\n\n      return function subscription(handler/*[, eventSelector or $scope][, eventSelector]*/) {\n        var eventSelector = angular.identity;\n        var scope = $rootScope;\n\n        if (arguments.length === 2) {\n          if (angular.isFunction(arguments[1].$new)) {\n            scope = arguments[1];\n          } else {\n            eventSelector = arguments[1]\n          }\n        } else if (arguments.length > 2) {\n          scope = arguments[1];\n          eventSelector = arguments[2];\n        }\n\n        // shorthand for subscriber to only receive events from a specific publisher instance\n        if (angular.isObject(eventSelector)) {\n          var requiredPublisher = eventSelector;\n          eventSelector = function (publisher) {\n            return publisher === requiredPublisher;\n          }\n        }\n\n        return scope.$on('ngTable:' + eventName, function (event, params/*, ...args*/) {\n          // don't send events published by the internal NgTableParams created by ngTableController\n          if (params.isNullInstance) return;\n\n          var eventArgs = rest(arguments, 2);\n          var fnArgs = [params].concat(eventArgs);\n          if (eventSelector.apply(this, fnArgs)) {\n            handler.apply(this, fnArgs);\n          }\n        });\n      }\n    }\n\n    function createPublishEventFn(eventName) {\n      return function publish(/*args*/) {\n        var fnArgs = ['ngTable:' + eventName].concat(Array.prototype.slice.call(arguments));\n        $rootScope.$broadcast.apply($rootScope, fnArgs);\n      }\n    }\n\n    function rest(array, n) {\n      return Array.prototype.slice.call(array, n == null ? 1 : n);\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .provider('ngTableFilterConfig', ngTableFilterConfigProvider);\n\n  ngTableFilterConfigProvider.$inject = [];\n\n  function ngTableFilterConfigProvider() {\n    var config;\n    var defaultConfig = {\n      defaultBaseUrl: 'ng-table/filters/',\n      defaultExt: '.html',\n      aliasUrls: {}\n    };\n\n    this.$get = ngTableFilterConfig;\n    this.resetConfigs = resetConfigs;\n    this.setConfig = setConfig;\n\n    init();\n\n    /////////\n\n    function init() {\n      resetConfigs();\n    }\n\n    function resetConfigs() {\n      config = defaultConfig;\n    }\n\n    function setConfig(customConfig) {\n      var mergeConfig = angular.extend({}, config, customConfig);\n      mergeConfig.aliasUrls = angular.extend({}, config.aliasUrls, customConfig.aliasUrls);\n      config = mergeConfig;\n    }\n\n    /////////\n\n    ngTableFilterConfig.$inject = [];\n\n    function ngTableFilterConfig() {\n\n      var publicConfig;\n\n      var service = {\n        config: publicConfig,\n        getTemplateUrl: getTemplateUrl,\n        getUrlForAlias: getUrlForAlias\n      };\n      Object.defineProperty(service, \"config\", {\n        get: function () {\n          return publicConfig = publicConfig || angular.copy(config);\n        },\n        enumerable: true\n      });\n\n      return service;\n\n      /////////\n\n      function getTemplateUrl(filterValue, filterKey) {\n        if (angular.isObject(filterValue)) {\n          filterValue = filterValue.id;\n        }\n        if (filterValue.indexOf('/') !== -1) {\n          return filterValue;\n        }\n\n        return service.getUrlForAlias(filterValue, filterKey);\n      }\n\n      function getUrlForAlias(aliasName/*, filterKey*/) {\n        return config.aliasUrls[aliasName] || config.defaultBaseUrl + aliasName + config.defaultExt;\n      }\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n\n  angular.module('ngTable')\n    .provider('ngTableDefaultGetData', ngTableDefaultGetDataProvider);\n\n  ngTableDefaultGetDataProvider.$inject = [];\n\n  /**\n   * @ngdoc provider\n   * @name ngTableDefaultGetDataProvider\n   * @description Allows for the configuration of the ngTableDefaultGetData service.\n   *\n   * Set filterFilterName to the name of a angular filter that knows how to apply the values returned by\n   * `NgTableParams.filter()` to restrict an array of data.\n   *\n   * Set sortingFilterName to the name of a angular filter that knows how to apply the values returned by\n   * `NgTableParams.orderBy()` to sort an array of data.\n   *\n   * Out of the box the `ngTableDefaultGetData` service will be configured to use the angular `filter` and `orderBy`\n   * filters respectively\n   */\n  function ngTableDefaultGetDataProvider() {\n    var provider = this;\n    provider.$get = ngTableDefaultGetData;\n    provider.filterFilterName = 'filter';\n    provider.sortingFilterName = 'orderBy';\n\n    ///////////\n\n    ngTableDefaultGetData.$inject = ['$filter'];\n\n    /**\n     * @ngdoc service\n     * @name ngTableDefaultGetData\n     * @description A default implementation of the getData function that will apply the `filter`, `orderBy` and\n     * paging values from the `NgTableParams` instance supplied to the data array supplied.\n     *\n     * The outcome will be to return the resulting array and to assign the total item count after filtering\n     * to the `total` of the `NgTableParams` instance supplied\n     */\n    function ngTableDefaultGetData($filter) {\n\n      var defaultDataOptions = { applyFilter: true, applySort: true, applyPaging: true };\n\n      getData.applyPaging = applyPaging;\n      getData.getFilterFn = getFilterFn;\n      getData.getOrderByFn = getOrderByFn;\n\n      return getData;\n\n      function getFilterFn(params) {\n        var filterOptions = params.settings().filterOptions;\n        if (angular.isFunction(filterOptions.filterFn)) {\n          return filterOptions.filterFn;\n        } else {\n          return $filter(filterOptions.filterFilterName || provider.filterFilterName);\n        }\n      }\n\n      function getOrderByFn(/*params*/) {\n        return $filter(provider.sortingFilterName);\n      }\n\n      function applyFilter(data, params) {\n        if (!params.hasFilter()) {\n          return data;\n        }\n\n        var filter = params.filter(true);\n        var filterKeys = Object.keys(filter);\n        var parsedFilter = filterKeys.reduce(function (result, key) {\n          result = setPath(result, filter[key], key);\n          return result;\n        }, {});\n        var filterFn = getFilterFn(params);\n        return filterFn.call(params, data, parsedFilter, params.settings().filterOptions.filterComparator);\n      }\n\n      function applyPaging(data, params) {\n        var pagedData = data.slice((params.page() - 1) * params.count(), params.page() * params.count());\n        params.total(data.length); // set total for recalc pagination\n        return pagedData;\n      }\n\n      function applySort(data, params) {\n        var orderBy = params.orderBy();\n        var orderByFn = getOrderByFn(params);\n        return orderBy.length ? orderByFn(data, orderBy) : data;\n      }\n\n      function getData(data, params) {\n        if (data == null) {\n          return [];\n        }\n\n        var options = angular.extend({}, defaultDataOptions, params.settings().dataOptions);\n\n        var fData = options.applyFilter ? applyFilter(data, params) : data;\n        var orderedData = options.applySort ? applySort(fData, params) : fData;\n        return options.applyPaging ? applyPaging(orderedData, params) : orderedData;\n      }\n\n      // Sets the value at any depth in a nested object based on the path\n      // note: adapted from: underscore-contrib#setPath\n      function setPath(obj, value, path) {\n        var keys = path.split('.');\n        var ret = obj;\n        var lastKey = keys[keys.length - 1];\n        var target = ret;\n\n        var parentPathKeys = keys.slice(0, keys.length - 1);\n        parentPathKeys.forEach(function (key) {\n          if (!target.hasOwnProperty(key)) {\n            target[key] = {};\n          }\n          target = target[key];\n        });\n\n        target[lastKey] = value;\n        return ret;\n      }\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  // todo: remove shim after an acceptable depreciation period\n\n  angular.module('ngTable')\n    .factory('ngTableGetDataBcShim', ngTableGetDataBcShim);\n\n  ngTableGetDataBcShim.$inject = ['$q'];\n\n  function ngTableGetDataBcShim($q) {\n\n    return createWrapper;\n\n    function createWrapper(getDataFn) {\n      return function getDataShim(/*args*/) {\n        var $defer = $q.defer();\n        var pData = getDataFn.apply(this, [$defer].concat(Array.prototype.slice.call(arguments)));\n        if (!pData) {\n          // If getData resolved the $defer, and didn't promise us data,\n          //   create a promise from the $defer. We need to return a promise.\n          pData = $defer.promise;\n        }\n        return pData;\n      }\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc service\n   * @name ngTableColumn\n   * @module ngTable\n   * @description\n   * Service to construct a $column definition used by {@link ngTable ngTable} directive\n   */\n  angular.module('ngTable').factory('ngTableColumn', [function () {\n\n    return {\n      buildColumn: buildColumn\n    };\n\n    //////////////\n\n    /**\n     * @ngdoc method\n     * @name ngTableColumn#buildColumn\n     * @description Creates a $column for use within a header template\n     *\n     * @param {Object} column an existing $column or simple column data object\n     * @param {Scope} defaultScope the $scope to supply to the $column getter methods when not supplied by caller\n     * @param {Array} columns a reference to the columns array to make available on the context supplied to the\n     * $column getter methods\n     * @returns {Object} a $column object\n     */\n    function buildColumn(column, defaultScope, columns) {\n      // note: we're not modifying the original column object. This helps to avoid unintended side affects\n      var extendedCol = Object.create(column);\n      var defaults = createDefaults();\n      for (var prop in defaults) {\n        if (extendedCol[prop] === undefined) {\n          extendedCol[prop] = defaults[prop];\n        }\n        if (!angular.isFunction(extendedCol[prop])) {\n          // wrap raw field values with \"getter\" functions\n          // - this is to ensure consistency with how ngTable.compile builds columns\n          // - note that the original column object is being \"proxied\"; this is important\n          //   as it ensure that any changes to the original object will be returned by the \"getter\"\n          (function (prop1) {\n            var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n              if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n                getterSetter.assign(null, arguments[0]);\n              } else {\n                return column[prop1];\n              }\n            };\n            getterSetter.assign = function ($scope, value) {\n              column[prop1] = value;\n            };\n            extendedCol[prop1] = getterSetter;\n          })(prop);\n        }\n        (function (prop1) {\n          // satisfy the arguments expected by the function returned by parsedAttribute in the ngTable directive\n          var getterFn = extendedCol[prop1];\n          extendedCol[prop1] = function () {\n            if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n              getterFn.assign(null, arguments[0]);\n            } else {\n              var scope = arguments[0] || defaultScope;\n              var context = Object.create(scope);\n              angular.extend(context, {\n                $column: extendedCol,\n                $columns: columns\n              });\n              return getterFn.call(column, context);\n            }\n          };\n          if (getterFn.assign) {\n            extendedCol[prop1].assign = getterFn.assign;\n          }\n        })(prop);\n      }\n      return extendedCol;\n    }\n\n    function createDefaults() {\n      return {\n        'class': createGetterSetter(''),\n        filter: createGetterSetter(false),\n        groupable: createGetterSetter(false),\n        filterData: angular.noop,\n        headerTemplateURL: createGetterSetter(false),\n        headerTitle: createGetterSetter(''),\n        sortable: createGetterSetter(false),\n        show: createGetterSetter(true),\n        title: createGetterSetter(''),\n        titleAlt: createGetterSetter('')\n      };\n    }\n\n    function createGetterSetter(initialValue) {\n      var value = initialValue;\n      var getterSetter = function getterSetter(/*[value] || [$scope, locals]*/) {\n        if (arguments.length === 1 && !isScopeLike(arguments[0])) {\n          getterSetter.assign(null, arguments[0]);\n        } else {\n          return value;\n        }\n      };\n      getterSetter.assign = function ($scope, newValue) {\n        value = newValue;\n      };\n      return getterSetter;\n    }\n\n    function isScopeLike(object) {\n      return object != null && angular.isFunction(object.$new);\n    }\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc service\n   * @name NgTableParams\n   * @module ngTable\n   * @description Parameters manager for ngTable\n   */\n\n  angular.module('ngTable').factory('NgTableParams', ['$q', '$log', '$filter', 'ngTableDefaults', 'ngTableGetDataBcShim', 'ngTableDefaultGetData', 'ngTableEventsChannel', function ($q, $log, $filter, ngTableDefaults, ngTableGetDataBcShim, ngTableDefaultGetData, ngTableEventsChannel) {\n    var isNumber = function (n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    };\n    var NgTableParams = function (baseParameters, baseSettings) {\n\n      // the ngTableController \"needs\" to create a dummy/null instance and it's important to know whether an instance\n      // is one of these\n      if (typeof baseParameters === \"boolean\") {\n        this.isNullInstance = true;\n      }\n\n      var self = this,\n        prevParamsMemento,\n        errParamsMemento,\n        isCommittedDataset = false,\n        initialEvents = [],\n        log = function () {\n          if (settings.debugMode && $log.debug) {\n            $log.debug.apply($log, arguments);\n          }\n        },\n        defaultFilterOptions = {\n          filterComparator: undefined, // look for a substring match in case insensitive way\n          filterDelay: 500,\n          filterDelayThreshold: 10000, // size of dataset array that will trigger the filterDelay being applied\n          filterFilterName: undefined, // when defined overrides ngTableDefaultGetDataProvider.filterFilterName\n          filterFn: undefined, // when defined overrides the filter function that ngTableDefaultGetData uses\n          filterLayout: 'stack' // alternative: 'horizontal'\n        },\n        defaultGroupOptions = {\n          defaultSort: 'asc', // set to 'asc' or 'desc' to apply sorting to groups\n          isExpanded: true\n        },\n        defaultSettingsFns = getDefaultSettingFns();\n\n      this.data = [];\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#parameters\n       * @description Set new parameters or get current parameters\n       *\n       * @param {string} newParameters      New parameters\n       * @param {string} parseParamsFromUrl Flag if parse parameters like in url\n       * @returns {Object} Current parameters or `this`\n       */\n      this.parameters = function (newParameters, parseParamsFromUrl) {\n        parseParamsFromUrl = parseParamsFromUrl || false;\n        if (angular.isDefined(newParameters)) {\n          for (var key in newParameters) {\n            var value = newParameters[key];\n            if (parseParamsFromUrl && key.indexOf('[') >= 0) {\n              var keys = key.split(/\\[(.*)\\]/).reverse()\n              var lastKey = '';\n              for (var i = 0, len = keys.length; i < len; i++) {\n                var name = keys[i];\n                if (name !== '') {\n                  var v = value;\n                  value = {};\n                  value[lastKey = name] = (isNumber(v) ? parseFloat(v) : v);\n                }\n              }\n              if (lastKey === 'sorting') {\n                params[lastKey] = {};\n              }\n              params[lastKey] = angular.extend(params[lastKey] || {}, value[lastKey]);\n            } else {\n              if (key === 'group') {\n                params[key] = parseGroup(newParameters[key]);\n              } else {\n                params[key] = (isNumber(newParameters[key]) ? parseFloat(newParameters[key]) : newParameters[key]);\n              }\n            }\n          }\n          log('ngTable: set parameters', params);\n          return this;\n        }\n        return params;\n      };\n\n      function parseGroup(group) {\n        var defaultSort = settings.groupOptions && settings.groupOptions.defaultSort;\n        if (angular.isFunction(group)) {\n          if (group.sortDirection == null) {\n            group.sortDirection = defaultSort;\n          }\n          return group;\n        } else if (angular.isString(group)) {\n          var grp = {};\n          grp[group] = defaultSort;\n          return grp;\n        } else if (angular.isObject(group)) {\n          for (var key in group) {\n            if (group[key] == null) {\n              group[key] = defaultSort;\n            }\n          }\n          return group;\n        } else {\n          return group;\n        }\n      }\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#settings\n       * @description Set new settings for table\n       *\n       * @param {string} newSettings New settings or undefined\n       * @returns {Object} Current settings or `this`\n       */\n      this.settings = function (newSettings) {\n        if (angular.isDefined(newSettings)) {\n\n          // todo: don't modify newSettings object: this introduces unexpected side effects;\n          // instead take a copy of newSettings\n\n          if (newSettings.filterOptions) {\n            newSettings.filterOptions = angular.extend({}, settings.filterOptions, newSettings.filterOptions);\n          }\n          if (newSettings.groupOptions) {\n            newSettings.groupOptions = angular.extend({}, settings.groupOptions, newSettings.groupOptions);\n          }\n\n          if (angular.isArray(newSettings.dataset)) {\n            //auto-set the total from passed in dataset\n            newSettings.total = newSettings.dataset.length;\n          }\n\n          // todo: remove the backwards compatibility shim and the following two if blocks\n          if (newSettings.getData && newSettings.getData.length > 1) {\n            // support the old getData($defer, params) api\n            newSettings.getDataFnAdaptor = ngTableGetDataBcShim;\n          }\n          if (newSettings.getGroups && newSettings.getGroups.length > 2) {\n            // support the old getGroups($defer, params) api\n            newSettings.getGroupsFnAdaptor = ngTableGetDataBcShim;\n          }\n\n          var originalDataset = settings.dataset;\n          settings = angular.extend(settings, newSettings);\n\n          if (angular.isArray(newSettings.dataset)) {\n            optimizeFilterDelay();\n          }\n\n          // note: using != as want null and undefined to be treated the same\n          var hasDatasetChanged = newSettings.hasOwnProperty('dataset') && (newSettings.dataset != originalDataset);\n          if (hasDatasetChanged) {\n            if (isCommittedDataset) {\n              this.page(1); // reset page as a new dataset has been supplied\n            }\n            isCommittedDataset = false;\n\n            var fireEvent = function () {\n              ngTableEventsChannel.publishDatasetChanged(self, newSettings.dataset, originalDataset);\n            };\n\n            if (initialEvents) {\n              initialEvents.push(fireEvent);\n            } else {\n              fireEvent();\n            }\n          }\n          log('ngTable: set settings', settings);\n          return this;\n        }\n        return settings;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#page\n       * @description If parameter page not set return current page else set current page\n       *\n       * @param {string} page Page number\n       * @returns {Object|Number} Current page or `this`\n       */\n      this.page = function (page) {\n        return angular.isDefined(page) ? this.parameters({\n          'page': page\n        }) : params.page;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#total\n       * @description If parameter total not set return current quantity else set quantity\n       *\n       * @param {string} total Total quantity of items\n       * @returns {Object|Number} Current page or `this`\n       */\n      this.total = function (total) {\n        return angular.isDefined(total) ? this.settings({\n          'total': total\n        }) : settings.total;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#count\n       * @description If parameter count not set return current count per page else set count per page\n       *\n       * @param {string} count Count per number\n       * @returns {Object|Number} Count per page or `this`\n       */\n      this.count = function (count) {\n        // reset to first page because can be blank page\n        return angular.isDefined(count) ? this.parameters({\n          'count': count,\n          'page': 1\n        }) : params.count;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#filter\n       * @description If 'filter' parameter not set return current filter else set current filter\n       *\n       * Note: when assigning a new filter, {@link NgTableParams#page page} will be set to 1\n       *\n       * @param {Object|Boolean} filter 'object': new filter to assign or\n       * 'true': to return the current filter minus any insignificant values (null,  undefined and empty string); or\n       * 'falsey': to return the current filter \"as is\"\n       * @returns {Object} Current filter or `this`\n       */\n      this.filter = function (filter) {\n        if (angular.isDefined(filter) && angular.isObject(filter)) {\n          return this.parameters({\n            'filter': filter,\n            'page': 1\n          });\n        } else if (filter === true) {\n          var keys = Object.keys(params.filter);\n          var significantFilter = {};\n          for (var i = 0; i < keys.length; i++) {\n            var filterValue = params.filter[keys[i]];\n            if (filterValue != null && filterValue !== '') {\n              significantFilter[keys[i]] = filterValue;\n            }\n          }\n          return significantFilter;\n        } else {\n          return params.filter;\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#group\n       * @description If 'group' parameter is not set, return current grouping. Otherwise set current group.\n       *\n       * @param {string|Function|Object} group New group field\n       * @param {string} sortDirection Optional direction that the list of groups should be sorted\n       * @returns {Object} Current grouping or `this`\n       */\n      this.group = function (group, sortDirection) {\n        if (!angular.isDefined(group)) {\n          return params.group;\n        }\n\n        var newParameters = {\n          page: 1\n        };\n        if (angular.isFunction(group) && angular.isDefined(sortDirection)) {\n          group.sortDirection = sortDirection;\n          newParameters.group = group;\n        } else if (angular.isDefined(group) && angular.isDefined(sortDirection)) {\n          var groupArray = {};\n          groupArray[group] = sortDirection;\n          newParameters.group = groupArray;\n        } else {\n          newParameters.group = group;\n        }\n        this.parameters(newParameters);\n        return this;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#sorting\n       * @description If 'sorting' parameter is not set, return current sorting. Otherwise set current sorting.\n       *\n       * @param {string} sorting New sorting\n       * @returns {Object} Current sorting or `this`\n       */\n      this.sorting = function (sorting) {\n        if (arguments.length == 2) {\n          var sortArray = {};\n          sortArray[sorting] = arguments[1];\n          this.parameters({\n            'sorting': sortArray\n          });\n          return this;\n        }\n        return angular.isDefined(sorting) ? this.parameters({\n          'sorting': sorting\n        }) : params.sorting;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#isSortBy\n       * @description Checks sort field\n       *\n       * @param {string} field     Field name\n       * @param {string} direction Optional direction of sorting ('asc' or 'desc')\n       * @returns {Array} Return true if field sorted by direction\n       */\n      this.isSortBy = function (field, direction) {\n        if (direction !== undefined) {\n          return angular.isDefined(params.sorting[field]) && params.sorting[field] == direction;\n        } else {\n          return angular.isDefined(params.sorting[field]);\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#orderBy\n       * @description Return object of sorting parameters for angular filter\n       *\n       * @returns {Array} Array like: [ '-name', '+age' ]\n       */\n      this.orderBy = function () {\n        return convertSortToOrderBy(params.sorting);\n      };\n\n      function convertSortToOrderBy(sorting) {\n        var result = [];\n        for (var column in sorting) {\n          result.push((sorting[column] === \"asc\" ? \"+\" : \"-\") + column);\n        }\n        return result;\n      }\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#generatePagesArray\n       * @description Generate array of pages\n       *\n       * When no arguments supplied, the current parameter state of this `NgTableParams` instance will be used\n       *\n       * @param {boolean} currentPage which page must be active\n       * @param {boolean} totalItems  Total quantity of items\n       * @param {boolean} pageSize    Quantity of items on page\n       * @param {number} maxBlocks    Quantity of blocks for pagination\n       * @returns {Array} Array of pages\n       */\n      this.generatePagesArray = function (currentPage, totalItems, pageSize, maxBlocks) {\n        if (!arguments.length) {\n          currentPage = this.page();\n          totalItems = this.total();\n          pageSize = this.count();\n        }\n\n        var maxPage, maxPivotPages, minPage, numPages, pages;\n        maxBlocks = maxBlocks && maxBlocks < 6 ? 6 : maxBlocks;\n\n        pages = [];\n        numPages = Math.ceil(totalItems / pageSize);\n        if (numPages > 1) {\n          pages.push({\n            type: 'prev',\n            number: Math.max(1, currentPage - 1),\n            active: currentPage > 1\n          });\n          pages.push({\n            type: 'first',\n            number: 1,\n            active: currentPage > 1,\n            current: currentPage === 1\n          });\n          maxPivotPages = Math.round((settings.paginationMaxBlocks - settings.paginationMinBlocks) / 2);\n          minPage = Math.max(2, currentPage - maxPivotPages);\n          maxPage = Math.min(numPages - 1, currentPage + maxPivotPages * 2 - (currentPage - minPage));\n          minPage = Math.max(2, minPage - (maxPivotPages * 2 - (maxPage - minPage)));\n          var i = minPage;\n          while (i <= maxPage) {\n            if ((i === minPage && i !== 2) || (i === maxPage && i !== numPages - 1)) {\n              pages.push({\n                type: 'more',\n                active: false\n              });\n            } else {\n              pages.push({\n                type: 'page',\n                number: i,\n                active: currentPage !== i,\n                current: currentPage === i\n              });\n            }\n            i++;\n          }\n          pages.push({\n            type: 'last',\n            number: numPages,\n            active: currentPage !== numPages,\n            current: currentPage === numPages\n          });\n          pages.push({\n            type: 'next',\n            number: Math.min(numPages, currentPage + 1),\n            active: currentPage < numPages\n          });\n        }\n        return pages;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#isDataReloadRequired\n       * @description Return true when a change to this `NgTableParams` instance should require the reload method\n       * to be run so as to ensure the data presented to the user reflects the `NgTableParams`\n       *\n       * Note that this method will return false when the reload method has run but fails. In this case\n       * `hasErrorState` will return true.\n       */\n      this.isDataReloadRequired = function () {\n        // note: using != as want to treat null and undefined the same\n        return !isCommittedDataset || !angular.equals(createComparableParams(), prevParamsMemento)\n          || hasGlobalSearchFieldChanges();\n      };\n\n      function createComparableParams() {\n        var result = { params: params };\n        if (angular.isFunction(params.group)) {\n          result.groupSortDirection = params.group.sortDirection;\n        }\n        return result\n      }\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasFilter\n       * @description Determines if NgTableParams#filter has significant filter value(s)\n       * (any value except null, undefined, or empty string)\n       * @returns {Boolean} true when NgTableParams#filter has at least one significant field value\n       */\n      this.hasFilter = function () {\n        return Object.keys(this.filter(true)).length > 0;\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasGroup\n       * @description Determines if at least one group has been set\n       * @returns {Boolean}\n       */\n      this.hasGroup = function (group, sortDirection) {\n        if (group == null) {\n          return angular.isFunction(params.group) || Object.keys(params.group).length > 0\n        }\n\n        if (angular.isFunction(group)) {\n          if (sortDirection == null) {\n            return params.group === group;\n          } else {\n            return params.group === group && group.sortDirection === sortDirection;\n          }\n        } else {\n          if (sortDirection == null) {\n            return Object.keys(params.group).indexOf(group) !== -1;\n          } else {\n            return params.group[group] === sortDirection;\n          }\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasFilterChanges\n       * @description Return true when a change to `NgTableParams.filters`require the reload method\n       * to be run so as to ensure the data presented to the user reflects these filters\n       */\n      this.hasFilterChanges = function () {\n        var previousFilter = (prevParamsMemento && prevParamsMemento.params.filter);\n        return !angular.equals((params.filter), previousFilter) || hasGlobalSearchFieldChanges();\n      };\n\n      function hasGlobalSearchFieldChanges() {\n        var currentVal = (params.filter && params.filter.$);\n        var previousVal =\n          (prevParamsMemento && prevParamsMemento.params.filter && prevParamsMemento.params.filter.$);\n        return !angular.equals(currentVal, previousVal);\n      }\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#url\n       * @description Return groups for table grouping\n       *\n       * @param {boolean} asString flag indicates return array of string or object\n       * @returns {Array} If asString = true will be return array of url string parameters else key-value object\n       */\n      this.url = function (asString) {\n        asString = asString || false;\n        var pairs = (asString ? [] : {});\n        for (var key in params) {\n          if (params.hasOwnProperty(key)) {\n            var item = params[key],\n              name = encodeURIComponent(key);\n            if (typeof item === \"object\") {\n              for (var subkey in item) {\n                if (isSignificantValue(item[subkey], key)) {\n                  var pname = name + \"[\" + encodeURIComponent(subkey) + \"]\";\n                  collectValue(item[subkey], pname);\n                }\n              }\n            } else if (!angular.isFunction(item) && isSignificantValue(item, key)) {\n              collectValue(item, name);\n            }\n          }\n        }\n        return pairs;\n\n        function collectValue(value, key) {\n          if (asString) {\n            pairs.push(key + \"=\" + encodeURIComponent(value));\n          } else {\n            pairs[key] = encodeURIComponent(value);\n          }\n        }\n\n        function isSignificantValue(value, key) {\n          return key === \"group\" ? true : angular.isDefined(value) && value !== \"\";\n        }\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#reload\n       * @description Reload table data\n       */\n      this.reload = function () {\n        var self = this,\n          pData = null;\n\n        settings.$loading = true;\n\n        prevParamsMemento = angular.copy(createComparableParams());\n        isCommittedDataset = true;\n\n        if (self.hasGroup()) {\n          pData = runInterceptorPipeline(runGetGroups);\n        } else {\n          pData = runInterceptorPipeline(runGetData);\n        }\n\n        log('ngTable: reload data');\n\n        var oldData = self.data;\n        return pData.then(function (data) {\n          settings.$loading = false;\n          errParamsMemento = null;\n\n          self.data = data;\n          // note: I think it makes sense to publish this event even when data === oldData\n          // subscribers can always set a filter to only receive the event when data !== oldData\n          ngTableEventsChannel.publishAfterReloadData(self, data, oldData);\n          self.reloadPages();\n\n          // todo: remove after acceptable depreciation period\n          if (settings.$scope) {\n            settings.$scope.$emit('ngTableAfterReloadData');\n          }\n\n          return data;\n        }).catch(function (reason) {\n          errParamsMemento = prevParamsMemento;\n          // \"rethrow\"\n          return $q.reject(reason);\n        });\n      };\n\n      /**\n       * @ngdoc method\n       * @name NgTableParams#hasErrorState\n       * @description Return true when an attempt to `reload` the current `parameter` values have resulted in\n       * a failure\n       *\n       * This method will continue to return true until the reload is successfully called or when the\n       * `parameter` values have changed\n       */\n      this.hasErrorState = function () {\n        return !!(errParamsMemento && angular.equals(errParamsMemento, createComparableParams()));\n      };\n\n      function optimizeFilterDelay() {\n        // don't debounce by default filter input when working with small synchronous datasets\n        if (settings.filterOptions.filterDelay === defaultFilterOptions.filterDelay &&\n          settings.total <= settings.filterOptions.filterDelayThreshold &&\n          settings.getData === defaultSettingsFns.getData) {\n          settings.filterOptions.filterDelay = 0;\n        }\n      }\n\n      this.reloadPages = (function () {\n        var currentPages;\n        return function () {\n          var oldPages = currentPages;\n          var newPages = self.generatePagesArray(self.page(), self.total(), self.count());\n          if (!angular.equals(oldPages, newPages)) {\n            currentPages = newPages;\n            ngTableEventsChannel.publishPagesChanged(this, newPages, oldPages);\n          }\n        }\n      })();\n\n      function runGetData() {\n        var getDataFn = settings.getDataFnAdaptor(settings.getData);\n        return $q.when(getDataFn.call(settings, self));\n      }\n\n      function runGetGroups() {\n        var getGroupsFn = settings.getGroupsFnAdaptor(settings.getGroups);\n        return $q.when(getGroupsFn.call(settings, self));\n      }\n\n      function runInterceptorPipeline(fetchFn) {\n        var interceptors = settings.interceptors || [];\n\n        return interceptors.reduce(function (result, interceptor) {\n          var thenFn = (interceptor.response && interceptor.response.bind(interceptor)) || $q.when;\n          var rejectFn = (interceptor.responseError && interceptor.responseError.bind(interceptor)) || $q.reject;\n          return result.then(function (data) {\n            return thenFn(data, self);\n          }, function (reason) {\n            return rejectFn(reason, self);\n          });\n        }, fetchFn());\n      }\n\n      function getDefaultSettingFns() {\n\n        return {\n          getDataFnAdaptor: angular.identity,\n          getGroupsFnAdaptor: angular.identity,\n          getData: getData,\n          getGroups: getGroups\n        };\n\n        /**\n         * @ngdoc method\n         * @name settings#getData\n         * @description Returns the data to display in the table\n         *\n         * Called by `NgTableParams` whenever it considers new data is to be loaded\n         *\n         * @param {Object} params the `NgTableParams` requesting data\n         */\n        function getData(params) {\n          return ngTableDefaultGetData(params.settings().dataset, params);\n        }\n\n        /**\n         * @ngdoc method\n         * @name settings#getGroups\n         * @description Return groups of data to display in the table\n         *\n         * Called by `NgTableParams` whenever it considers new data is to be loaded\n         * and when a `group` value has been assigned\n         *\n         * @param {Object} params the `NgTableParams` requesting data\n         */\n        function getGroups(params) {\n\n          var group = params.group();\n          var groupFn;\n          var sortDirection = undefined;\n          if (angular.isFunction(group)) {\n            groupFn = group;\n            sortDirection = group.sortDirection;\n          } else {\n            // currently support for only one group implemented\n            var groupField = Object.keys(group)[0];\n            sortDirection = group[groupField];\n            groupFn = function (item) {\n              return getPath(item, groupField);\n            };\n          }\n\n          var settings = params.settings();\n          var originalDataOptions = settings.dataOptions;\n          settings.dataOptions = { applyPaging: false };\n          var adaptedFn = settings.getDataFnAdaptor(settings.getData);\n          var gotData = $q.when(adaptedFn.call(settings, params));\n          return gotData.then(function (data) {\n            var groups = {};\n            angular.forEach(data, function (item) {\n              var groupName = groupFn(item);\n              groups[groupName] = groups[groupName] || {\n                data: [],\n                $hideRows: !settings.groupOptions.isExpanded,\n                value: groupName\n              };\n              groups[groupName].data.push(item);\n            });\n            var result = [];\n            for (var i in groups) {\n              result.push(groups[i]);\n            }\n            if (sortDirection) {\n              var orderByFn = ngTableDefaultGetData.getOrderByFn();\n              var orderBy = convertSortToOrderBy({\n                value: sortDirection\n              });\n              result = orderByFn(result, orderBy);\n            }\n\n            return ngTableDefaultGetData.applyPaging(result, params);\n          }).finally(function () {\n            // restore the real options\n            settings.dataOptions = originalDataOptions;\n          });\n        }\n\n        function getPath(obj, ks) {\n          // origianl source https://github.com/documentcloud/underscore-contrib\n\n          if (typeof ks == \"string\") ks = ks.split(\".\");\n\n          // If we have reached an undefined property\n          // then stop executing and return undefined\n          if (obj === undefined) return void 0;\n\n          // If the path array has no more elements, we've reached\n          // the intended property and return its value\n          if (ks.length === 0) return obj;\n\n          // If we still have elements in the path array and the current\n          // value is null, stop executing and return undefined\n          if (obj === null) return void 0;\n\n          return getPath(obj[ks[0]], ks.slice(1));\n        }\n      }\n\n      var params = {\n        page: 1,\n        count: 10,\n        filter: {},\n        sorting: {},\n        group: {}\n      };\n      angular.extend(params, ngTableDefaults.params);\n\n      /**\n       * @ngdoc object\n       * @name settings\n       * @module ngTable\n       * @description configuration settings for `NgTableParams`\n       */\n      var settings = {\n        // todo: remove $scope after acceptable depreciation period as no longer required\n        $scope: null, // set by ngTable controller\n        $loading: false,\n        dataset: null, //allows data to be set when table is initialized\n        total: 0,\n        defaultSort: 'desc',\n        filterOptions: angular.copy(defaultFilterOptions),\n        groupOptions: angular.copy(defaultGroupOptions),\n        counts: [10, 25, 50, 100],\n        interceptors: [],\n        paginationMaxBlocks: 11,\n        paginationMinBlocks: 5,\n        sortingIndicator: 'span'\n      };\n\n      this.settings(defaultSettingsFns);\n      this.settings(ngTableDefaults.settings);\n      this.settings(baseSettings);\n      this.parameters(baseParameters, true);\n\n      ngTableEventsChannel.publishAfterCreated(this);\n      // run events during construction after the initial create event. That way a consumer\n      // can subscribe to all events for a table without \"dropping\" an event\n      angular.forEach(initialEvents, function (event) {\n        event();\n      });\n      initialEvents = null;\n\n      return this;\n    };\n    return NgTableParams;\n  }]);\n\n  /**\n   * @ngdoc service\n   * @name ngTableParams\n   * @description Backwards compatible shim for lowercase 'n' in NgTableParams\n   */\n  angular.module('ngTable').factory('ngTableParams', ['NgTableParams', function (NgTableParams) {\n    return NgTableParams;\n  }]);\n})();\n\n\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc object\n   * @name ngTableController\n   *\n   * @description\n   * Each {@link ngTable ngTable} directive creates an instance of `ngTableController`\n   */\n  angular.module('ngTable').controller('ngTableController', ['$scope', 'NgTableParams', '$timeout', '$parse', '$compile', '$attrs', '$element',\n    'ngTableColumn', 'ngTableEventsChannel',\n    function ($scope, NgTableParams, $timeout, $parse, $compile, $attrs, $element, ngTableColumn, ngTableEventsChannel) {\n      var isFirstTimeLoad = true;\n      $scope.$filterRow = {};\n      $scope.$loading = false;\n\n      // until such times as the directive uses an isolated scope, we need to ensure that the check for\n      // the params field only consults the \"own properties\" of the $scope. This is to avoid seeing the params\n      // field on a $scope higher up in the prototype chain\n      if (!$scope.hasOwnProperty(\"params\")) {\n        $scope.params = new NgTableParams(true);\n      }\n      $scope.params.settings().$scope = $scope;\n\n      var delayFilter = (function () {\n        var timer = 0;\n        return function (callback, ms) {\n          $timeout.cancel(timer);\n          timer = $timeout(callback, ms);\n        };\n      })();\n\n      function onDataReloadStatusChange(newStatus/*, oldStatus*/) {\n        if (!newStatus || $scope.params.hasErrorState()) {\n          return;\n        }\n\n        $scope.params.settings().$scope = $scope;\n\n        var currentParams = $scope.params;\n        var filterOptions = currentParams.settings().filterOptions;\n\n        if (currentParams.hasFilterChanges()) {\n          var applyFilter = function () {\n            currentParams.page(1);\n            currentParams.reload();\n          };\n          if (filterOptions.filterDelay) {\n            delayFilter(applyFilter, filterOptions.filterDelay);\n          } else {\n            applyFilter();\n          }\n        } else {\n          currentParams.reload();\n        }\n      }\n\n      // watch for when a new NgTableParams is bound to the scope\n      // CRITICAL: the watch must be for reference and NOT value equality; this is because NgTableParams maintains\n      // the current data page as a field. Checking this for value equality would be terrible for performance\n      // and potentially cause an error if the items in that array has circular references\n      $scope.$watch('params', function (newParams, oldParams) {\n        if (newParams === oldParams || !newParams) {\n          return;\n        }\n\n        newParams.reload();\n      }, false);\n\n      $scope.$watch('params.isDataReloadRequired()', onDataReloadStatusChange);\n\n      this.compileDirectiveTemplates = function () {\n        if (!$element.hasClass('ng-table')) {\n          $scope.templates = {\n            header: ($attrs.templateHeader ? $attrs.templateHeader : 'ng-table/header.html'),\n            pagination: ($attrs.templatePagination ? $attrs.templatePagination : 'ng-table/pager.html')\n          };\n          $element.addClass('ng-table');\n          var headerTemplate = null;\n\n          // $element.find('> thead').length === 0 doesn't work on jqlite\n          var theadFound = false;\n          angular.forEach($element.children(), function (e) {\n            if (e.tagName === 'THEAD') {\n              theadFound = true;\n            }\n          });\n          if (!theadFound) {\n            headerTemplate = angular.element(document.createElement('thead')).attr('ng-include', 'templates.header');\n            $element.prepend(headerTemplate);\n          }\n          var paginationTemplate = angular.element(document.createElement('div')).attr({\n            'ng-table-pagination': 'params',\n            'template-url': 'templates.pagination'\n          });\n          $element.after(paginationTemplate);\n          if (headerTemplate) {\n            $compile(headerTemplate)($scope);\n          }\n          $compile(paginationTemplate)($scope);\n        }\n      };\n\n      this.loadFilterData = function ($columns) {\n        angular.forEach($columns, function ($column) {\n          var result;\n          result = $column.filterData($scope);\n          if (!result) {\n            delete $column.filterData;\n            return;\n          }\n\n          // if we're working with a deferred object or a promise, let's wait for the promise\n          /* WARNING: support for returning a $defer is depreciated */\n          if ((angular.isObject(result) && (angular.isObject(result.promise) || angular.isFunction(result.then)))) {\n            var pData = angular.isFunction(result.then) ? result : result.promise;\n            delete $column.filterData;\n            return pData.then(function (data) {\n              // our deferred can eventually return arrays, functions and objects\n              if (!angular.isArray(data) && !angular.isFunction(data) && !angular.isObject(data)) {\n                // if none of the above was found - we just want an empty array\n                data = [];\n              }\n              $column.data = data;\n            });\n          }\n          // otherwise, we just return what the user gave us. It could be a function, array, object, whatever\n          else {\n            return $column.data = result;\n          }\n        });\n      };\n\n      this.buildColumns = function (columns) {\n        var result = [];\n        (columns || []).forEach(function (col) {\n          result.push(ngTableColumn.buildColumn(col, $scope, result));\n        });\n        return result\n      };\n\n      this.parseNgTableDynamicExpr = function (attr) {\n        if (!attr || attr.indexOf(\" with \") > -1) {\n          var parts = attr.split(/\\s+with\\s+/);\n          return {\n            tableParams: parts[0],\n            columns: parts[1]\n          };\n        } else {\n          throw new Error('Parse error (expected example: ng-table-dynamic=\\'tableParams with cols\\')');\n        }\n      };\n\n      this.setupBindingsToInternalScope = function (tableParamsExpr) {\n\n        // note: this we're setting up watches to simulate angular's isolated scope bindings\n\n        // note: is REALLY important to watch for a change to the ngTableParams *reference* rather than\n        // $watch for value equivalence. This is because ngTableParams references the current page of data as\n        // a field and it's important not to watch this\n        var tableParamsGetter = $parse(tableParamsExpr);\n        $scope.$watch(tableParamsGetter, (function (params) {\n          if (angular.isUndefined(params)) {\n            return;\n          }\n          $scope.paramsModel = tableParamsGetter;\n          $scope.params = params;\n        }), false);\n\n        setupFilterRowBindingsToInternalScope();\n        setupGroupRowBindingsToInternalScope();\n      };\n\n      function setupFilterRowBindingsToInternalScope() {\n        if ($attrs.showFilter) {\n          $scope.$parent.$watch($attrs.showFilter, function (value) {\n            $scope.show_filter = value;\n          });\n        } else {\n          $scope.$watch(hasVisibleFilterColumn, function (value) {\n            $scope.show_filter = value;\n          })\n        }\n\n        if ($attrs.disableFilter) {\n          $scope.$parent.$watch($attrs.disableFilter, function (value) {\n            $scope.$filterRow.disabled = value;\n          });\n        }\n      }\n\n      function setupGroupRowBindingsToInternalScope() {\n        $scope.$groupRow = {};\n        if ($attrs.showGroup) {\n          var showGroupGetter = $parse($attrs.showGroup);\n          $scope.$parent.$watch(showGroupGetter, function (value) {\n            $scope.$groupRow.show = value;\n          });\n          if (showGroupGetter.assign) {\n            // setup two-way databinding thus allowing ngTableGrowRow to assign to the showGroup expression\n            $scope.$watch('$groupRow.show', function (value) {\n              showGroupGetter.assign($scope.$parent, value);\n            });\n          }\n        } else {\n          $scope.$watch('params.hasGroup()', function (newValue) {\n            $scope.$groupRow.show = newValue;\n          });\n        }\n      }\n\n      function getVisibleColumns() {\n        return ($scope.$columns || []).filter(function (c) {\n          return c.show($scope);\n        });\n      }\n\n      function hasVisibleFilterColumn() {\n        if (!$scope.$columns) return false;\n\n        return some($scope.$columns, function ($column) {\n          return $column.show($scope) && $column.filter($scope);\n        });\n      }\n\n      function some(array, predicate) {\n        var found = false;\n        for (var i = 0; i < array.length; i++) {\n          var obj = array[i];\n          if (predicate(obj)) {\n            found = true;\n            break;\n          }\n        }\n        return found;\n      }\n\n      function commonInit() {\n        ngTableEventsChannel.onAfterReloadData(bindDataToScope, $scope, isMyPublisher);\n        ngTableEventsChannel.onPagesChanged(bindPagesToScope, $scope, isMyPublisher);\n\n        function bindDataToScope(params, newDatapage) {\n          var visibleColumns = getVisibleColumns();\n          if (params.hasGroup()) {\n            $scope.$groups = newDatapage || [];\n            $scope.$groups.visibleColumnCount = visibleColumns.length;\n          } else {\n            $scope.$data = newDatapage || [];\n            $scope.$data.visibleColumnCount = visibleColumns.length;\n          }\n        }\n\n        function bindPagesToScope(params, newPages) {\n          $scope.pages = newPages\n        }\n\n        function isMyPublisher(publisher) {\n          return $scope.params === publisher;\n        }\n      }\n\n      commonInit();\n    }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc directive\n   * @name ngTable\n   * @module ngTable\n   * @restrict A\n   *\n   * @description\n   * Directive that instantiates {@link ngTableController ngTableController}.\n   */\n  angular.module('ngTable').directive('ngTable', ['$q', '$parse',\n    function ($q, $parse) {\n      'use strict';\n\n      return {\n        restrict: 'A',\n        priority: 1001,\n        scope: true,\n        controller: 'ngTableController',\n        compile: function (element) {\n          var columns = [],\n            i = 0,\n            dataRow,\n            groupRow,\n            rows = [];\n\n          angular.forEach(element.find('tr'), function (tr) {\n            rows.push(angular.element(tr))\n          });\n          dataRow = rows.filter(function (tr) {\n            return !tr.hasClass('ng-table-group');\n          })[0];\n          groupRow = rows.filter(function (tr) {\n            return tr.hasClass('ng-table-group');\n          })[0];\n\n          if (!dataRow) {\n            return;\n          }\n          angular.forEach(dataRow.find('td'), function (item) {\n            var el = angular.element(item);\n            if (el.attr('ignore-cell') && 'true' === el.attr('ignore-cell')) {\n              return;\n            }\n\n            var getAttrValue = function (attr) {\n              return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n            };\n            var setAttrValue = function (attr, value) {\n              if (el.attr('x-data-' + attr)) {\n                el.attr('x-data-' + attr, value)\n              } else if (el.attr('data' + attr)) {\n                el.attr('data' + attr, value)\n              } else {\n                el.attr(attr, value)\n              }\n            };\n\n            var parsedAttribute = function (attr) {\n              var expr = getAttrValue(attr);\n              if (!expr) {\n                return undefined;\n              }\n\n              var localValue;\n              var getter = function (context) {\n                if (localValue !== undefined) {\n                  return localValue;\n                }\n                return $parse(expr)(context);\n              };\n              getter.assign = function ($scope, value) {\n                var parsedExpr = $parse(expr);\n                if (parsedExpr.assign) {\n                  // we should be writing back to the parent scope as this is where the expression\n                  // came from\n                  parsedExpr.assign($scope.$parent, value);\n                } else {\n                  localValue = value;\n                }\n              };\n              return getter;\n            };\n            var titleExpr = getAttrValue('title-alt') || getAttrValue('title');\n            if (titleExpr) {\n              el.attr('data-title-text', '{{' + titleExpr + '}}'); // this used in responsive table\n            }\n            // NOTE TO MAINTAINERS: if you add extra fields to a $column be sure to extend ngTableColumn with\n            // a corresponding \"safe\" default\n            columns.push({\n              id: i++,\n              title: parsedAttribute('title'),\n              titleAlt: parsedAttribute('title-alt'),\n              headerTitle: parsedAttribute('header-title'),\n              sortable: parsedAttribute('sortable'),\n              'class': parsedAttribute('header-class'),\n              filter: parsedAttribute('filter'),\n              groupable: parsedAttribute('groupable'),\n              headerTemplateURL: parsedAttribute('header'),\n              filterData: parsedAttribute('filter-data'),\n              show: el.attr(\"ng-if\") ? parsedAttribute('ng-if') : undefined\n            });\n\n            if (groupRow || el.attr(\"ng-if\")) {\n              // change ng-if to bind to our column definition which we know will be writable\n              // because this will potentially increase the $watch count, only do so if we already have an\n              // ng-if or when we definitely need to change visibility of the columns.\n              // currently only ngTableGroupRow directive needs to change visibility\n              setAttrValue('ng-if', '$columns[' + (columns.length - 1) + '].show(this)');\n            }\n          });\n          return function (scope, element, attrs, controller) {\n            scope.$columns = columns = controller.buildColumns(columns);\n\n            controller.setupBindingsToInternalScope(attrs.ngTable);\n            controller.loadFilterData(columns);\n            controller.compileDirectiveTemplates();\n          };\n        }\n      }\n    }\n  ]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n\n  /**\n   * @ngdoc directive\n   * @name ngTableDynamic\n   * @module ngTable\n   * @restrict A\n   *\n   * @description\n   * A dynamic version of the {@link ngTable ngTable} directive that accepts a dynamic list of columns\n   * definitions to render\n   */\n  angular.module('ngTable').directive('ngTableDynamic', [function () {\n\n    return {\n      restrict: 'A',\n      priority: 1001,\n      scope: true,\n      controller: 'ngTableController',\n      compile: function (tElement) {\n        var row;\n\n        // IE 8 fix :not(.ng-table-group) selector\n        angular.forEach(tElement.find('tr'), function (tr) {\n          tr = angular.element(tr);\n          if (!tr.hasClass('ng-table-group') && !row) {\n            row = tr;\n          }\n        });\n        if (!row) {\n          return;\n        }\n\n        angular.forEach(row.find('td'), function (item) {\n          var el = angular.element(item);\n          var getAttrValue = function (attr) {\n            return el.attr('x-data-' + attr) || el.attr('data-' + attr) || el.attr(attr);\n          };\n\n          // this used in responsive table\n          var titleExpr = getAttrValue('title');\n          if (!titleExpr) {\n            el.attr('data-title-text', '{{$columns[$index].titleAlt(this) || $columns[$index].title(this)}}');\n          }\n          var showExpr = el.attr('ng-if');\n          if (!showExpr) {\n            el.attr('ng-if', '$columns[$index].show(this)');\n          }\n        });\n        return function (scope, element, attrs, controller) {\n          var expr = controller.parseNgTableDynamicExpr(attrs.ngTableDynamic);\n\n          controller.setupBindingsToInternalScope(expr.tableParams);\n          controller.compileDirectiveTemplates();\n\n          scope.$watchCollection(expr.columns, function (newCols/*, oldCols*/) {\n            scope.$columns = controller.buildColumns(newCols);\n            controller.loadFilterData(scope.$columns);\n          });\n        };\n      }\n    };\n  }]);\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .directive('ngTableColumnsBinding', ngTableColumnsBinding);\n\n  ngTableColumnsBinding.$inject = [\"$parse\"];\n\n  /**\n   * @ngdoc directive\n   * @name ngTableColumnsBinding\n   * @description One-way data binds the $columns array generated by ngTable/ngTableDynamic to the specified\n   * expression.\n   *\n   * This allows the $columns array to be accessed outside of the html table markup\n   */\n  function ngTableColumnsBinding($parse) {\n    var directive = {\n      restrict: 'A',\n      require: 'ngTable',\n      link: linkFn\n    };\n    return directive;\n\n    function linkFn($scope, $element, $attrs) {\n      var setter = $parse($attrs.ngTableColumnsBinding).assign;\n      if (setter) {\n        $scope.$watch('$columns', function (newColumns) {\n          var shallowClone = (newColumns || []).slice(0);\n          setter($scope, shallowClone);\n        });\n      }\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  /**\n   * @ngdoc directive\n   * @name ngTablePagination\n   * @module ngTable\n   * @restrict A\n   */\n  angular.module('ngTable').directive('ngTablePagination', ['$compile', 'ngTableEventsChannel',\n    function ($compile, ngTableEventsChannel) {\n      'use strict';\n\n      return {\n        restrict: 'A',\n        scope: {\n          'params': '=ngTablePagination',\n          'templateUrl': '='\n        },\n        replace: false,\n        link: function (scope, element/*, attrs*/) {\n\n          ngTableEventsChannel.onAfterReloadData(function (pubParams) {\n            scope.pages = pubParams.generatePagesArray();\n          }, scope, function (pubParams) {\n            return pubParams === scope.params;\n          });\n\n          scope.$watch('templateUrl', function (templateUrl) {\n            if (angular.isUndefined(templateUrl)) {\n              return;\n            }\n            var template = angular.element(document.createElement('div'));\n            template.attr({\n              'ng-include': 'templateUrl'\n            });\n            element.append(template);\n            $compile(template)(scope);\n          });\n        }\n      };\n    }\n  ]);\n\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .controller('ngTableFilterRowController', ngTableFilterRowController);\n\n  ngTableFilterRowController.$inject = ['$scope', 'ngTableFilterConfig'];\n\n  function ngTableFilterRowController($scope, ngTableFilterConfig) {\n\n    $scope.config = ngTableFilterConfig;\n\n    $scope.getFilterCellCss = function (filter, layout) {\n      if (layout !== 'horizontal') {\n        return 's12';\n      }\n\n      var size = Object.keys(filter).length;\n      var width = parseInt(12 / size, 10);\n      return 's' + width;\n    };\n\n    $scope.getFilterPlaceholderValue = function (filterValue/*, filterName*/) {\n      if (angular.isObject(filterValue)) {\n        return filterValue.placeholder;\n      } else {\n        return '';\n      }\n    };\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .directive('ngTableFilterRow', ngTableFilterRow);\n\n  ngTableFilterRow.$inject = [];\n\n  function ngTableFilterRow() {\n    var directive = {\n      restrict: 'E',\n      replace: true,\n      templateUrl: 'ng-table/filterRow.html',\n      scope: true,\n      controller: 'ngTableFilterRowController'\n    };\n    return directive;\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .controller('ngTableGroupRowController', ngTableGroupRowController);\n\n  ngTableGroupRowController.$inject = ['$scope'];\n\n  function ngTableGroupRowController($scope) {\n\n    var groupFns = [];\n\n    init();\n\n    function init() {\n      $scope.getGroupables = getGroupables;\n      $scope.getGroupTitle = getGroupTitle;\n      $scope.getVisibleColumns = getVisibleColumns;\n      $scope.groupBy = groupBy;\n      $scope.isSelectedGroup = isSelectedGroup;\n      $scope.toggleDetail = toggleDetail;\n\n      $scope.$watch('params.group()', setGroup, true);\n    }\n\n    function changeSortDirection() {\n      var newDirection;\n      if ($scope.params.hasGroup($scope.$selGroup, 'asc')) {\n        newDirection = 'desc';\n      } else if ($scope.params.hasGroup($scope.$selGroup, 'desc')) {\n        newDirection = '';\n      } else {\n        newDirection = 'asc';\n      }\n      $scope.params.group($scope.$selGroup, newDirection);\n    }\n\n    function findGroupColumn(groupKey) {\n      return $scope.$columns.filter(function ($column) {\n        return $column.groupable($scope) === groupKey;\n      })[0];\n    }\n\n    function getGroupTitle(group) {\n      return angular.isFunction(group) ? group.title : group.title($scope);\n    }\n\n    function getGroupables() {\n      var groupableCols = $scope.$columns.filter(function ($column) {\n        return $column.groupable($scope);\n      });\n      return groupFns.concat(groupableCols);\n    }\n\n    function getVisibleColumns() {\n      return $scope.$columns.filter(function ($column) {\n        return $column.show($scope);\n      })\n    }\n\n    function groupBy(group) {\n      if (isSelectedGroup(group)) {\n        changeSortDirection();\n      } else {\n        if (group.groupable) {\n          $scope.params.group(group.groupable($scope));\n        } else {\n          $scope.params.group(group);\n        }\n      }\n    }\n\n    function isSelectedGroup(group) {\n      if (group.groupable) {\n        return group.groupable($scope) === $scope.$selGroup;\n      } else {\n        return group === $scope.$selGroup;\n      }\n    }\n\n    function setGroup(group) {\n      var existingGroupCol = findGroupColumn($scope.$selGroup);\n      if (existingGroupCol && existingGroupCol.show.assign) {\n        existingGroupCol.show.assign($scope, true);\n      }\n      if (angular.isFunction(group)) {\n        groupFns = [group];\n        $scope.$selGroup = group;\n        $scope.$selGroupTitle = group.title;\n      } else {\n        // note: currently only one group is implemented\n        var groupKey = Object.keys(group || {})[0];\n        var groupedColumn = findGroupColumn(groupKey);\n        if (groupedColumn) {\n          $scope.$selGroupTitle = groupedColumn.title($scope);\n          $scope.$selGroup = groupKey;\n          if (groupedColumn.show.assign) {\n            groupedColumn.show.assign($scope, false);\n          }\n        }\n      }\n    }\n\n    function toggleDetail() {\n      $scope.params.settings().groupOptions.isExpanded = !$scope.params.settings().groupOptions.isExpanded;\n      return $scope.params.reload();\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .directive('ngTableGroupRow', ngTableGroupRow);\n\n  ngTableGroupRow.$inject = [];\n\n  function ngTableGroupRow() {\n    var directive = {\n      restrict: 'E',\n      replace: true,\n      templateUrl: 'ng-table/groupRow.html',\n      scope: true,\n      controller: 'ngTableGroupRowController',\n      controllerAs: 'dctrl'\n    };\n    return directive;\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .controller('ngTableSorterRowController', ngTableSorterRowController);\n\n  ngTableSorterRowController.$inject = ['$scope'];\n\n  function ngTableSorterRowController($scope) {\n\n    $scope.sortBy = sortBy;\n\n    ///////////\n\n    function sortBy($column, event) {\n      var parsedSortable = $column.sortable && $column.sortable();\n      if (!parsedSortable) {\n        return;\n      }\n      var defaultSort = $scope.params.settings().defaultSort;\n      var inverseSort = (defaultSort === 'asc' ? 'desc' : 'asc');\n      var sorting = $scope.params.sorting() && $scope.params.sorting()[parsedSortable] && ($scope.params.sorting()[parsedSortable] === defaultSort);\n      var sortingParams = (event.ctrlKey || event.metaKey) ? $scope.params.sorting() : {};\n      sortingParams[parsedSortable] = (sorting ? inverseSort : defaultSort);\n      $scope.params.parameters({\n        sorting: sortingParams\n      });\n    }\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  angular.module('ngTable')\n    .directive('ngTableSorterRow', ngTableSorterRow);\n\n  ngTableSorterRow.$inject = [];\n\n  function ngTableSorterRow() {\n    var directive = {\n      restrict: 'E',\n      replace: true,\n      templateUrl: 'ng-table/sorterRow.html',\n      scope: true,\n      controller: 'ngTableSorterRowController'\n    };\n    return directive;\n  }\n})();\n\n/**\n * ngTable: Table + Angular JS\n *\n * @author Vitalii Savchuk <esvit666@gmail.com>\n * @url https://github.com/esvit/ng-table/\n * @license New BSD License <http://creativecommons.org/licenses/BSD/>\n */\n\n(function () {\n  'use strict';\n\n  /**\n   * @ngdoc directive\n   * @name ngTableSelectFilterDs\n   * @module ngTable\n   * @restrict A\n   *\n   * @description\n   * Takes the array returned by $column.filterData and makes it available as `$selectData` on the `$scope`.\n   *\n   * The resulting `$selectData` array will contain an extra item that is suitable to represent the user\n   * \"deselecting\" an item from a `<select>` tag\n   *\n   * This directive is is focused on providing a datasource to an `ngOptions` directive\n   */\n  angular.module('ngTable')\n    .directive('ngTableSelectFilterDs', ngTableSelectFilterDs);\n\n  ngTableSelectFilterDs.$inject = [];\n\n  function ngTableSelectFilterDs() {\n    // note: not using isolated or child scope \"by design\"\n    // this is to allow this directive to be combined with other directives that do\n\n    var directive = {\n      restrict: 'A',\n      controller: ngTableSelectFilterDsController\n    };\n    return directive;\n  }\n\n  ngTableSelectFilterDsController.$inject = ['$scope', '$parse', '$attrs', '$q'];\n  function ngTableSelectFilterDsController($scope, $parse, $attrs, $q) {\n\n    var $column = {};\n    init();\n\n    function init() {\n      $column = $parse($attrs.ngTableSelectFilterDs)($scope);\n      $scope.$watch(function () {\n        return $column.data;\n      }, bindDataSource);\n    }\n\n    function bindDataSource() {\n      getSelectListData($column).then(function (data) {\n        if (data && !hasEmptyOption(data)) {\n          data.unshift({ id: '', title: '' });\n        }\n        data = data || [];\n        $scope.$selectData = data;\n      });\n    }\n\n    function hasEmptyOption(data) {\n      var isMatch;\n      for (var i = 0; i < data.length; i++) {\n        var item = data[i];\n        if (item && item.id === '') {\n          isMatch = true;\n          break;\n        }\n      }\n      return isMatch;\n    }\n\n    function getSelectListData($column) {\n      var data = angular.isFunction($column.data) ? $column.data() : $column.data;\n      return $q.when(data);\n    }\n  }\n})();\n\nangular.module('ngTable').run(['$templateCache', function ($templateCache) {\n  $templateCache.put('ng-table/filterRow.html', '<tr ng-show=\"show_filter\" class=\"ng-table-filters\"> <th data-title-text=\"{{$column.titleAlt(this) || $column.title(this)}}\" ng-repeat=\"$column in $columns\" ng-if=\"$column.show(this)\" class=\"filter {{$column.class(this)}}\" ng-class=\"params.settings().filterOptions.filterLayout===\\'horizontal\\' ? \\'filter-horizontal\\' : \\'\\'\"> <div ng-repeat=\"(name, filter) in $column.filter(this)\" ng-include=\"config.getTemplateUrl(filter)\" class=\"filter-cell\" ng-class=\"[getFilterCellCss($column.filter(this), params.settings().filterOptions.filterLayout), $last ? \\'last\\' : \\'\\']\"> </div> </th> </tr> ');\n  $templateCache.put('ng-table/filters/number.html', '<input type=\"number\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n  $templateCache.put('ng-table/filters/select-multiple.html', '<select ng-options=\"data.id as data.title for data in $column.data\" ng-disabled=\"$filterRow.disabled\" multiple ng-multiple=\"true\" ng-model=\"params.filter()[name]\" class=\"filter filter-select-multiple form-control\" name=\"{{name}}\"> </select> ');\n  $templateCache.put('ng-table/filters/select.html', '<select ng-options=\"data.id as data.title for data in $selectData\" ng-table-select-filter-ds=\"$column\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"filter filter-select form-control\" name=\"{{name}}\"> <option style=\"display:none\" value=\"\"></option> </select> ');\n  $templateCache.put('ng-table/filters/text.html', '<input type=\"text\" name=\"{{name}}\" ng-disabled=\"$filterRow.disabled\" ng-model=\"params.filter()[name]\" class=\"input-filter form-control\" placeholder=\"{{getFilterPlaceholderValue(filter, name)}}\"/> ');\n  $templateCache.put('ng-table/groupRow.html', '<tr ng-if=\"params.hasGroup()\" ng-show=\"$groupRow.show\" class=\"ng-table-group-header\"> <th colspan=\"{{getVisibleColumns().length}}\" class=\"sortable\" ng-class=\"{ \\'sort-asc\\': params.hasGroup($selGroup, \\'asc\\'), \\'sort-desc\\':params.hasGroup($selGroup, \\'desc\\') }\"> <a href=\"\" ng-click=\"isSelectorOpen=!isSelectorOpen\" class=\"ng-table-group-selector\"> <strong class=\"sort-indicator\">{{$selGroupTitle}}</strong> <button class=\"btn btn-default btn-xs ng-table-group-close\" ng-click=\"$groupRow.show=false; $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon glyphicon-remove\"></span> </button> <button class=\"btn btn-default btn-xs ng-table-group-toggle\" ng-click=\"toggleDetail(); $event.preventDefault(); $event.stopPropagation();\"> <span class=\"glyphicon\" ng-class=\"{ \\'glyphicon-resize-small\\': params.settings().groupOptions.isExpanded, \\'glyphicon-resize-full\\': !params.settings().groupOptions.isExpanded }\"></span> </button> </a> <div class=\"list-group\" ng-if=\"isSelectorOpen\"> <a href=\"\" class=\"list-group-item\" ng-repeat=\"group in getGroupables()\" ng-click=\"groupBy(group)\"> <strong>{{ getGroupTitle(group)}}</strong> <strong ng-class=\"isSelectedGroup(group) && \\'sort-indicator\\'\"></strong> </a> </div> </th> </tr> ');\n  $templateCache.put('ng-table/header.html', '<ng-table-group-row></ng-table-group-row> <ng-table-sorter-row></ng-table-sorter-row> <ng-table-filter-row></ng-table-filter-row> ');\n  $templateCache.put('ng-table/pager.html', '<div class=\"ng-cloak ng-table-pager\" ng-if=\"params.data.length\"> <div ng-if=\"params.settings().counts.length\" class=\"ng-table-counts btn-group pull-right\"> <button ng-repeat=\"count in params.settings().counts\" type=\"button\" ng-class=\"{\\'active\\':params.count()==count}\" ng-click=\"params.count(count)\" class=\"btn btn-default\"> <span ng-bind=\"count\"></span> </button> </div> <ul ng-if=\"pages.length\" class=\"pagination ng-table-pagination\"> <li ng-class=\"{\\'disabled\\': !page.active && !page.current, \\'active\\': page.current}\" ng-repeat=\"page in pages\" ng-switch=\"page.type\"> <a ng-switch-when=\"prev\" ng-click=\"params.page(page.number)\" href=\"\">&laquo;</a> <a ng-switch-when=\"first\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"page\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"more\" ng-click=\"params.page(page.number)\" href=\"\">&#8230;</a> <a ng-switch-when=\"last\" ng-click=\"params.page(page.number)\" href=\"\"><span ng-bind=\"page.number\"></span></a> <a ng-switch-when=\"next\" ng-click=\"params.page(page.number)\" href=\"\">&raquo;</a> </li> </ul> </div> ');\n  $templateCache.put('ng-table/sorterRow.html', '<tr class=\"ng-table-sort-header\"> <th title=\"{{$column.headerTitle(this)}}\" ng-repeat=\"$column in $columns\" ng-class=\"{ \\'sortable\\': $column.sortable(this), \\'sort-asc\\': params.sorting()[$column.sortable(this)]==\\'asc\\', \\'sort-desc\\': params.sorting()[$column.sortable(this)]==\\'desc\\' }\" ng-click=\"sortBy($column, $event)\" ng-if=\"$column.show(this)\" ng-init=\"template=$column.headerTemplateURL(this)\" class=\"header {{$column.class(this)}}\"> <div ng-if=\"!template\" class=\"ng-table-header\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'div\\'}\"> <span ng-bind=\"$column.title(this)\" ng-class=\"{\\'sort-indicator\\': params.settings().sortingIndicator==\\'span\\'}\"></span> </div> <div ng-if=\"template\" ng-include=\"template\"></div> </th> </tr> ');\n}]);\n\nexport default angular.module('ngTable');\n\n\n\n// WEBPACK FOOTER //\n// ./lib/ffanTable/index.js","exports = module.exports = require(\"./../../../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/less-loader!./example/app/components/table/table.less\n// module id = 715\n// module chunks = 28","import template from './table.html';\nimport controller from './table.controller.js';\nimport './table.less';\n\nexport default {\n  restrict: 'E',\n  bindings: {},\n  template,\n  controller,\n  controllerAs: 'vm'\n};\n\n\n\n// WEBPACK FOOTER //\n// ./example/app/components/table/table.component.js","/**\n * (description)\n *\n * @author yourname\n */\n\nexport default class TableController {\n\tconstructor(NgTableParams, $state) {\n\t\t\"ngInject\";\n\t\tthis.$state = $state;\n\t\tthis.NgTableParams = NgTableParams;\n\t\tthis.data = {\n      \"total\": 85,\n      \"datas\": [\n        {\n          \"name\": 'fix_web',\n          \"viewName\": \"tool-wd\",\n          \"lastStatus\": \"SUCCESS\",\n          \"lastNO\": \"#10\",\n          \"lastFailNO\": \"#4\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"name\": 'fix_web',\n\t\t\t\t\t\"viewName\": \"tool-wd\",\n\t\t\t\t\t\"lastStatus\": \"SUCCESS\",\n\t\t\t\t\t\"lastNO\": \"#10\",\n\t\t\t\t\t\"lastFailNO\": \"#4\"\n\t\t\t\t}\n\t\t\t]\n    };\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\tthis.getDataList();\n\t}\n\n\tgetDataList() {\n\t\tvar self = this;\n\t\tvar self = this;\n    self.tableParams = new this.NgTableParams({\n      page: 1,\n      count: 5\n    }, {\n\t\t\t\tcounts: [],\n\t\t\t\tgetData: function (params) {\n\t\t\t\t\tparams.total(self.data.total);\n\t\t\t\t\treturn self.data.datas;\n\t\t\t\t}\n\t\t\t});\n\t}\n}\n\n\n// WEBPACK FOOTER //\n// ./example/app/components/table/table.controller.js"],"sourceRoot":""}